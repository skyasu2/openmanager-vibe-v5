# ğŸš€ AI ìë™ ì½”ë“œ ë¦¬ë·° ë¦¬í¬íŠ¸ (Engine: CODEX)

**ë‚ ì§œ**: 2026-01-24 19-28-05
**ì»¤ë°‹**: `65c6c98ab`
**ë¸Œëœì¹˜**: `main`
**AI ì—”ì§„**: **CODEX**

---

## ğŸ” ì‹¤ì‹œê°„ ê²€ì¦ ê²°ê³¼ (2026-01-24 19:28:06)

```
ESLint: ìë™ ê²€ì¦ (pre-push)
TypeScript: ìë™ ê²€ì¦ (pre-push)
```

**ê²€ì¦ ë¡œê·¸ íŒŒì¼**:
- ESLint: `logs/validation/`
- TypeScript: `logs/validation/`

---

## ğŸ“Š ë³€ê²½ì‚¬í•­ ìš”ì•½

**ì»¤ë°‹**: `65c6c98ab1e55c9a880e969293b043d649a93b8a`
**ë©”ì‹œì§€**: refactor(medium): P2 performance and reliability improvements

## ğŸ“„ cloud-run/ai-engine/src/lib/cache-layer.ts

```diff
diff --git a/cloud-run/ai-engine/src/lib/cache-layer.ts b/cloud-run/ai-engine/src/lib/cache-layer.ts
index b659abe5e..082059d90 100644
--- a/cloud-run/ai-engine/src/lib/cache-layer.ts
+++ b/cloud-run/ai-engine/src/lib/cache-layer.ts
@@ -153,17 +153,31 @@ export class DataCacheLayer {
 
   /**
    * Set item in cache
+   * ğŸ¯ P2-4 Fix: Cleanup BEFORE insert to prevent temporary maxSize overflow
    */
   set<T>(type: CacheType, identifier: string, data: T): void {
     const key = this.generateKey(type, identifier);
+
+    // P2-4: Pre-insert size check and cleanup
+    // If at or over capacity (before new insert), cleanup first
+    if (this.cache.size >= this.config.maxSize) {
+      this.cleanup();
+
+      // If still at capacity after cleanup, force-evict oldest entry
+      if (this.cache.size >= this.config.maxSize) {
+        const oldestKey = this.cache.keys().next().value;
+        if (oldestKey) {
+          this.cache.delete(oldestKey);
+        }
+      }
+    }
+
     this.cache.set(key, {
       data,
       cachedAt: Date.now(),
       ttl: this.getTTL(type),
       hits: 0,
     });
-
-    this.cleanup(); // Cleanup after adding to enforce maxSize
   }
 
   /**
```

## ğŸ“„ cloud-run/ai-engine/src/services/ai-sdk/supervisor.ts

```diff
diff --git a/cloud-run/ai-engine/src/services/ai-sdk/supervisor.ts b/cloud-run/ai-engine/src/services/ai-sdk/supervisor.ts
index 6d6b4a408..55f05cdaf 100644
--- a/cloud-run/ai-engine/src/services/ai-sdk/supervisor.ts
+++ b/cloud-run/ai-engine/src/services/ai-sdk/supervisor.ts
@@ -20,6 +20,7 @@ import {
   hasToolCall,
   createUIMessageStream,
   createUIMessageStreamResponse,
+  generateId, // ğŸ¯ P2-2: Cryptographically secure ID generation
   type ModelMessage,
 } from 'ai';
 import { getSupervisorModel, logProviderStatus, type ProviderName } from './model-provider';
@@ -497,15 +498,26 @@ async function executeSupervisorAttempt(
           toolsCalled.push(toolCall.toolName);
         }
         // toolResultsëŠ” step.toolResultsì—ì„œ ì¶”ì¶œ
+        // AI SDK v6 í˜¸í™˜: ì—¬ëŸ¬ toolResult êµ¬ì¡° ëŒ€ì‘
         if (step.toolResults) {
           for (const tr of step.toolResults) {
             if ('result' in tr) {
               toolResults.push(tr.result as Record<string, unknown>);
               // Log tool call to Langfuse
               logToolCall(trace, tr.toolName, {}, tr.result, 0);
-              // Check for finalAnswer tool result
-              if (tr.toolName === 'finalAnswer' && tr.result && typeof tr.result === 'object') {
-                finalAnswerResult = tr.result as { answer: string };
+            }
+
+            // Check for finalAnswer tool result (AI SDK v6 Best Practice)
+            // Case 1: result í”„ë¡œí¼í‹°ì— answerê°€ ìˆëŠ” ê²½ìš°
+            // Case 2: toolResult ìì²´ì— answerê°€ ìˆëŠ” ê²½ìš°
+            if (tr.toolName === 'finalAnswer') {
+              if ('result' in tr && tr.result && typeof tr.result === 'object') {
+                const result = tr.result as Record<string, unknown>;
+                if ('answer' in result && typeof result.answer === 'string') {
+                  finalAnswerResult = { answer: result.answer };
+                }
+              } else if ('answer' in tr && typeof (tr as Record<string, unknown>).answer === 'string') {
+                finalAnswerResult = { answer: (tr as Record<string, unknown>).answer as string };
               }
             }
           }
@@ -731,6 +743,16 @@ async function* streamSingleAgent(
       stopWhen: [hasToolCall('finalAnswer'), stepCountIs(3)],
       temperature: 0.4,
       maxOutputTokens: 1536,
+      // ğŸ¯ Phase 3: AI SDK v6 ê¶Œì¥ - onError ì½œë°± ì¶”ê°€
+      // ìŠ¤íŠ¸ë¦¼ ì—ëŸ¬ ë°œìƒ ì‹œ ë¡œê¹… (Cloud Runì—ì„œ ë””ë²„ê¹…ìš©)
+      onError: ({ error }) => {
+        console.error('âŒ [SingleAgent] streamText error:', {
+          error: error instanceof Error ? error.message : String(error),
+          model: modelId,
+          provider,
+          query: queryText.substring(0, 100),
+        });
+      },
     });
 
     // Hard timeout constant (50s - increased from 45s for complex queries)
@@ -865,6 +887,24 @@ function getIntentCategory(query: string): IntentCategory {
   return 'general';
 }
 
+// ============================================================================
+// ğŸ¯ P2-1 Fix: Pre-compiled Regex Patterns for Tool Routing
+// Compiled once at module load, not per-request (~3x perf improvement)
+// ============================================================================
+
+const TOOL_ROUTING_PATTERNS = {
+  /** ì´ìƒ íƒì§€: ê¸‰ì¦/ê¸‰ê°/ìŠ¤íŒŒì´í¬/anomaly ë“± */
+  anomaly: /ì´ìƒ|ê¸‰ì¦|ê¸‰ê°|ìŠ¤íŒŒì´í¬|anomal|íƒì§€|ê°ì§€|ë¹„ì •ìƒ/i,
+  /** ì˜ˆì¸¡/íŠ¸ë Œë“œ ë¶„ì„ */
+  prediction: /ì˜ˆì¸¡|íŠ¸ë Œë“œ|ì¶”ì´|ì „ë§|forecast|ì¶”ì„¸/i,
+  /** RCA: ê·¼ë³¸ ì›ì¸ ë¶„ì„, ì¥ì• , ì¸ì‹œë˜íŠ¸ */
+  rca: /ì¥ì• |rca|íƒ€ì„ë¼ì¸|ìƒê´€ê´€ê³„|ì›ì¸|ì™œ|ê·¼ë³¸|incident/i,
+  /** Advisor: í•´ê²° ë°©ë²•, ëª…ë ¹ì–´, ê³¼ê±° ì‚¬ë¡€ */
+  advisor: /í•´ê²°|ë°©ë²•|ëª…ë ¹ì–´|ê°€ì´ë“œ|ì´ë ¥|ê³¼ê±°|ì‚¬ë¡€|ê²€ìƒ‰/i,
+  /** Server Group: DB/Web/Cache/LB ë“± */
+  serverGroup: /(db|web|cache|lb|api|storage|ë¡œë“œ\s*ë°¸ëŸ°ì„œ|ìºì‹œ|ìŠ¤í† ë¦¬ì§€)\s*(ì„œë²„)?/i,
+} as const;
+
 /**
  * Create prepareStep function for runtime tool filtering
  * AI SDK v6 Best Practice: Filter tools dynamically based on query intent
@@ -885,38 +925,44 @@ function createPrepareStep(query: string) {
     if (stepNumber > 0) return {};
 
     // AI SDK v6 Best Practice: Order patterns from specific to general
-    // CODEX Review: "ì›ì¸/ì™œ" should match RCA before Analyst for proper root cause analysis
+    // ìš°ì„ ìˆœìœ„: ëª…ì‹œì  ì´ìƒíƒì§€ â†’ ì˜ˆì¸¡/íŠ¸ë Œë“œ â†’ RCA â†’ Reporter â†’ Server Group â†’ Default
 
-    // RCA: root cause analysis (PRIORITY - check before Analyst)
-    // Includes "ì›ì¸", "ì™œ" which need RCA tools
-    if (/ì¥ì• |rca|íƒ€ì„ë¼ì¸|ìƒê´€ê´€ê³„|ì›ì¸|ì™œ/.test(q)) {
+    // 1. ëª…ì‹œì  ì´ìƒíƒì§€ ìš”ì²­ (ìµœìš°ì„  - Analyst)
+    if (TOOL_ROUTING_PATTERNS.anomaly.test(q)) {
       return {
-        activeTools: ['findRootCause', 'buildIncidentTimeline', 'correlateMetrics', 'getServerMetrics', 'detectAnomalies', 'finalAnswer'] as ToolName[]
+        activeTools: ['detectAnomalies', 'predictTrends', 'analyzePattern', 'getServerMetrics', 'finalAnswer'] as ToolName[]
       };
```

## ğŸ“„ cloud-run/ai-engine/src/tools-ai-sdk/reporter-tools.ts

```diff
diff --git a/cloud-run/ai-engine/src/tools-ai-sdk/reporter-tools.ts b/cloud-run/ai-engine/src/tools-ai-sdk/reporter-tools.ts
index e41936c04..24ca165df 100644
--- a/cloud-run/ai-engine/src/tools-ai-sdk/reporter-tools.ts
+++ b/cloud-run/ai-engine/src/tools-ai-sdk/reporter-tools.ts
@@ -397,7 +397,15 @@ interface WebSearchResult {
 const TAVILY_TIMEOUT_MS = 10000; // 10ì´ˆ íƒ€ì„ì•„ì›ƒ (ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤: 1-5ì´ˆ, ì—¬ìœ ìˆê²Œ 10ì´ˆ)
 const TAVILY_MAX_RETRIES = 2; // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ (ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤: 2íšŒ)
 const TAVILY_RETRY_DELAY_MS = 1000; // ì¬ì‹œë„ ê°„ ëŒ€ê¸° ì‹œê°„
-const TAVILY_CACHE_TTL_MS = 5 * 60 * 1000; // 5ë¶„ ìºì‹œ (ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤: ë°˜ë³µ ì¿¼ë¦¬ ìºì‹±)
+/**
+ * Web Search Cache Configuration
+ * Cloud Run Free Tier: 256MB RAM ì œí•œ ê³ ë ¤
+ */
+const SEARCH_CACHE_CONFIG = {
+  maxSize: 30,              // ë¬´ë£Œ í‹°ì–´ ë©”ëª¨ë¦¬ ì œí•œ ê³ ë ¤ (100 â†’ 30)
+  evictCount: 10,           // í•œ ë²ˆì— 10ê°œ ì‚­ì œ (LRU)
+  ttlMs: 10 * 60 * 1000,    // 10ë¶„ TTL (5ë¶„ â†’ 10ë¶„ìœ¼ë¡œ ì¦ê°€, ìºì‹œ íš¨ìœ¨)
+} as const;
 
 /**
  * Simple in-memory cache for web search results
@@ -412,26 +420,47 @@ const searchCache = new Map<string, CacheEntry>();
 
 /**
  * Get cached result if valid
+ * LRU ë°©ì‹: ì¡°íšŒ ì‹œ TTL ë§Œë£Œ í•­ëª© ì •ë¦¬
  */
 function getCachedResult(query: string): { results: WebSearchResult[]; answer: string | null } | null {
-  const cached = searchCache.get(query.toLowerCase().trim());
-  if (cached && Date.now() - cached.timestamp < TAVILY_CACHE_TTL_MS) {
-    console.log(`ğŸ“¦ [Tavily] Cache hit for: "${query.substring(0, 30)}..."`);
-    return { results: cached.results, answer: cached.answer };
+  const key = query.toLowerCase().trim();
+  const cached = searchCache.get(key);
+  const now = Date.now();
+
+  if (!cached) return null;
+
+  // TTL ë§Œë£Œ ì²´í¬
+  if (now - cached.timestamp > SEARCH_CACHE_CONFIG.ttlMs) {
+    searchCache.delete(key);
+    return null;
   }
-  return null;
+
+  console.log(`ğŸ“¦ [Tavily] Cache hit for: "${query.substring(0, 30)}..." (size: ${searchCache.size})`);
+  return { results: cached.results, answer: cached.answer };
 }
 
 /**
- * Store result in cache
+ * Store result in cache with LRU eviction
+ * Cloud Run Free Tier ë©”ëª¨ë¦¬ ì œí•œ ëŒ€ì‘
  */
 function setCacheResult(query: string, results: WebSearchResult[], answer: string | null): void {
-  // Limit cache size to prevent memory leak
-  if (searchCache.size > 100) {
-    const oldestKey = searchCache.keys().next().value;
-    if (oldestKey) searchCache.delete(oldestKey);
+  const now = Date.now();
+
+  // 1. TTL ë§Œë£Œ í•­ëª© ë¨¼ì € ì •ë¦¬
+  for (const [key, entry] of searchCache) {
+    if (now - entry.timestamp > SEARCH_CACHE_CONFIG.ttlMs) {
+      searchCache.delete(key);
+    }
   }
-  searchCache.set(query.toLowerCase().trim(), { results, answer, timestamp: Date.now() });
+
+  // 2. í¬ê¸° ì œí•œ (LRU ë°©ì‹ - ì˜¤ë˜ëœ í•­ëª©ë¶€í„° ì‚­ì œ)
+  if (searchCache.size >= SEARCH_CACHE_CONFIG.maxSize) {
+    const keysToDelete = [...searchCache.keys()].slice(0, SEARCH_CACHE_CONFIG.evictCount);
+    keysToDelete.forEach(k => searchCache.delete(k));
+    console.log(`ğŸ—‘ï¸ [Tavily] Cache evicted ${keysToDelete.length} entries (LRU)`);
+  }
+
+  searchCache.set(query.toLowerCase().trim(), { results, answer, timestamp: now });
 }
 
 /**
```

---

## ğŸš€ AI ë¦¬ë·° ê²°ê³¼

**ë¦¬ë·° ê²°ê³¼**

- **[High] ìºì‹œ overwrite ì‹œ ë¶ˆí•„ìš”í•œ ê°•ì œ eviction ë°œìƒ ê°€ëŠ¥**
  - ìœ„ì¹˜: `cloud-run/ai-engine/src/lib/cache-layer.ts:158-176`
  - ë¬¸ì œ: `set()`ì´ key êµì²´ì¸ ê²½ìš°ì—ë„ `this.cache.size >= maxSize`ì´ë©´ cleanup/evictionì„ ì‹¤í–‰í•©ë‹ˆë‹¤. ê¸°ì¡´ í‚¤ ì—…ë°ì´íŠ¸ëŠ” size ì¦ê°€ê°€ ì—†ëŠ”ë°ë„ ë‹¤ë¥¸ ì—”íŠ¸ë¦¬ê°€ ì‚­ì œë  ìˆ˜ ìˆì–´ ìºì‹œ ì •í•©ì„±/íš¨ìœ¨ì´ ë–¨ì–´ì§‘ë‹ˆë‹¤.
  - ê°œì„  ìŠ¤ë‹ˆí«:
    ```ts
    set<T>(type: CacheType, identifier: string, data: T): void {
      const key = this.generateKey(type, identifier);
      const exists = this.cache.has(key);

      // cleanupì€ ë³„ë„ë¡œ ìœ ì§€í•˜ë˜, ê°•ì œ evictionì€ ì‹ ê·œ insertì¼ ë•Œë§Œ
      if (!exists && this.cache.size >= this.config.maxSize) {
        this.cleanup();
        if (this.cache.size >= this.config.maxSize) {
          const oldestKey = this.cache.keys().next().value;
          if (oldestKey) this.cache.delete(oldestKey);
        }
      } else if (exists) {
        // í•„ìš” ì‹œ ë§Œë£Œ ì •ë¦¬ëŠ” ìœ ì§€
        this.cleanup();
      }

      this.cache.set(key, {
        data,
        cachedAt: Date.now(),
        ttl: this.getTTL(type),
        hits: 0,
      });
    }
    ```

- **[Medium] ì˜ë„í•œ íŒ¨í„´ê³¼ ì‹¤ì œ ë¡œê¹… ë¶„ê¸° ë¶ˆì¼ì¹˜**
  - ìœ„ì¹˜: `cloud-run/ai-engine/src/services/ai-sdk/supervisor.ts:880-887`, `895-968`
  - ë¬¸ì œ: `getIntentCategory()`ëŠ” â€œcreatePrepareStepê³¼ syncâ€ë¼ê³  ì£¼ì„ì´ ìˆìœ¼ë‚˜ ì‹¤ì œë¡œëŠ” `TOOL_ROUTING_PATTERNS`ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. íŒ¨í„´ ë³€ê²½ ì‹œ ë¡œê¹…/ë¶„ì„ ì§€í‘œê°€ ì‹¤ì œ ë¼ìš°íŒ…ê³¼ ë¶ˆì¼ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  - ê°œì„  ìŠ¤ë‹ˆí«:
    ```ts
    function getIntentCategory(query: string): IntentCategory {
      const q = query.toLowerCase();
      if (TOOL_ROUTING_PATTERNS.rca.test(q)) return 'rca';
      if (TOOL_ROUTING_PATTERNS.advisor.test(q)) return 'reporter';
      if (TOOL_ROUTING_PATTERNS.anomaly.test(q) || TOOL_ROUTING_PATTERNS.prediction.test(q)) return 'analyst';
      if (TOOL_ROUTING_PATTERNS.serverGroup.test(q) || /cpu|ë©”ëª¨ë¦¬|ë””ìŠ¤í¬|ì„œë²„|ìƒíƒœ/.test(q)) return 'metrics';
      return 'general';
    }
    ```

- **[Low] â€œLRUâ€ í‘œê¸°ì™€ ì‹¤ì œ ë™ì‘ ë¶ˆì¼ì¹˜**
  - ìœ„ì¹˜: `cloud-run/ai-engine/src/tools-ai-sdk/reporter-tools.ts:421-463`
  - ë¬¸ì œ: `getCachedResult()`ì—ì„œ ì ‘ê·¼ ì‹œ ìˆœì„œ ê°±ì‹ ì´ ì—†ì–´ ì‹¤ì œë¡œëŠ” LRUê°€ ì•„ë‹ˆë¼ ì‚½ì…ìˆœ(FIFO) ê¸°ë°˜ ì‚­ì œì…ë‹ˆë‹¤. ì£¼ì„/ë¡œê·¸ê°€ ì˜¤í•´ë¥¼ ìœ ë°œ.
  - ê°œì„  ìŠ¤ë‹ˆí« (ì‹¤ì œ LRUë¡œ ë§ì¶”ë ¤ë©´):
    ```ts
    function getCachedResult(query: string): { results: WebSearchResult[]; answer: string | null } | null {
      const key = query.toLowerCase().trim();
      const cached = searchCache.get(key);
      const now = Date.now();
      if (!cached) return null;
      if (now - cached.timestamp > SEARCH_CACHE_CONFIG.ttlMs) {
        searchCache.delete(key);
        return null;
      }
      // LRU ê°±ì‹ 
      searchCache.delete(key);
      searchCache.set(key, { ...cached, timestamp: cached.timestamp });
      return { results: cached.results, answer: cached.answer };
    }
    ```
    (í˜¹ì€ ì£¼ì„/ë¡œê·¸ë¥¼ â€œFIFOâ€ë¡œ ìˆ˜ì •)

---

**í…ŒìŠ¤íŠ¸/ë¬¸ì„œ ê¶Œì¥**
- í…ŒìŠ¤íŠ¸: `DataCacheLayer.set()` overwrite ì‹œ evictionì´ ë°œìƒí•˜ì§€ ì•ŠëŠ” ì¼€ì´ìŠ¤, `createPrepareStep()` íŒ¨í„´ ë¶„ê¸°, Tavily ìºì‹œ eviction/TTL ë™ì‘ì— ëŒ€í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì¶”ê°€ ê¶Œì¥.
- ë¬¸ì„œ: ë³€ê²½ëœ ìºì‹œ ì •ì±…(í¬ê¸° 30, TTL 10ë¶„)ìœ¼ë¡œ ìš´ì˜ ì§€í‘œì— ì˜í–¥ì´ ìˆëŠ” ê²½ìš°, ìš´ì˜ ê°€ì´ë“œ/READMEì— ê°„ë‹¨íˆ ëª…ì‹œ ê¶Œì¥.

---

**ì¢…í•© í‰ê°€**
- ì ìˆ˜: **7.5 / 10**
- ìŠ¹ì¸ ì—¬ë¶€: **ì¡°ê±´ë¶€ ìŠ¹ì¸**
  - ì´ìœ : ìºì‹œ overwrite ì‹œ ë¶ˆí•„ìš”í•œ evictionì€ ì‹¤ì œ ë™ì‘/ì„±ëŠ¥ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆì–´ ë°°í¬ ì „ ìˆ˜ì • ê¶Œì¥.
  - ë‚˜ë¨¸ì§€ëŠ” ë¡œê¹… ì¼ê´€ì„± ë° ìºì‹œ ì •ì±… ì„¤ëª…/êµ¬í˜„ ì¼ì¹˜ ë¬¸ì œë¡œ, ìˆ˜ì • ë‚œì´ë„ëŠ” ë‚®ìŒ.

---

## ğŸ“‹ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ë²„ê·¸ ìœ„í—˜ ì‚¬í•­ í™•ì¸ ì™„ë£Œ
- [ ] ê°œì„  ì œì•ˆ ê²€í†  ì™„ë£Œ
- [ ] TypeScript ì•ˆì „ì„± í™•ì¸ ì™„ë£Œ
- [ ] ë³´ì•ˆ ì´ìŠˆ í™•ì¸ ì™„ë£Œ
- [ ] ì¢…í•© í‰ê°€ í™•ì¸ ì™„ë£Œ

## ğŸš¨ ì˜¤íƒ(False Positive) ê¸°ë¡

<!-- ê±°ë¶€/ì €ì ìˆ˜ê°€ ì˜¤íƒì¸ ê²½ìš° ì•„ë˜ì— ê¸°ë¡ -->
<!-- ì˜ˆì‹œ: - [x] limit ê²€ì¦ ì´ìŠˆ: Mock í•¸ë“¤ëŸ¬ë¼ ì‹¤ì œ ì˜í–¥ ì—†ìŒ -->


---

**ìƒì„± ì‹œê°„**: 2026-01-24 19:29:58
**ë¦¬ë·° íŒŒì¼**: `/mnt/d/cursor/openmanager-vibe-v5/reports/ai-review/pending/review-codex-2026-01-24-19-28-05.md`
**AI ì—”ì§„**: CODEX
