#!/usr/bin/env node

/**
 * üìä OpenManager V5 ÏûëÏóÖ Î°úÍ∑∏ Î∂ÑÏÑùÍ∏∞
 * 
 * Í∏∞Îä•:
 * - Git Ïª§Î∞ã ÌûàÏä§ÌÜ†Î¶¨ Î∂ÑÏÑù
 * - ÌååÏùº Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï∂îÏ†Å
 * - Í∞úÎ∞ú ÏßÑÌñâÎèÑ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
 * - Vibe Coding Í∞úÎ∞ú ÎÇ¥Ïó≠ ÌÜµÌï©
 * - Î¨∏ÏÑú ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏ Ï†úÏïà
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class WorkLogAnalyzer {
  constructor() {
    this.projectRoot = process.cwd();
    this.reportDir = path.join(this.projectRoot, 'logs', 'analysis');
    this.ensureDirectoryExists(this.reportDir);
  }

  // Git Ïª§Î∞ã ÌûàÏä§ÌÜ†Î¶¨ Î∂ÑÏÑù
  async analyzeGitHistory(days = 30) {
    try {
      const sinceDate = new Date();
      sinceDate.setDate(sinceDate.getDate() - days);
      const since = sinceDate.toISOString().split('T')[0];
      
      // Ïª§Î∞ã Î°úÍ∑∏ Í∞ÄÏ†∏Ïò§Í∏∞
      const gitLog = execSync(`git log --since="${since}" --pretty=format:"%h|%an|%ad|%s" --date=short`, {
        encoding: 'utf8'
      }).split('\n').filter(line => line.trim());
      
      // ÌååÏùº Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î∂ÑÏÑù
      const fileChanges = execSync(`git log --since="${since}" --name-status --pretty=format:"%h"`, {
        encoding: 'utf8'
      });
      
      const commits = gitLog.map(line => {
        const [hash, author, date, message] = line.split('|');
        return { hash, author, date, message };
      });
      
      // Î∂ÑÎ•òÎ≥Ñ Î∂ÑÏÑù
      const analysis = {
        totalCommits: commits.length,
        authors: this.analyzeAuthors(commits),
        categories: this.categorizeCommits(commits),
        fileChanges: this.analyzeFileChanges(fileChanges),
        vibecodingProgress: this.analyzeVibeCodingProgress(commits),
        timeline: this.createTimeline(commits)
      };
      
      return analysis;
    } catch (error) {
      console.error('Error analyzing git history:', error);
      return null;
    }
  }

  // ÏûëÏÑ±ÏûêÎ≥Ñ Î∂ÑÏÑù
  analyzeAuthors(commits) {
    const authorStats = {};
    
    commits.forEach(commit => {
      if (!authorStats[commit.author]) {
        authorStats[commit.author] = {
          commits: 0,
          firstCommit: commit.date,
          lastCommit: commit.date
        };
      }
      
      authorStats[commit.author].commits++;
      
      if (commit.date < authorStats[commit.author].firstCommit) {
        authorStats[commit.author].firstCommit = commit.date;
      }
      
      if (commit.date > authorStats[commit.author].lastCommit) {
        authorStats[commit.author].lastCommit = commit.date;
      }
    });
    
    return authorStats;
  }

  // Ïª§Î∞ã Î∂ÑÎ•ò
  categorizeCommits(commits) {
    const categories = {
      features: [],
      fixes: [],
      docs: [],
      refactor: [],
      tests: [],
      vibe_coding: [],
      mcp: [],
      ui_ux: [],
      performance: [],
      others: []
    };
    
    const keywords = {
      features: ['feat:', 'add:', 'implement', 'Ï∂îÍ∞Ä', 'Íµ¨ÌòÑ', 'Í∏∞Îä•'],
      fixes: ['fix:', 'bug:', 'patch:', 'ÏàòÏ†ï', 'Î≤ÑÍ∑∏', 'Ïò§Î•ò'],
      docs: ['docs:', 'doc:', 'Î¨∏ÏÑú', 'README', 'documentation'],
      refactor: ['refactor:', 'clean:', 'Î¶¨Ìå©ÌÑ∞', 'Ï†ïÎ¶¨', 'Í∞úÏÑ†'],
      tests: ['test:', 'spec:', 'ÌÖåÏä§Ìä∏', 'testing'],
      vibe_coding: ['vibe', 'cursor', 'ai collaboration', 'claude', 'copilot'],
      mcp: ['mcp', 'model context protocol', 'ai agent'],
      ui_ux: ['ui:', 'ux:', 'style:', 'ÎîîÏûêÏù∏', 'framer', 'animation'],
      performance: ['perf:', 'optimize:', 'ÏµúÏ†ÅÌôî', 'ÏÑ±Îä•', 'performance']
    };
    
    commits.forEach(commit => {
      const message = commit.message.toLowerCase();
      let categorized = false;
      
      for (const [category, keywordList] of Object.entries(keywords)) {
        if (keywordList.some(keyword => message.includes(keyword))) {
          categories[category].push(commit);
          categorized = true;
          break;
        }
      }
      
      if (!categorized) {
        categories.others.push(commit);
      }
    });
    
    return categories;
  }

  // ÌååÏùº Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î∂ÑÏÑù
  analyzeFileChanges(fileChangesRaw) {
    const lines = fileChangesRaw.split('\n');
    const fileStats = {};
    let currentHash = null;
    
    lines.forEach(line => {
      if (line.match(/^[a-f0-9]+$/)) {
        currentHash = line;
      } else if (line.startsWith('A\t') || line.startsWith('M\t') || line.startsWith('D\t')) {
        const [status, file] = line.split('\t');
        
        if (!fileStats[file]) {
          fileStats[file] = {
            added: 0,
            modified: 0,
            deleted: 0,
            lastModified: currentHash
          };
        }
        
        if (status === 'A') fileStats[file].added++;
        else if (status === 'M') fileStats[file].modified++;
        else if (status === 'D') fileStats[file].deleted++;
      }
    });
    
    // Í∞ÄÏû• ÌôúÎ∞úÌûà Î≥ÄÍ≤ΩÎêú ÌååÏùºÎì§
    const mostChanged = Object.entries(fileStats)
      .map(([file, stats]) => ({
        file,
        totalChanges: stats.added + stats.modified + stats.deleted,
        ...stats
      }))
      .sort((a, b) => b.totalChanges - a.totalChanges)
      .slice(0, 20);
    
    return {
      totalFiles: Object.keys(fileStats).length,
      mostChanged,
      fileTypes: this.analyzeFileTypes(Object.keys(fileStats))
    };
  }

  // ÌååÏùº ÌÉÄÏûÖÎ≥Ñ Î∂ÑÏÑù
  analyzeFileTypes(files) {
    const typeStats = {};
    
    files.forEach(file => {
      const ext = path.extname(file).toLowerCase() || 'no-extension';
      typeStats[ext] = (typeStats[ext] || 0) + 1;
    });
    
    return Object.entries(typeStats)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);
  }

  // Vibe Coding ÏßÑÌñâÎèÑ Î∂ÑÏÑù
  analyzeVibeCodingProgress(commits) {
    const vibeCodingCommits = commits.filter(commit => 
      commit.message.toLowerCase().includes('vibe') ||
      commit.message.toLowerCase().includes('cursor') ||
      commit.message.toLowerCase().includes('ai') ||
      commit.message.toLowerCase().includes('claude')
    );
    
    const milestones = [
      {
        title: 'AI ÌòëÏóÖ ÎèÑÍµ¨ ÏÑ§Ï†ï',
        keywords: ['cursor', 'claude', 'setup', 'ÏÑ§Ï†ï'],
        completed: false,
        commits: []
      },
      {
        title: 'MCP ÏãúÏä§ÌÖú Íµ¨ÌòÑ',
        keywords: ['mcp', 'model context', 'ai agent', 'orchestrator'],
        completed: false,
        commits: []
      },
      {
        title: 'Vibe Coding ÌéòÏù¥ÏßÄ Í∞úÎ∞ú',
        keywords: ['vibe coding', 'collaboration page', 'ai workflow'],
        completed: false,
        commits: []
      },
      {
        title: 'Í∞úÎ∞ú ÏûêÎèôÌôî Íµ¨Ï∂ï',
        keywords: ['automation', 'script', 'generator', 'ÏûêÎèôÌôî'],
        completed: false,
        commits: []
      }
    ];
    
    // ÎßàÏùºÏä§ÌÜ§Î≥Ñ ÏßÑÌñâÎèÑ Ï≤¥ÌÅ¨
    vibeCodingCommits.forEach(commit => {
      milestones.forEach(milestone => {
        if (milestone.keywords.some(keyword => 
          commit.message.toLowerCase().includes(keyword)
        )) {
          milestone.commits.push(commit);
          milestone.completed = true;
        }
      });
    });
    
    return {
      totalVibeCodingCommits: vibeCodingCommits.length,
      milestones,
      completionRate: (milestones.filter(m => m.completed).length / milestones.length) * 100
    };
  }

  // ÌÉÄÏûÑÎùºÏù∏ ÏÉùÏÑ±
  createTimeline(commits) {
    const timeline = {};
    
    commits.forEach(commit => {
      if (!timeline[commit.date]) {
        timeline[commit.date] = [];
      }
      timeline[commit.date].push(commit);
    });
    
    return Object.entries(timeline)
      .sort((a, b) => new Date(b[0]) - new Date(a[0]))
      .slice(0, 14); // ÏµúÍ∑º 2Ï£º
  }

  // ÌîÑÎ°úÏ†ùÌä∏ ÌòÑÌô© Î∂ÑÏÑù
  analyzeProjectStatus() {
    try {
      // ÌååÏùº Ïàò Í≥ÑÏÇ∞
      const srcFiles = this.countFiles('src', /\.(ts|tsx|js|jsx)$/);
      const testFiles = this.countFiles('tests', /\.(test|spec)\.(ts|tsx|js|jsx)$/);
      const docFiles = this.countFiles('docs', /\.md$/);
      
      // ÏΩîÎìú ÎùºÏù∏ Ïàò Í≥ÑÏÇ∞ (Í∑ºÏÇ¨Ïπò)
      const codeLines = this.estimateCodeLines();
      
      // Ìå®ÌÇ§ÏßÄ ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      
      return {
        files: {
          source: srcFiles,
          tests: testFiles,
          docs: docFiles
        },
        codeLines,
        dependencies: {
          production: Object.keys(packageJson.dependencies || {}).length,
          development: Object.keys(packageJson.devDependencies || {}).length
        },
        scripts: Object.keys(packageJson.scripts || {}).length
      };
    } catch (error) {
      console.error('Error analyzing project status:', error);
      return null;
    }
  }

  // ÌååÏùº Ïàò Í≥ÑÏÇ∞
  countFiles(directory, pattern) {
    try {
      if (!fs.existsSync(directory)) return 0;
      
      let count = 0;
      
      const walkDir = (dir) => {
        const items = fs.readdirSync(dir);
        
        items.forEach(item => {
          const fullPath = path.join(dir, item);
          const stat = fs.statSync(fullPath);
          
          if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
            walkDir(fullPath);
          } else if (stat.isFile() && pattern.test(item)) {
            count++;
          }
        });
      };
      
      walkDir(directory);
      return count;
    } catch (error) {
      return 0;
    }
  }

  // ÏΩîÎìú ÎùºÏù∏ Ïàò Ï∂îÏ†ï
  estimateCodeLines() {
    try {
      const result = execSync('find src -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" | xargs wc -l | tail -1', {
        encoding: 'utf8'
      });
      
      const match = result.match(/(\d+)/);
      return match ? parseInt(match[1]) : 0;
    } catch (error) {
      return 0;
    }
  }

  // Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏ Ï†úÏïà ÏÉùÏÑ±
  generateDocumentationSuggestions(analysis) {
    const suggestions = [];
    
    // Vibe Coding ÏßÑÌñâÎèÑ Í∏∞Î∞ò Ï†úÏïà
    if (analysis.vibecodingProgress.completionRate > 80) {
      suggestions.push({
        type: 'vibe_coding',
        priority: 'high',
        title: 'Vibe Coding ÏôÑÏÑ± Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏',
        description: 'Vibe Coding ÎßàÏùºÏä§ÌÜ§ Îã¨ÏÑ±Î•†Ïù¥ 80% Ïù¥ÏÉÅÏûÖÎãàÎã§. Í¥ÄÎ†® Î¨∏ÏÑúÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï¥Ï£ºÏÑ∏Ïöî.',
        targetFile: 'docs/4_AI_AGENT_GUIDE.md'
      });
    }
    
    // ÏÉàÎ°úÏö¥ Í∏∞Îä• Í∏∞Î∞ò Ï†úÏïà
    if (analysis.categories.features.length > 5) {
      suggestions.push({
        type: 'features',
        priority: 'medium',
        title: 'ÏÉà Í∏∞Îä• Î¨∏ÏÑúÌôî',
        description: `ÏµúÍ∑º ${analysis.categories.features.length}Í∞úÏùò ÏÉà Í∏∞Îä•Ïù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.`,
        targetFile: 'docs/1_SYSTEM_OVERVIEW.md'
      });
    }
    
    // API Î≥ÄÍ≤Ω Í∏∞Î∞ò Ï†úÏïà
    const apiChanges = analysis.fileChanges.mostChanged.filter(f => 
      f.file.includes('/api/') || f.file.includes('route.ts')
    );
    
    if (apiChanges.length > 0) {
      suggestions.push({
        type: 'api',
        priority: 'high',
        title: 'API Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏',
        description: `${apiChanges.length}Í∞úÏùò API ÌååÏùºÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.`,
        targetFile: 'docs/8_API_REFERENCE.md'
      });
    }
    
    return suggestions;
  }

  // Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
  async generateReport(days = 30) {
    console.log(`üìä ÏµúÍ∑º ${days}ÏùºÍ∞Ñ ÏûëÏóÖ Î°úÍ∑∏ Î∂ÑÏÑù Ï§ë...`);
    
    const analysis = await this.analyzeGitHistory(days);
    const projectStatus = this.analyzeProjectStatus();
    const suggestions = this.generateDocumentationSuggestions(analysis);
    
    const report = {
      generatedAt: new Date().toISOString(),
      period: `ÏµúÍ∑º ${days}Ïùº`,
      analysis,
      projectStatus,
      suggestions,
      summary: this.generateSummary(analysis, projectStatus)
    };
    
    // Î¶¨Ìè¨Ìä∏ ÌååÏùº Ï†ÄÏû•
    const reportPath = path.join(this.reportDir, `work-log-report-${Date.now()}.json`);
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    // ÎßàÌÅ¨Îã§Ïö¥ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
    const markdownReport = this.generateMarkdownReport(report);
    const mdReportPath = path.join(this.reportDir, `work-log-report-${Date.now()}.md`);
    fs.writeFileSync(mdReportPath, markdownReport);
    
    console.log(`‚úÖ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å:`);
    console.log(`   JSON: ${reportPath}`);
    console.log(`   Markdown: ${mdReportPath}`);
    
    return report;
  }

  // ÏöîÏïΩ ÏÉùÏÑ±
  generateSummary(analysis, projectStatus) {
    const activeAuthors = Object.keys(analysis.authors).length;
    const totalCommits = analysis.totalCommits;
    const vibeCodingProgress = analysis.vibecodingProgress.completionRate;
    
    return {
      productivity: totalCommits > 50 ? 'High' : totalCommits > 20 ? 'Medium' : 'Low',
      teamActivity: activeAuthors > 3 ? 'Very Active' : activeAuthors > 1 ? 'Active' : 'Solo',
      vibeCodingStatus: vibeCodingProgress > 75 ? 'Advanced' : vibeCodingProgress > 50 ? 'In Progress' : 'Starting',
      codebase: projectStatus.codeLines > 10000 ? 'Large' : projectStatus.codeLines > 5000 ? 'Medium' : 'Small'
    };
  }

  // ÎßàÌÅ¨Îã§Ïö¥ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
  generateMarkdownReport(report) {
    const { analysis, projectStatus, suggestions, summary } = report;
    
    return `# üìä OpenManager V5 - ÏûëÏóÖ Î°úÍ∑∏ Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏

**ÏÉùÏÑ±Ïùº**: ${new Date(report.generatedAt).toLocaleString()}  
**Î∂ÑÏÑù Í∏∞Í∞Ñ**: ${report.period}

---

## üéØ ÏöîÏïΩ

- **ÏÉùÏÇ∞ÏÑ±**: ${summary.productivity}
- **ÌåÄ ÌôúÎèô**: ${summary.teamActivity}  
- **Vibe Coding ÏßÑÌñâÎèÑ**: ${summary.vibeCodingStatus} (${Math.round(analysis.vibecodingProgress.completionRate)}%)
- **ÏΩîÎìúÎ≤†Ïù¥Ïä§ Í∑úÎ™®**: ${summary.codebase} (${projectStatus.codeLines.toLocaleString()} ÎùºÏù∏)

---

## üìà Í∞úÎ∞ú ÌôúÎèô ÌÜµÍ≥Ñ

### Ïª§Î∞ã ÌòÑÌô©
- **Ï¥ù Ïª§Î∞ã Ïàò**: ${analysis.totalCommits}Í∞ú
- **ÌôúÏÑ± Í∞úÎ∞úÏûê**: ${Object.keys(analysis.authors).length}Î™Ö
- **Î≥ÄÍ≤ΩÎêú ÌååÏùº**: ${analysis.fileChanges.totalFiles}Í∞ú

### Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î∂ÑÏÑù
${Object.entries(analysis.categories)
  .filter(([_, commits]) => commits.length > 0)
  .map(([category, commits]) => `- **${category}**: ${commits.length}Í∞ú`)
  .join('\n')}

---

## üé® Vibe Coding ÏßÑÌñâÎèÑ

**Ï†ÑÏ≤¥ ÏôÑÎ£åÏú®**: ${Math.round(analysis.vibecodingProgress.completionRate)}%

### ÎßàÏùºÏä§ÌÜ§ ÌòÑÌô©
${analysis.vibecodingProgress.milestones
  .map(milestone => `- ${milestone.completed ? '‚úÖ' : '‚è≥'} **${milestone.title}** (${milestone.commits.length}Í∞ú Ïª§Î∞ã)`)
  .join('\n')}

---

## üìÅ ÌîÑÎ°úÏ†ùÌä∏ ÌòÑÌô©

### ÌååÏùº Íµ¨ÏÑ±
- **ÏÜåÏä§ ÌååÏùº**: ${projectStatus.files.source}Í∞ú
- **ÌÖåÏä§Ìä∏ ÌååÏùº**: ${projectStatus.files.tests}Í∞ú  
- **Î¨∏ÏÑú ÌååÏùº**: ${projectStatus.files.docs}Í∞ú

### ÏùòÏ°¥ÏÑ±
- **ÌîÑÎ°úÎçïÏÖò**: ${projectStatus.dependencies.production}Í∞ú
- **Í∞úÎ∞ú**: ${projectStatus.dependencies.development}Í∞ú
- **Ïä§ÌÅ¨Î¶ΩÌä∏**: ${projectStatus.scripts}Í∞ú

---

## üîß Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏ Ï†úÏïà

${suggestions.length > 0 ? 
  suggestions.map(s => `### ${s.priority === 'high' ? 'üî¥' : 'üü°'} ${s.title}

**ÎåÄÏÉÅ ÌååÏùº**: \`${s.targetFile}\`  
**ÏÑ§Î™Ö**: ${s.description}
`).join('\n') : 
  'ÌòÑÏû¨ Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÌïÑÏöîÌïú Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§.'
}

---

## üìÖ ÏµúÍ∑º ÌôúÎèô ÌÉÄÏûÑÎùºÏù∏

${analysis.timeline.slice(0, 7)
  .map(([date, commits]) => `### ${date} (${commits.length}Í∞ú Ïª§Î∞ã)

${commits.slice(0, 3).map(c => `- \`${c.hash}\` ${c.message}`).join('\n')}
${commits.length > 3 ? `\n... Ïô∏ ${commits.length - 3}Í∞ú` : ''}
`).join('\n')}

---

**ÏûêÎèô ÏÉùÏÑ±**: ${new Date().toLocaleString()}  
**Î∂ÑÏÑù ÎèÑÍµ¨**: OpenManager V5 Work Log Analyzer`;
  }

  // ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
  ensureDirectoryExists(dirPath) {
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }

  // CLI Ïã§Ìñâ
  run() {
    const args = process.argv.slice(2);
    const days = parseInt(args.find(arg => arg.startsWith('--days='))?.split('=')[1]) || 30;
    
    if (args.includes('--help')) {
      console.log(`
üìä Work Log Analyzer

ÏÇ¨Ïö©Î≤ï:
  node .cursor/scripts/work-log-analyzer.js [options]

ÏòµÏÖò:
  --days=<Ïà´Ïûê>     Î∂ÑÏÑùÌï† ÏùºÏàò (Í∏∞Î≥∏: 30Ïùº)
  --help           Ïù¥ ÎèÑÏõÄÎßê ÌëúÏãú

ÏòàÏ†ú:
  node .cursor/scripts/work-log-analyzer.js --days=14
  node .cursor/scripts/work-log-analyzer.js
      `);
      return;
    }
    
    this.generateReport(days);
  }
}

// CLI Ïã§Ìñâ
if (require.main === module) {
  const analyzer = new WorkLogAnalyzer();
  analyzer.run();
}

module.exports = WorkLogAnalyzer; 