/**
 * üß™ GoogleLoginButton TDD Tests
 * 
 * Google OAuth Î°úÍ∑∏Ïù∏ Î≤ÑÌäº Ïª¥Ìè¨ÎÑåÌä∏ ÌÖåÏä§Ìä∏
 */

import { GoogleLoginButton } from '@/components/auth/GoogleLoginButton';
import { useAuth } from '@/hooks/useAuth';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';
import { useRouter } from 'next/navigation';

// Mock Next.js router
jest.mock('next/navigation', () => ({
    useRouter: jest.fn()
}));

// Mock useAuth hook
jest.mock('@/hooks/useAuth', () => ({
    useAuth: jest.fn()
}));

// Mock Google OAuth API
const mockGoogleAuth = {
    signIn: jest.fn(),
    isSignedIn: jest.fn()
};

// Mock Google API Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú
Object.defineProperty(window, 'gapi', {
    value: {
        load: jest.fn((api, callback) => callback()),
        auth2: {
            init: jest.fn(() => mockGoogleAuth),
            getAuthInstance: jest.fn(() => mockGoogleAuth)
        }
    },
    writable: true
});

describe('GoogleLoginButton', () => {
    const mockPush = jest.fn();
    const mockLogin = {
        withGoogle: jest.fn()
    };

    beforeEach(() => {
        (useRouter as jest.Mock).mockReturnValue({
            push: mockPush
        });

        (useAuth as jest.Mock).mockReturnValue({
            login: mockLogin,
            isAuthenticated: false,
            user: null
        });

        jest.clearAllMocks();
    });

    describe('Rendering', () => {
        it('should render login button when not authenticated', () => {
            render(<GoogleLoginButton />);

            expect(screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏')).toBeInTheDocument();
            expect(screen.getByRole('button')).toBeInTheDocument();
        });

        it('should display Google icon in button', () => {
            render(<GoogleLoginButton />);

            const button = screen.getByRole('button');
            expect(button).toHaveClass('flex', 'items-center', 'gap-2');

            // Google ÏïÑÏù¥ÏΩò SVG ÌôïÏù∏
            const googleIcon = button.querySelector('svg');
            expect(googleIcon).toBeInTheDocument();
        });

        it('should have proper accessibility attributes', () => {
            render(<GoogleLoginButton />);

            const button = screen.getByRole('button');
            expect(button).toHaveAttribute('aria-label', 'GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            expect(button).toHaveAttribute('type', 'button');
        });

        it('should not render when already authenticated', () => {
            (useAuth as jest.Mock).mockReturnValue({
                login: mockLogin,
                isAuthenticated: true,
                user: { name: 'Test User' }
            });

            render(<GoogleLoginButton />);

            expect(screen.queryByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏')).not.toBeInTheDocument();
        });
    });

    describe('Google OAuth Flow', () => {
        it('should initiate Google OAuth when clicked', async () => {
            mockLogin.withGoogle.mockResolvedValue({
                success: true,
                user: { name: 'Test User', email: 'test@example.com' }
            });

            render(<GoogleLoginButton />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            expect(mockLogin.withGoogle).toHaveBeenCalled();
        });

        it('should redirect to dashboard after successful login', async () => {
            mockLogin.withGoogle.mockResolvedValue({
                success: true,
                user: { name: 'Test User', email: 'test@example.com' }
            });

            render(<GoogleLoginButton />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            await waitFor(() => {
                expect(mockPush).toHaveBeenCalledWith('/dashboard');
            });
        });

        it('should show loading state during authentication', async () => {
            let resolveLogin: (value: any) => void;
            const loginPromise = new Promise(resolve => {
                resolveLogin = resolve;
            });

            mockLogin.withGoogle.mockReturnValue(loginPromise);

            render(<GoogleLoginButton />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            // Î°úÎî© ÏÉÅÌÉú ÌôïÏù∏
            expect(screen.getByText('Î°úÍ∑∏Ïù∏ Ï§ë...')).toBeInTheDocument();
            expect(screen.getByRole('button')).toBeDisabled();

            // Î°úÍ∑∏Ïù∏ ÏôÑÎ£å
            resolveLogin!({ success: true, user: { name: 'Test User' } });

            await waitFor(() => {
                expect(screen.queryByText('Î°úÍ∑∏Ïù∏ Ï§ë...')).not.toBeInTheDocument();
            });
        });

        it('should handle login failure gracefully', async () => {
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

            mockLogin.withGoogle.mockRejectedValue(new Error('Login failed'));

            render(<GoogleLoginButton />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            await waitFor(() => {
                expect(consoleSpy).toHaveBeenCalledWith('Î°úÍ∑∏Ïù∏ Ïã§Ìå®:', expect.any(Error));
            });

            // ÏóêÎü¨ Î©îÏãúÏßÄ ÌëúÏãú ÌôïÏù∏
            expect(screen.getByText('Î°úÍ∑∏Ïù∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.')).toBeInTheDocument();

            consoleSpy.mockRestore();
        });

        it('should handle network errors', async () => {
            mockLogin.withGoogle.mockRejectedValue(new Error('Network error'));

            render(<GoogleLoginButton />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            await waitFor(() => {
                expect(screen.getByText('ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.')).toBeInTheDocument();
            });
        });
    });

    describe('Custom Props', () => {
        it('should call custom onLoginSuccess callback', async () => {
            const mockOnLoginSuccess = jest.fn();

            mockLogin.withGoogle.mockResolvedValue({
                success: true,
                user: { name: 'Test User' }
            });

            render(<GoogleLoginButton onLoginSuccess={mockOnLoginSuccess} />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            await waitFor(() => {
                expect(mockOnLoginSuccess).toHaveBeenCalledWith({
                    success: true,
                    user: { name: 'Test User' }
                });
            });
        });

        it('should apply custom className', () => {
            render(<GoogleLoginButton className="custom-class" />);

            const button = screen.getByRole('button');
            expect(button).toHaveClass('custom-class');
        });

        it('should support custom button text', () => {
            render(<GoogleLoginButton buttonText="Íµ¨Í∏Ä Í≥ÑÏ†ïÏúºÎ°ú ÏãúÏûëÌïòÍ∏∞" />);

            expect(screen.getByText('Íµ¨Í∏Ä Í≥ÑÏ†ïÏúºÎ°ú ÏãúÏûëÌïòÍ∏∞')).toBeInTheDocument();
        });

        it('should support disabled state', () => {
            render(<GoogleLoginButton disabled={true} />);

            const button = screen.getByRole('button');
            expect(button).toBeDisabled();
            expect(button).toHaveClass('opacity-50', 'cursor-not-allowed');
        });
    });

    describe('Integration with System', () => {
        it('should trigger system start after successful authentication', async () => {
            mockLogin.withGoogle.mockResolvedValue({
                success: true,
                user: { name: 'Test User' },
                systemStarted: true
            });

            render(<GoogleLoginButton />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            await waitFor(() => {
                expect(screen.getByText('ÏãúÏä§ÌÖúÏù¥ ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.')).toBeInTheDocument();
            });
        });

        it('should handle system start failure', async () => {
            mockLogin.withGoogle.mockResolvedValue({
                success: true,
                user: { name: 'Test User' },
                systemStarted: false,
                systemError: 'System initialization failed'
            });

            render(<GoogleLoginButton />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            await waitFor(() => {
                expect(screen.getByText('Î°úÍ∑∏Ïù∏ÏùÄ ÏÑ±Í≥µÌñàÏßÄÎßå ÏãúÏä§ÌÖú ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')).toBeInTheDocument();
            });
        });
    });

    describe('Accessibility', () => {
        it('should support keyboard navigation', () => {
            render(<GoogleLoginButton />);

            const button = screen.getByRole('button');
            button.focus();

            expect(button).toHaveFocus();

            fireEvent.keyDown(button, { key: 'Enter' });
            expect(mockLogin.withGoogle).toHaveBeenCalled();
        });

        it('should have proper ARIA labels', () => {
            render(<GoogleLoginButton />);

            const button = screen.getByRole('button');
            expect(button).toHaveAttribute('aria-label', 'GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            expect(button).toHaveAttribute('aria-describedby');
        });

        it('should announce loading state to screen readers', async () => {
            let resolveLogin: (value: any) => void;
            const loginPromise = new Promise(resolve => {
                resolveLogin = resolve;
            });

            mockLogin.withGoogle.mockReturnValue(loginPromise);

            render(<GoogleLoginButton />);

            const button = screen.getByText('GoogleÎ°ú Î°úÍ∑∏Ïù∏');
            fireEvent.click(button);

            expect(button).toHaveAttribute('aria-busy', 'true');
            expect(button).toHaveAttribute('aria-live', 'polite');

            resolveLogin!({ success: true, user: { name: 'Test User' } });

            await waitFor(() => {
                expect(button).toHaveAttribute('aria-busy', 'false');
            });
        });
    });
}); 