#!/usr/bin/env node

/**
 * @fileoverview AI ÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî Ïä§ÌÅ¨Î¶ΩÌä∏
 * @description Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏ÏôÄ Ïô∏Î∂Ä AI CLI ÎèÑÍµ¨Îì§ Í∞ÑÏùò ÏÑ§Ï†ï ÎèôÍ∏∞Ìôî Î∞è ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ
 * @author Claude Code + Multi-AI ÌòëÏóÖ ÏãúÏä§ÌÖú
 * @created 2025-08-18
 * @version 1.0.0
 */

import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';

/**
 * AI ÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî ÏãúÏä§ÌÖú
 * - Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏ ÏÑ§Ï†ï ÎèôÍ∏∞Ìôî
 * - Ïô∏Î∂Ä AI CLI ÎèÑÍµ¨ ÏÑ§Ï†ï Í≤ÄÏ¶ù
 * - MCP ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
 * - ÏÑ§Ï†ï ÏùºÍ¥ÄÏÑ± Î≥¥Ïû•
 */
class AIAgentSyncManager {
  constructor() {
    this.projectRoot = '/mnt/d/cursor/openmanager-vibe-v5';
    this.configPaths = {
      mcpMapping: '.claude/agents/mcp-mapping.json',
      claudeSettings: '.claude/settings.json',
      mcpConfig: '.mcp.json',
      agentsConfig: 'AGENTS.md',
      geminiConfig: 'GEMINI.md',
      qwenConfig: 'QWEN.md',
      claudeGuide: 'CLAUDE.md'
    };
    
    this.syncResults = {
      claude: { status: 'unknown', agents: [], errors: [] },
      codex: { status: 'unknown', config: null, errors: [] },
      gemini: { status: 'unknown', config: null, errors: [] },
      qwen: { status: 'unknown', config: null, errors: [] },
      mcp: { status: 'unknown', servers: [], errors: [] }
    };
    
    this.startTime = Date.now();
  }

  // === Î©îÏù∏ ÎèôÍ∏∞Ìôî ÌîÑÎ°úÏÑ∏Ïä§ ===
  async synchronize(options = {}) {
    const { verbose = false, dryRun = false, forceFix = false } = options;
    
    this.log('info', 'üîÑ AI ÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî ÏãúÏûë...');
    this.log('debug', `üìÇ ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏: ${this.projectRoot}`);
    
    try {
      // 1. ÏãúÏä§ÌÖú ÏÉÅÌÉú Í≤ÄÏ¶ù
      await this.validateSystemStatus();
      
      // 2. Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî
      await this.syncClaudeAgents();
      
      // 3. Ïô∏Î∂Ä AI CLI ÎèÑÍµ¨ ÎèôÍ∏∞Ìôî
      await this.syncExternalAITools();
      
      // 4. MCP ÏÑúÎ≤Ñ ÎèôÍ∏∞Ìôî
      await this.syncMCPServers();
      
      // 5. ÏÑ§Ï†ï ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
      await this.validateConsistency();
      
      // 6. ÎèôÍ∏∞Ìôî Í≤∞Í≥º Î≥¥Í≥†
      const report = this.generateSyncReport();
      
      if (!dryRun && forceFix) {
        await this.applyFixes();
      }
      
      this.log('success', '‚úÖ AI ÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî ÏôÑÎ£å');
      return report;
      
    } catch (error) {
      this.log('error', `‚ùå ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${error.message}`);
      throw error;
    }
  }

  // === ÏãúÏä§ÌÖú ÏÉÅÌÉú Í≤ÄÏ¶ù ===
  async validateSystemStatus() {
    this.log('debug', 'üîç ÏãúÏä§ÌÖú ÏÉÅÌÉú Í≤ÄÏ¶ù Ï§ë...');
    
    // WSL ÌôòÍ≤Ω ÌôïÏù∏
    const isWSL = await this.checkWSLEnvironment();
    if (!isWSL) {
      throw new Error('WSL ÌôòÍ≤ΩÏóêÏÑúÎßå Ïã§Ìñâ Í∞ÄÎä•Ìï©ÎãàÎã§');
    }
    
    // ÌïÑÏàò ÌååÏùº Ï°¥Ïû¨ ÌôïÏù∏
    const missingFiles = [];
    for (const [name, filePath] of Object.entries(this.configPaths)) {
      const fullPath = path.join(this.projectRoot, filePath);
      try {
        await fs.access(fullPath);
      } catch {
        missingFiles.push(filePath);
      }
    }
    
    if (missingFiles.length > 0) {
      this.log('warn', `‚ö†Ô∏è  ÎàÑÎùΩÎêú ÏÑ§Ï†ï ÌååÏùº: ${missingFiles.join(', ')}`);
    }
    
    // AI CLI ÎèÑÍµ¨ ÏÑ§Ïπò ÏÉÅÌÉú ÌôïÏù∏
    await this.checkAIToolsInstallation();
  }

  // === Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî ===
  async syncClaudeAgents() {
    this.log('debug', 'ü§ñ Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî Ï§ë...');
    
    try {
      // MCP Îß§Ìïë ÏÑ§Ï†ï Î°úÎìú
      const mcpMappingPath = path.join(this.projectRoot, this.configPaths.mcpMapping);
      const mcpMapping = JSON.parse(await fs.readFile(mcpMappingPath, 'utf8'));
      
      // Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏ Î™©Î°ù Ï∂îÏ∂ú
      const claudeAgents = Object.keys(mcpMapping.agent_mcp_mappings);
      this.syncResults.claude.agents = claudeAgents;
      
      // Task ÎèÑÍµ¨ ÏßÄÏõê ÏóêÏù¥Ï†ÑÌä∏ ÌôïÏù∏
      const taskEnabledAgents = claudeAgents.filter(agent => 
        mcpMapping.agent_mcp_mappings[agent].task_enabled === true
      );
      
      this.log('info', `üìã Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏: ${claudeAgents.length}Í∞ú (Task ÏßÄÏõê: ${taskEnabledAgents.length}Í∞ú)`);
      this.syncResults.claude.status = 'synced';
      
    } catch (error) {
      this.syncResults.claude.status = 'error';
      this.syncResults.claude.errors.push(error.message);
      this.log('error', `‚ùå Claude ÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${error.message}`);
    }
  }

  // === Ïô∏Î∂Ä AI CLI ÎèÑÍµ¨ ÎèôÍ∏∞Ìôî ===
  async syncExternalAITools() {
    this.log('debug', 'üîß Ïô∏Î∂Ä AI CLI ÎèÑÍµ¨ ÎèôÍ∏∞Ìôî Ï§ë...');
    
    // Codex CLI ÎèôÍ∏∞Ìôî
    await this.syncCodexCLI();
    
    // Gemini CLI ÎèôÍ∏∞Ìôî
    await this.syncGeminiCLI();
    
    // Qwen CLI ÎèôÍ∏∞Ìôî
    await this.syncQwenCLI();
  }

  async syncCodexCLI() {
    try {
      const agentsConfigPath = path.join(this.projectRoot, this.configPaths.agentsConfig);
      const agentsContent = await fs.readFile(agentsConfigPath, 'utf8');
      
      // AGENTS.mdÏóêÏÑú 12Í∞ú Ï†ÑÎ¨∏ Î∂ÑÏïº ÏÑ§Ï†ï ÌôïÏù∏
      const domainMatches = agentsContent.match(/## \d+\. .+/g) || [];
      const domains = domainMatches.length;
      
      this.syncResults.codex = {
        status: 'synced',
        config: {
          tool_type: 'single_ai_tool',
          specialized_domains: domains,
          base_model: 'ChatGPT Plus',
          monthly_cost: '$20'
        },
        errors: []
      };
      
      this.log('info', `üéØ Codex CLI: 1Í∞ú ÎèÑÍµ¨ (${domains}Í∞ú Ï†ÑÎ¨∏ Î∂ÑÏïº)`);
      
    } catch (error) {
      this.syncResults.codex.status = 'error';
      this.syncResults.codex.errors.push(error.message);
      this.log('error', `‚ùå Codex CLI ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${error.message}`);
    }
  }

  async syncGeminiCLI() {
    try {
      const geminiConfigPath = path.join(this.projectRoot, this.configPaths.geminiConfig);
      const geminiContent = await fs.readFile(geminiConfigPath, 'utf8');
      
      // Gemini CLI Î≤ÑÏ†Ñ ÌôïÏù∏
      let version = 'unknown';
      try {
        version = execSync('gemini --version', { encoding: 'utf8' }).trim();
      } catch {
        // Î≤ÑÏ†Ñ ÌôïÏù∏ Ïã§Ìå®Îäî Ï†ïÏÉÅ (ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏùÑ Ïàò ÏûàÏùå)
      }
      
      this.syncResults.gemini = {
        status: 'synced',
        config: {
          tool_type: 'single_ai_tool',
          role: 'Senior Code Architect',
          version: version,
          cost: 'Free (1K req/day)'
        },
        errors: []
      };
      
      this.log('info', `üß† Gemini CLI: 1Í∞ú ÎèÑÍµ¨ (Senior Code Architect Ïó≠Ìï†)`);
      
    } catch (error) {
      this.syncResults.gemini.status = 'error';
      this.syncResults.gemini.errors.push(error.message);
      this.log('error', `‚ùå Gemini CLI ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${error.message}`);
    }
  }

  async syncQwenCLI() {
    try {
      const qwenConfigPath = path.join(this.projectRoot, this.configPaths.qwenConfig);
      const qwenContent = await fs.readFile(qwenConfigPath, 'utf8');
      
      // Qwen CLI Î≤ÑÏ†Ñ ÌôïÏù∏
      let version = 'unknown';
      try {
        version = execSync('qwen --version', { encoding: 'utf8' }).trim();
      } catch {
        // Î≤ÑÏ†Ñ ÌôïÏù∏ Ïã§Ìå®Îäî Ï†ïÏÉÅ
      }
      
      this.syncResults.qwen = {
        status: 'synced',
        config: {
          tool_type: 'single_ai_tool',
          role: 'Î≥ëÎ†¨ Î™®Îìà Í∞úÎ∞ú Ï†ÑÎ¨∏',
          version: version,
          cost: 'Free (2K req/day)'
        },
        errors: []
      };
      
      this.log('info', `‚ö° Qwen CLI: 1Í∞ú ÎèÑÍµ¨ (Î≥ëÎ†¨ Í∞úÎ∞ú Ï†ÑÎ¨∏)`);
      
    } catch (error) {
      this.syncResults.qwen.status = 'error';
      this.syncResults.qwen.errors.push(error.message);
      this.log('error', `‚ùå Qwen CLI ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${error.message}`);
    }
  }

  // === MCP ÏÑúÎ≤Ñ ÎèôÍ∏∞Ìôî ===
  async syncMCPServers() {
    this.log('debug', 'üîå MCP ÏÑúÎ≤Ñ ÎèôÍ∏∞Ìôî Ï§ë...');
    
    try {
      const mcpConfigPath = path.join(this.projectRoot, this.configPaths.mcpConfig);
      const mcpConfig = JSON.parse(await fs.readFile(mcpConfigPath, 'utf8'));
      
      const servers = Object.keys(mcpConfig.mcpServers || {});
      this.syncResults.mcp.servers = servers;
      this.syncResults.mcp.status = 'synced';
      
      this.log('info', `üîå MCP ÏÑúÎ≤Ñ: ${servers.length}Í∞ú (${servers.join(', ')})`);
      
      // MCP ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ (ÏòµÏÖò)
      await this.checkMCPServerStatus();
      
    } catch (error) {
      this.syncResults.mcp.status = 'error';
      this.syncResults.mcp.errors.push(error.message);
      this.log('error', `‚ùå MCP ÏÑúÎ≤Ñ ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${error.message}`);
    }
  }

  // === ÏÑ§Ï†ï ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù ===
  async validateConsistency() {
    this.log('debug', '‚úÖ ÏÑ§Ï†ï ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù Ï§ë...');
    
    const inconsistencies = [];
    
    // Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏ Ïàò ÏùºÍ¥ÄÏÑ± ÌôïÏù∏
    const expectedClaudeAgents = 19;
    if (this.syncResults.claude.agents.length !== expectedClaudeAgents) {
      inconsistencies.push(`Claude ÏÑúÎ∏åÏóêÏù¥Ï†ÑÌä∏ Ïàò Î∂àÏùºÏπò: ÏòàÏÉÅ ${expectedClaudeAgents}Í∞ú, Ïã§Ï†ú ${this.syncResults.claude.agents.length}Í∞ú`);
    }
    
    // MCP ÏÑúÎ≤Ñ Ïàò ÏùºÍ¥ÄÏÑ± ÌôïÏù∏
    const expectedMCPServers = 12;
    if (this.syncResults.mcp.servers.length !== expectedMCPServers) {
      inconsistencies.push(`MCP ÏÑúÎ≤Ñ Ïàò Î∂àÏùºÏπò: ÏòàÏÉÅ ${expectedMCPServers}Í∞ú, Ïã§Ï†ú ${this.syncResults.mcp.servers.length}Í∞ú`);
    }
    
    // Ïô∏Î∂Ä AI ÎèÑÍµ¨ ÏÉÅÌÉú ÌôïÏù∏
    const aiToolsExpected = ['codex', 'gemini', 'qwen'];
    const aiToolsActual = aiToolsExpected.filter(tool => 
      this.syncResults[tool].status === 'synced'
    );
    
    if (aiToolsActual.length !== aiToolsExpected.length) {
      inconsistencies.push(`Ïô∏Î∂Ä AI ÎèÑÍµ¨ ÎèôÍ∏∞Ìôî Î∂àÏôÑÏ†Ñ: ${aiToolsExpected.length - aiToolsActual.length}Í∞ú Ïã§Ìå®`);
    }
    
    if (inconsistencies.length > 0) {
      this.log('warn', '‚ö†Ô∏è  ÏÑ§Ï†ï ÏùºÍ¥ÄÏÑ± Î¨∏Ï†ú:');
      inconsistencies.forEach(issue => this.log('warn', `   - ${issue}`));
    } else {
      this.log('success', '‚úÖ Î™®Îì† ÏÑ§Ï†ïÏù¥ ÏùºÍ¥ÄÏÑ± ÏûàÍ≤å ÎèôÍ∏∞ÌôîÎê®');
    }
    
    return inconsistencies;
  }

  // === ÎèôÍ∏∞Ìôî Í≤∞Í≥º Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ===
  generateSyncReport() {
    const endTime = Date.now();
    const duration = endTime - this.startTime;
    
    const report = {
      timestamp: new Date().toISOString(),
      duration_ms: duration,
      summary: {
        claude_subagents: {
          total: this.syncResults.claude.agents.length,
          status: this.syncResults.claude.status,
          errors: this.syncResults.claude.errors.length
        },
        external_ai_tools: {
          codex_cli: { status: this.syncResults.codex.status },
          gemini_cli: { status: this.syncResults.gemini.status },
          qwen_cli: { status: this.syncResults.qwen.status }
        },
        mcp_servers: {
          total: this.syncResults.mcp.servers.length,
          status: this.syncResults.mcp.status,
          servers: this.syncResults.mcp.servers
        }
      },
      details: this.syncResults
    };
    
    this.log('info', 'üìä ÎèôÍ∏∞Ìôî Î≥¥Í≥†ÏÑú:');
    this.log('info', `   ‚è±Ô∏è  ÏÜåÏöîÏãúÍ∞Ñ: ${duration}ms`);
    this.log('info', `   ü§ñ Claude ÏóêÏù¥Ï†ÑÌä∏: ${report.summary.claude_subagents.total}Í∞ú (${report.summary.claude_subagents.status})`);
    this.log('info', `   üîß Ïô∏Î∂Ä AI ÎèÑÍµ¨: Codex(${this.syncResults.codex.status}), Gemini(${this.syncResults.gemini.status}), Qwen(${this.syncResults.qwen.status})`);
    this.log('info', `   üîå MCP ÏÑúÎ≤Ñ: ${report.summary.mcp_servers.total}Í∞ú (${report.summary.mcp_servers.status})`);
    
    return report;
  }

  // === Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìúÎì§ ===
  async checkWSLEnvironment() {
    try {
      const result = execSync('uname -a', { encoding: 'utf8' });
      return result.includes('microsoft') || result.includes('WSL');
    } catch {
      return false;
    }
  }

  async checkAIToolsInstallation() {
    const tools = ['claude', 'gemini', 'qwen', 'codex-cli'];
    const installedTools = [];
    
    for (const tool of tools) {
      try {
        execSync(`which ${tool}`, { stdio: 'ignore' });
        installedTools.push(tool);
      } catch {
        // ÎèÑÍµ¨Í∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùå
      }
    }
    
    this.log('debug', `üõ†Ô∏è  ÏÑ§ÏπòÎêú AI ÎèÑÍµ¨: ${installedTools.join(', ')}`);
    return installedTools;
  }

  async checkMCPServerStatus() {
    try {
      // Claude Code MCP ÏÉÅÌÉú ÌôïÏù∏ (ÏûàÎã§Î©¥)
      execSync('claude mcp list', { stdio: 'ignore' });
      this.log('debug', 'üîå MCP ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ ÏôÑÎ£å');
    } catch {
      this.log('warn', '‚ö†Ô∏è  MCP ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå® (Ï†ïÏÉÅÏùº Ïàò ÏûàÏùå)');
    }
  }

  async applyFixes() {
    this.log('info', 'üîß ÏûêÎèô ÏàòÏ†ï Ï†ÅÏö© Ï§ë...');
    
    // Ïó¨Í∏∞Ïóê ÏûêÎèô ÏàòÏ†ï Î°úÏßÅ Íµ¨ÌòÑ
    // Ïòà: ÎàÑÎùΩÎêú ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ±, Í∂åÌïú Î¨∏Ï†ú Ìï¥Í≤∞ Îì±
    
    this.log('success', '‚úÖ ÏûêÎèô ÏàòÏ†ï ÏôÑÎ£å');
  }

  // === Î°úÍπÖ ÏãúÏä§ÌÖú ===
  log(level, message) {
    const timestamp = new Date().toISOString().slice(11, 19);
    const prefix = {
      debug: 'üîç',
      info: '‚ÑπÔ∏è',
      warn: '‚ö†Ô∏è',
      error: '‚ùå',
      success: '‚úÖ'
    }[level] || '‚ÑπÔ∏è';
    
    console.log(`[${timestamp}] ${prefix} ${message}`);
  }
}

// === CLI Ïã§Ìñâ ===
async function main() {
  const args = process.argv.slice(2);
  const options = {
    verbose: args.includes('--verbose') || args.includes('-v'),
    dryRun: args.includes('--dry-run') || args.includes('-d'),
    forceFix: args.includes('--fix') || args.includes('-f'),
    help: args.includes('--help') || args.includes('-h')
  };
  
  if (options.help) {
    console.log(`
AI ÏóêÏù¥Ï†ÑÌä∏ ÎèôÍ∏∞Ìôî Ïä§ÌÅ¨Î¶ΩÌä∏

ÏÇ¨Ïö©Î≤ï:
  node ai-agent-sync.mjs [ÏòµÏÖò]

ÏòµÏÖò:
  -v, --verbose    ÏÉÅÏÑ∏ Î°úÍ∑∏ Ï∂úÎ†•
  -d, --dry-run    Ïã§Ï†ú Î≥ÄÍ≤Ω ÏóÜÏù¥ Í≤ÄÏ¶ùÎßå ÏàòÌñâ
  -f, --fix        ÏûêÎèô ÏàòÏ†ï Ï†ÅÏö©
  -h, --help       ÎèÑÏõÄÎßê ÌëúÏãú

ÏòàÏãú:
  node ai-agent-sync.mjs --verbose
  node ai-agent-sync.mjs --dry-run --fix
    `);
    return;
  }
  
  try {
    const syncManager = new AIAgentSyncManager();
    const report = await syncManager.synchronize(options);
    
    // Î≥¥Í≥†ÏÑúÎ•º ÌååÏùºÎ°ú Ï†ÄÏû• (ÏòµÏÖò)
    if (!options.dryRun) {
      const reportPath = path.join(syncManager.projectRoot, 'logs', 'ai-agent-sync-report.json');
      await fs.mkdir(path.dirname(reportPath), { recursive: true });
      await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
      console.log(`üìÑ Î≥¥Í≥†ÏÑú Ï†ÄÏû•Îê®: ${reportPath}`);
    }
    
    process.exit(0);
    
  } catch (error) {
    console.error(`‚ùå ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${error.message}`);
    process.exit(1);
  }
}

// Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä ÏßÅÏ†ë Ïã§ÌñâÎê† ÎïåÎßå main Ìï®Ïàò Ìò∏Ï∂ú
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export default AIAgentSyncManager;