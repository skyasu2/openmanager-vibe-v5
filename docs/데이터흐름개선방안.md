# 🔧 데이터 흐름 개선 방안

> **분석 일자**: 2025년 6월 19일  
> **분석 범위**: 프론트엔드 시작버튼 → 서버 데이터 생성 → AI 분석 → 프론트엔드 수신

## 📊 현재 상태 요약

### ✅ 정상 동작 부분

- **서버 데이터 생성**: 15개 서버, 418ms 응답시간
- **AI 예측 시스템**: 80% 신뢰도, 33ms 응답시간
- **AI 추천 시스템**: 3개 카테고리, 239ms 응답시간
- **대시보드 통합**: 615ms 응답시간

### ⚠️ 개선 필요 부분

- **헬스체크**: 5020ms (목표: 1000ms 이하)
- **시스템 초기화**: 지연 발생
- **실시간 연동**: AI-서버 데이터 간 동기화 부족

## 🎯 개선 방안

### 1. 헬스체크 최적화

#### **문제점**

```javascript
// 현재: MCP 서버 연결 타임아웃으로 5초 지연
{"mcp":{"status":"degraded","details":{"error":"This operation was aborted"}}}
```

#### **해결책**

```javascript
// src/app/api/health/route.ts 개선
export async function GET() {
  const checks = await Promise.allSettled([
    checkEnvironment(),
    checkRedis(),
    checkGenerator(),
    // MCP 체크를 병렬로 처리하되 타임아웃 단축
    Promise.race([
      checkMCP(),
      new Promise(resolve =>
        setTimeout(
          () =>
            resolve({
              status: 'degraded',
              details: { message: '타임아웃 (3초)' },
            }),
          3000
        )
      ),
    ]),
  ]);

  // 결과 처리...
}
```

### 2. 데이터 생성기 사전 초기화

#### **문제점**

```javascript
// 현재: API 첫 호출 시에만 초기화
if (generator.getAllServers().length === 0) {
  await generator.initialize(); // 지연 발생
}
```

#### **해결책**

```javascript
// src/app/layout.tsx에 초기화 로직 추가
'use client';

import { useEffect } from 'react';
import { RealServerDataGenerator } from '@/services/data-generator/RealServerDataGenerator';

export default function RootLayout({ children }) {
  useEffect(() => {
    // 앱 시작 시 백그라운드에서 데이터 생성기 초기화
    const initializeDataGenerator = async () => {
      try {
        const generator = RealServerDataGenerator.getInstance();
        await generator.initialize();
        generator.startAutoGeneration();
        console.log('✅ 데이터 생성기 사전 초기화 완료');
      } catch (error) {
        console.warn('⚠️ 데이터 생성기 초기화 실패:', error);
      }
    };

    initializeDataGenerator();
  }, []);

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}
```

### 3. AI-서버 데이터 실시간 연동 강화

#### **문제점**

```javascript
// 현재: AI 예측이 샘플 데이터 기반
const history = await this.collectServerHistory(serverId);
if (history.length === 0) {
  return this.generateSampleHistory(serverId); // 실제 데이터 미사용
}
```

#### **해결책**

```javascript
// src/services/ai/PredictiveAnalytics.ts 개선
class PredictiveAnalytics {
  private realTimeDataFeed: Map<string, ServerMetricPoint[]> = new Map();

  async collectServerHistory(serverId: string): Promise<ServerMetricPoint[]> {
    // 1. 실시간 데이터 우선 사용
    const realtimeData = this.realTimeDataFeed.get(serverId);
    if (realtimeData && realtimeData.length > 10) {
      return realtimeData;
    }

    // 2. API에서 실제 서버 데이터 가져오기
    try {
      const response = await fetch('/api/servers');
      const data = await response.json();
      const server = data.servers.find(s => s.id === serverId);

      if (server) {
        return this.convertToMetricPoints(server);
      }
    } catch (error) {
      console.warn('실시간 데이터 수집 실패:', error);
    }

    // 3. 폴백: 샘플 데이터
    return this.generateSampleHistory(serverId);
  }

  // 실시간 메트릭 피드 등록
  subscribeToServerMetrics(serverId: string, callback: (metrics: ServerMetricPoint) => void) {
    // WebSocket 또는 폴링으로 실시간 데이터 수집
    const interval = setInterval(async () => {
      const response = await fetch(`/api/servers/${serverId}/metrics`);
      const metrics = await response.json();

      if (metrics.success) {
        const point = this.convertToMetricPoint(metrics.data);

        // 히스토리 업데이트
        const history = this.realTimeDataFeed.get(serverId) || [];
        history.push(point);

        // 최대 100개 포인트 유지
        if (history.length > 100) {
          history.shift();
        }

        this.realTimeDataFeed.set(serverId, history);
        callback(point);
      }
    }, 15000); // 15초 간격

    return () => clearInterval(interval);
  }
}
```

### 4. 프론트엔드 성능 최적화

#### **문제점**

```javascript
// 현재: 불필요한 재렌더링과 중복 API 호출
const { servers, isLoading: realtimeLoading } = useRealtimeServers();
// 매번 새로운 객체 생성으로 무한 재렌더링 위험
```

#### **해결책**

```javascript
// src/hooks/api/useRealtimeServers.ts 개선
export function useRealtimeServers(options: UseRealtimeServersOptions = {}) {
  const [servers, setServers] = useState<ServerInstance[]>([]);
  const [lastFetch, setLastFetch] = useState<number>(0);
  const cacheRef = useRef<Map<string, any>>(new Map());

  const fetchServers = useCallback(async () => {
    const now = Date.now();

    // 캐시 확인 (30초 이내 재사용)
    if (now - lastFetch < 30000 && cacheRef.current.has('servers')) {
      return cacheRef.current.get('servers');
    }

    try {
      const response = await fetch('/api/servers', {
        headers: {
          'Cache-Control': 'max-age=30'
        }
      });

      const data = await response.json();

      if (data.success) {
        // 캐시 저장
        cacheRef.current.set('servers', data.servers);
        setLastFetch(now);
        setServers(data.servers);
        return data.servers;
      }
    } catch (error) {
      console.error('서버 데이터 조회 실패:', error);
    }

    return [];
  }, [lastFetch]);

  // 중복 호출 방지를 위한 디바운싱
  const debouncedFetch = useMemo(
    () => debounce(fetchServers, 1000),
    [fetchServers]
  );

  useEffect(() => {
    debouncedFetch();

    if (options.autoRefresh) {
      const interval = setInterval(debouncedFetch, options.refreshInterval || 30000);
      return () => clearInterval(interval);
    }
  }, [debouncedFetch, options.autoRefresh, options.refreshInterval]);

  return {
    servers: useMemo(() => servers, [servers]), // 메모이제이션으로 불필요한 재렌더링 방지
    isLoading: false,
    refresh: debouncedFetch
  };
}
```

### 5. 에러 처리 및 폴백 강화

#### **해결책**

```javascript
// src/components/ErrorBoundary.tsx 개선
class DataFlowErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      errorType: null,
      retryCount: 0,
    };
  }

  static getDerivedStateFromError(error) {
    // 에러 타입별 분류
    if (error.message.includes('fetch')) {
      return { hasError: true, errorType: 'network' };
    } else if (error.message.includes('timeout')) {
      return { hasError: true, errorType: 'timeout' };
    }
    return { hasError: true, errorType: 'unknown' };
  }

  handleRetry = () => {
    if (this.state.retryCount < 3) {
      this.setState({
        hasError: false,
        retryCount: this.state.retryCount + 1,
      });
    }
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className='error-fallback'>
          <h2>데이터 로딩 중 문제가 발생했습니다</h2>
          <p>에러 타입: {this.state.errorType}</p>
          <button onClick={this.handleRetry}>
            다시 시도 ({3 - this.state.retryCount}회 남음)
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## 📈 예상 개선 효과

| **항목**           | **현재** | **개선 후** | **개선율**      |
| ------------------ | -------- | ----------- | --------------- |
| 헬스체크 응답시간  | 5020ms   | 1000ms      | **80% 개선**    |
| 시스템 초기화 시간 | 3-5초    | 즉시        | **100% 개선**   |
| AI 예측 정확도     | 80%      | 90%+        | **12% 개선**    |
| 프론트엔드 렌더링  | 불안정   | 안정적      | **안정성 향상** |

## 🎯 구현 우선순위

### **Phase 1 (즉시 적용 가능)**

1. ✅ 헬스체크 타임아웃 단축 (3초)
2. ✅ 데이터 생성기 사전 초기화
3. ✅ API 응답 캐싱 구현

### **Phase 2 (1주 내 구현)**

1. 🔄 AI-서버 데이터 실시간 연동
2. 🔄 프론트엔드 성능 최적화
3. 🔄 에러 처리 강화

### **Phase 3 (장기 개선)**

1. 📊 WebSocket 기반 실시간 통신
2. 📊 AI 모델 정확도 향상
3. 📊 사용자 경험 모니터링

## 🧪 테스트 방법

### **성능 테스트**

```bash
# 개선 전후 성능 비교
node scripts/test-data-flow.js

# 부하 테스트
npm run test:load

# 메모리 누수 검사
npm run test:memory
```

### **품질 검증**

```bash
# TypeScript 컴파일 검증
npm run type-check

# 단위 테스트
npm run test:unit

# 통합 테스트
npm run test:integration
```

---

**📝 작성자**: AI 분석 시스템  
**🔄 업데이트**: 실시간 성능 모니터링 기반  
**🎯 목표**: 사용자 경험 최적화 및 시스템 안정성 향상
