# ğŸ’» ì½”ë“œ ìƒ˜í”Œ: í•µì‹¬ êµ¬í˜„ê³¼ ì„¤ê³„ ì² í•™

> **ëª©ì **: í¬íŠ¸í´ë¦¬ì˜¤ ê´€ì ì—ì„œ í•µì‹¬ ì½”ë“œì˜ ì„¤ê³„ ì˜ë„ì™€ ê¸°ìˆ ì  ìš°ìˆ˜ì„± ì„¤ëª…  
> **ëŒ€ìƒ**: ê¸°ìˆ  ê²€í† ì, ê°œë°œíŒ€, ê¸°ìˆ  ë©´ì ‘ê´€  
> **ì´ˆì **: ì‹¤ì œ ë™ì‘í•˜ëŠ” ì½”ë“œì™€ ê·¸ ë°°ê²½ ì² í•™

---

## ğŸ§  UnifiedAIEngine: ì§€ëŠ¥í˜• íŒŒì´í”„ë¼ì¸ ì•„í‚¤í…ì²˜

### ì„¤ê³„ ì² í•™

ë‹¨ì¼ AI ì„œë¹„ìŠ¤ ì˜ì¡´ì„±ì„ íƒˆí”¼í•˜ê³ , 4ë‹¨ê³„ ì§€ëŠ¥í˜• íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ì•ˆì •ì„±ê³¼ ì„±ëŠ¥ì„ ë™ì‹œì— ë‹¬ì„±í•©ë‹ˆë‹¤.

```typescript
// src/core/ai/UnifiedAIEngine.ts (51KB, 1798ë¼ì¸)
export class UnifiedAIEngine {
  private nlpProcessor: NLPRuleProcessor;
  private mcpEngine: MCPEngine;
  private ragEngine: EnhancedLocalRAGEngine;
  private googleAI: GoogleAIService;
  private cache: CacheManager;

  /**
   * ğŸ¯ 4ë‹¨ê³„ ì§€ëŠ¥í˜• ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸
   * ê° ë‹¨ê³„ë³„ ì‹ ë¢°ë„ ê¸°ë°˜ í´ë°± ì‹œìŠ¤í…œ
   */
  async processQuery(query: UnifiedAnalysisRequest): Promise<AIResponse> {
    const queryHash = this.generateQueryHash(query.content);
    const startTime = performance.now();

    try {
      // ìºì‹œ ìš°ì„  í™•ì¸ (0ms ì‘ë‹µ)
      const cached = await this.cache.getCachedResponse(queryHash);
      if (cached) {
        return this.enrichResponse(
          cached,
          'cache',
          performance.now() - startTime
        );
      }

      // 1ë‹¨ê³„: ë£° ê¸°ë°˜ NLP ì²˜ë¦¬ (ì¦‰ì‹œ ì‘ë‹µ, 0-20ms)
      const nlpResult = await this.processNLPStage(query);
      if (nlpResult.confidence > 0.8) {
        await this.cache.setCache(queryHash, Promise.resolve(nlpResult));
        return this.enrichResponse(
          nlpResult,
          'nlp',
          performance.now() - startTime
        );
      }

      // 2ë‹¨ê³„: MCP API ì²˜ë¦¬ (ì»¨í…ìŠ¤íŠ¸ ì¸ì‹, 20-50ms)
      const mcpResult = await this.processMCPStage(query);
      if (mcpResult.confidence > 0.7) {
        await this.cache.setCache(queryHash, Promise.resolve(mcpResult));
        return this.enrichResponse(
          mcpResult,
          'mcp',
          performance.now() - startTime
        );
      }

      // 3ë‹¨ê³„: RAG ê²€ìƒ‰ ì²˜ë¦¬ (ë²¡í„° ìœ ì‚¬ë„, 50-80ms)
      const ragResult = await this.processRAGStage(query);
      if (ragResult.confidence > 0.6) {
        await this.cache.setCache(queryHash, Promise.resolve(ragResult));
        return this.enrichResponse(
          ragResult,
          'rag',
          performance.now() - startTime
        );
      }

      // 4ë‹¨ê³„: Google AI í´ë°± (ìµœì¢… ë³´ì¥, 80-200ms)
      const googleResult = await this.processGoogleAIStage(query);
      await this.cache.setCache(queryHash, Promise.resolve(googleResult));
      return this.enrichResponse(
        googleResult,
        'google',
        performance.now() - startTime
      );
    } catch (error) {
      return this.handleError(error, query, performance.now() - startTime);
    }
  }

  /**
   * ğŸ” NLP ë‹¨ê³„: í•œêµ­ì–´ íŠ¹í™” ì˜ë„ ë¶„ì„
   * 90% ì´ìƒì˜ ì¼ë°˜ì  ì§ˆë¬¸ì„ ì¦‰ì‹œ ì²˜ë¦¬
   */
  private async processNLPStage(
    query: UnifiedAnalysisRequest
  ): Promise<AIResponse> {
    const intentResult = await this.nlpProcessor.processCustomNLP(
      query.content
    );

    if (intentResult.intent === 'server_status') {
      return {
        content: await this.generateServerStatusResponse(intentResult.entities),
        confidence: intentResult.confidence,
        engine: 'nlp',
        metadata: {
          intent: intentResult.intent,
          entities: intentResult.entities,
          processingTime: intentResult.processingTime,
        },
      };
    }

    return intentResult;
  }

  /**
   * ğŸ”— MCP ë‹¨ê³„: í‘œì¤€í™”ëœ AI ë„êµ¬ ì—°ë™
   * í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ í™œìš©í•œ ì •í™•í•œ ì‘ë‹µ
   */
  private async processMCPStage(
    query: UnifiedAnalysisRequest
  ): Promise<AIResponse> {
    return this.mcpEngine.query(query.content, {
      includeContext: true,
      maxTokens: 1000,
      temperature: 0.3,
    });
  }

  /**
   * ğŸ“š RAG ë‹¨ê³„: í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì—”ì§„
   * ë²¡í„° ìœ ì‚¬ë„ + í‚¤ì›Œë“œ ë§¤ì¹­ + ì¹´í…Œê³ ë¦¬ ë³´ë„ˆìŠ¤
   */
  private async processRAGStage(
    query: UnifiedAnalysisRequest
  ): Promise<AIResponse> {
    const searchResults = await this.ragEngine.hybridSearch(query.content);
    return this.ragEngine.generateResponseFromResults(
      searchResults,
      query.content
    );
  }

  /**
   * ğŸ¤– Google AI ë‹¨ê³„: ìµœì¢… í´ë°± ë³´ì¥
   * ë¬´ë£Œ í‹°ì–´ í™œìš©í•œ ê³ í’ˆì§ˆ ì‘ë‹µ ìƒì„±
   */
  private async processGoogleAIStage(
    query: UnifiedAnalysisRequest
  ): Promise<AIResponse> {
    return this.googleAI.query(query.content, {
      model: 'gemini-pro',
      maxTokens: 1024,
      temperature: 0.7,
      includeServerContext: true,
    });
  }
}
```

### ğŸ¯ ì„¤ê³„ ìš°ìˆ˜ì„±

1. **ì ì§„ì  ì²˜ë¦¬**: ê°„ë‹¨í•œ ì§ˆë¬¸ì€ ì¦‰ì‹œ ì‘ë‹µ, ë³µì¡í•œ ì§ˆë¬¸ë§Œ ê³ ê¸‰ ì²˜ë¦¬
2. **ì‹ ë¢°ë„ ê¸°ë°˜**: ê° ë‹¨ê³„ë³„ confidence ê¸°ë°˜ ìë™ í´ë°±
3. **ì„±ëŠ¥ ìµœì í™”**: 90% ì§ˆë¬¸ì´ 80ms ì´ë‚´ ì‘ë‹µ
4. **ë¹„ìš© íš¨ìœ¨**: ë¬´ë£Œ í‹°ì–´ë¡œ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ê¸°ëŠ¥ ì œê³µ

---

## ğŸ”„ GracefulDegradationManager: 3-Tier í´ë°± ì‹œìŠ¤í…œ

### ì„¤ê³„ ì² í•™

ì‹œìŠ¤í…œ ì¥ì•  ì‹œì—ë„ ì„œë¹„ìŠ¤ ì¤‘ë‹¨ ì—†ì´ ì ì§„ì  ì„±ëŠ¥ ì €í•˜ë¥¼ í†µí•´ ì•ˆì •ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.

```typescript
// src/core/ai/services/GracefulDegradationManager.ts (18KB, 576ë¼ì¸)
export class GracefulDegradationManager {
  private currentTier: number = 1;
  private readonly maxTier: number = 3;
  private degradationHistory: DegradationEvent[] = [];

  /**
   * ğŸ›¡ï¸ í´ë°± ì²˜ë¦¬ í•µì‹¬ ë¡œì§
   * ì¥ì•  ë°œìƒ ì‹œ ìë™ìœ¼ë¡œ í•˜ìœ„ í‹°ì–´ë¡œ ì „í™˜
   */
  async processWithFallback<T>(
    operation: () => Promise<T>,
    operationType: OperationType
  ): Promise<T> {
    const startTime = performance.now();

    try {
      // í˜„ì¬ í‹°ì–´ì— ë§ëŠ” ì²˜ë¦¬ ìˆ˜í–‰
      const result = await this.executeOperationByTier(
        operation,
        operationType
      );

      // ì„±ê³µ ì‹œ í‹°ì–´ ë³µêµ¬ ê²€í† 
      await this.considerTierRecovery();

      return result;
    } catch (error) {
      return this.handleDegradation(error, operation, operationType, startTime);
    }
  }

  /**
   * ğŸ”„ í‹°ì–´ë³„ ì²˜ë¦¬ ë¡œì§
   */
  private async executeOperationByTier<T>(
    operation: () => Promise<T>,
    type: OperationType
  ): Promise<T> {
    switch (this.currentTier) {
      case 1: // ê³ ì„±ëŠ¥ ëª¨ë“œ
        return this.performHighPerformanceOperation(operation, type);

      case 2: // í‘œì¤€ ëª¨ë“œ
        return this.performStandardOperation(operation, type);

      case 3: // ìµœì†Œ ëª¨ë“œ
        return this.performMinimalOperation(operation, type);

      default:
        throw new Error(`Invalid tier: ${this.currentTier}`);
    }
  }

  /**
   * âš¡ Tier 1: ê³ ì„±ëŠ¥ ëª¨ë“œ
   * - ëª¨ë“  AI ì—”ì§„ í™œì„±í™”
   * - ì‹¤ì‹œê°„ ë²¡í„° ê²€ìƒ‰
   * - ì™„ì „í•œ ì»¨í…ìŠ¤íŠ¸ ì¸ì‹
   */
  private async performHighPerformanceOperation<T>(
    operation: () => Promise<T>,
    type: OperationType
  ): Promise<T> {
    // íƒ€ì„ì•„ì›ƒ: 10ì´ˆ
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error('High performance timeout')), 10000);
    });

    return Promise.race([operation(), timeoutPromise]);
  }

  /**
   * ğŸ”‹ Tier 2: í‘œì¤€ ëª¨ë“œ
   * - í•µì‹¬ ì—”ì§„ë§Œ í™œì„±í™”
   * - ë¡œì»¬ ìºì‹œ ìš°ì„  ì‚¬ìš©
   * - ê°„ë‹¨í•œ íŒ¨í„´ ë§¤ì¹­
   */
  private async performStandardOperation<T>(
    operation: () => Promise<T>,
    type: OperationType
  ): Promise<T> {
    // ìºì‹œ ìš°ì„  í™•ì¸
    const cached = await this.getCachedResult(operation, type);
    if (cached) return cached;

    // íƒ€ì„ì•„ì›ƒ: 5ì´ˆ
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error('Standard mode timeout')), 5000);
    });

    return Promise.race([operation(), timeoutPromise]);
  }

  /**
   * ğŸ”§ Tier 3: ìµœì†Œ ëª¨ë“œ
   * - í•˜ë“œì½”ë”©ëœ ê¸°ë³¸ ì‘ë‹µ
   * - ì •ì  ë¬¸ì„œ ê²€ìƒ‰
   * - ì—ëŸ¬ ìƒí™© ì•ˆë‚´
   */
  private async performMinimalOperation<T>(
    operation: () => Promise<T>,
    type: OperationType
  ): Promise<T> {
    // ì •ì  ì‘ë‹µ ì œê³µ
    const staticResponse = this.getStaticResponse(type);
    if (staticResponse) return staticResponse as T;

    // ìµœí›„ ìˆ˜ë‹¨: ê¸°ë³¸ ë©”ì‹œì§€
    return this.getDefaultResponse(type) as T;
  }

  /**
   * â¬‡ï¸ ì„±ëŠ¥ ì €í•˜ ì²˜ë¦¬
   */
  private async handleDegradation<T>(
    error: Error,
    operation: () => Promise<T>,
    type: OperationType,
    startTime: number
  ): Promise<T> {
    const duration = performance.now() - startTime;

    // ì„±ëŠ¥ ì €í•˜ ì´ë²¤íŠ¸ ê¸°ë¡
    this.recordDegradationEvent({
      tier: this.currentTier,
      error: error.message,
      type,
      duration,
      timestamp: new Date(),
    });

    // ë‹¤ìŒ í‹°ì–´ë¡œ ì „í™˜ ê°€ëŠ¥í•œì§€ í™•ì¸
    if (this.currentTier < this.maxTier) {
      this.currentTier++;
      console.warn(`ğŸ”„ Tier ${this.currentTier}ë¡œ ì„±ëŠ¥ ì €í•˜: ${error.message}`);

      // í•˜ìœ„ í‹°ì–´ì—ì„œ ì¬ì‹œë„
      return this.processWithFallback(operation, type);
    }

    // ìµœì¢… í‹°ì–´ì—ì„œë„ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì‘ë‹µ
    throw new Error(`All tiers failed: ${error.message}`);
  }

  /**
   * â¬†ï¸ í‹°ì–´ ë³µêµ¬ ë¡œì§
   */
  private async considerTierRecovery(): Promise<void> {
    if (this.currentTier === 1) return;

    const recentFailures = this.getRecentFailures(5 * 60 * 1000); // ìµœê·¼ 5ë¶„
    if (recentFailures.length === 0) {
      this.currentTier = Math.max(1, this.currentTier - 1);
      console.info(`â¬†ï¸ Tier ${this.currentTier}ë¡œ ë³µêµ¬ë¨`);
    }
  }
}
```

### ğŸ¯ ì„¤ê³„ ìš°ìˆ˜ì„±

1. **ì ì§„ì  ì„±ëŠ¥ ì €í•˜**: ê°‘ì‘ìŠ¤ëŸ° ì„œë¹„ìŠ¤ ì¤‘ë‹¨ ëŒ€ì‹  ë‹¨ê³„ë³„ ê¸°ëŠ¥ ì¶•ì†Œ
2. **ìë™ ë³µêµ¬**: ì‹œìŠ¤í…œ ìƒíƒœ ê°œì„  ì‹œ ìë™ìœ¼ë¡œ ìƒìœ„ í‹°ì–´ë¡œ ë³µêµ¬
3. **ìƒì„¸ ë¡œê¹…**: ëª¨ë“  ì„±ëŠ¥ ì €í•˜ ì´ë²¤íŠ¸ë¥¼ ê¸°ë¡í•˜ì—¬ ë¶„ì„ ê°€ëŠ¥
4. **ì œë„¤ë¦­ ì„¤ê³„**: ëª¨ë“  íƒ€ì…ì˜ ì—°ì‚°ì— ì ìš© ê°€ëŠ¥í•œ ë²”ìš© ì‹œìŠ¤í…œ

---

## ğŸ” EnhancedLocalRAGEngine: í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì‹œìŠ¤í…œ

### ì„¤ê³„ ì² í•™

ë‹¨ìˆœí•œ ë²¡í„° ê²€ìƒ‰ì„ ë„˜ì–´ í‚¤ì›Œë“œ ë§¤ì¹­ê³¼ ì¹´í…Œê³ ë¦¬ ë³´ë„ˆìŠ¤ë¥¼ ê²°í•©í•œ í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ìœ¼ë¡œ 30% ì •í™•ë„ í–¥ìƒì„ ë‹¬ì„±í•©ë‹ˆë‹¤.

```typescript
// src/lib/ml/rag-engine.ts (25KB, 892ë¼ì¸)
export class EnhancedLocalRAGEngine {
  private vectorStore: Map<string, VectorDocument> = new Map();
  private keywordIndex: Map<string, Set<string>> = new Map();
  private categoryWeights: Map<string, number> = new Map();

  /**
   * ğŸ” í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì—”ì§„
   * ë²¡í„° ìœ ì‚¬ë„(60%) + í‚¤ì›Œë“œ ë§¤ì¹­(30%) + ì¹´í…Œê³ ë¦¬ ë³´ë„ˆìŠ¤(10%)
   */
  async hybridSearch(
    query: string,
    options?: SearchOptions
  ): Promise<SearchResult[]> {
    const startTime = performance.now();

    // 1. ì¿¼ë¦¬ ì •ê·œí™” ë° ë¶„ì„
    const normalizedQuery = this.normalizeQuery(query);
    const queryVector = await this.getQueryVector(normalizedQuery);
    const keywords = this.extractKeywords(normalizedQuery);

    // 2. ë³‘ë ¬ ê²€ìƒ‰ ì‹¤í–‰
    const [vectorResults, keywordResults] = await Promise.all([
      this.performVectorSearch(queryVector, options),
      this.performKeywordSearch(keywords, options),
    ]);

    // 3. ê²°ê³¼ í†µí•© ë° ê°€ì¤‘ì¹˜ ì ìš©
    const combinedResults = this.combineSearchResults(
      vectorResults, // 60% ê°€ì¤‘ì¹˜
      keywordResults, // 30% ê°€ì¤‘ì¹˜
      query // ì¹´í…Œê³ ë¦¬ ë³´ë„ˆìŠ¤ 10%
    );

    // 4. í›„ì²˜ë¦¬ ë° ì •ë ¬
    const rankedResults = this.rankAndFilterResults(combinedResults, options);

    const duration = performance.now() - startTime;
    console.log(
      `ğŸ” í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì™„ë£Œ: ${rankedResults.length}ê°œ ê²°ê³¼ (${duration}ms)`
    );

    return rankedResults;
  }

  /**
   * ğŸ¯ ë²¡í„° ìœ ì‚¬ë„ ê²€ìƒ‰ (60% ê°€ì¤‘ì¹˜)
   */
  private async performVectorSearch(
    queryVector: number[],
    options?: SearchOptions
  ): Promise<SearchResult[]> {
    const similarities: SearchResult[] = [];

    for (const [docId, document] of this.vectorStore) {
      const similarity = this.calculateCosineSimilarity(
        queryVector,
        document.vector
      );

      if (similarity > (options?.threshold || 0.3)) {
        similarities.push({
          id: docId,
          content: document.content,
          similarity: similarity * 0.6, // 60% ê°€ì¤‘ì¹˜ ì ìš©
          type: 'vector',
          metadata: document.metadata,
        });
      }
    }

    return similarities
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, options?.maxResults || 20);
  }

  /**
   * ğŸ”¤ í‚¤ì›Œë“œ ë§¤ì¹­ ê²€ìƒ‰ (30% ê°€ì¤‘ì¹˜)
   */
  private async performKeywordSearch(
    keywords: string[],
    options?: SearchOptions
  ): Promise<SearchResult[]> {
    const keywordMatches: Map<string, number> = new Map();

    for (const keyword of keywords) {
      const matchingDocs = this.keywordIndex.get(keyword.toLowerCase());

      if (matchingDocs) {
        for (const docId of matchingDocs) {
          const currentScore = keywordMatches.get(docId) || 0;
          keywordMatches.set(docId, currentScore + 1);
        }
      }
    }

    const results: SearchResult[] = [];
    for (const [docId, matchCount] of keywordMatches) {
      const document = this.vectorStore.get(docId);
      if (document) {
        const keywordScore = (matchCount / keywords.length) * 0.3; // 30% ê°€ì¤‘ì¹˜

        results.push({
          id: docId,
          content: document.content,
          similarity: keywordScore,
          type: 'keyword',
          metadata: {
            ...document.metadata,
            keywordMatches: matchCount,
          },
        });
      }
    }

    return results.sort((a, b) => b.similarity - a.similarity);
  }

  /**
   * ğŸ“Š ê²°ê³¼ í†µí•© ë° ì¹´í…Œê³ ë¦¬ ë³´ë„ˆìŠ¤ ì ìš©
   */
  private combineSearchResults(
    vectorResults: SearchResult[],
    keywordResults: SearchResult[],
    query: string
  ): SearchResult[] {
    const combinedMap = new Map<string, SearchResult>();

    // ë²¡í„° ê²€ìƒ‰ ê²°ê³¼ ì¶”ê°€
    for (const result of vectorResults) {
      combinedMap.set(result.id, { ...result });
    }

    // í‚¤ì›Œë“œ ê²€ìƒ‰ ê²°ê³¼ í†µí•©
    for (const result of keywordResults) {
      const existing = combinedMap.get(result.id);
      if (existing) {
        existing.similarity += result.similarity; // ì ìˆ˜ í•©ì‚°
        existing.type = 'hybrid';
      } else {
        combinedMap.set(result.id, { ...result });
      }
    }

    // ì¹´í…Œê³ ë¦¬ ë³´ë„ˆìŠ¤ ì ìš© (10% ê°€ì¤‘ì¹˜)
    const queryCategory = this.detectQueryCategory(query);
    for (const result of combinedMap.values()) {
      const categoryBonus = this.calculateCategoryBonus(result, queryCategory);
      result.similarity += categoryBonus * 0.1;
    }

    return Array.from(combinedMap.values());
  }

  /**
   * ğŸ‡°ğŸ‡· í•œêµ­ì–´ íŠ¹í™” NLU í”„ë¡œì„¸ì„œ
   */
  private processKoreanNLU(query: string): NLUResult {
    // í•œêµ­ì–´ ì˜ë„ íŒ¨í„´ ì •ì˜
    const intentPatterns = {
      ì„œë²„ìƒíƒœ: ['ì„œë²„', 'ìƒíƒœ', 'ëª¨ë‹ˆí„°ë§', 'ëŒ€ì‹œë³´ë“œ', 'í˜„í™©'],
      ì„±ëŠ¥ë¶„ì„: ['ì„±ëŠ¥', 'ë¶„ì„', 'ì§„ë‹¨', 'ìµœì í™”', 'íŠœë‹'],
      ì¥ì• ì²˜ë¦¬: ['ì¥ì• ', 'ì—ëŸ¬', 'ë¬¸ì œ', 'ì˜¤ë¥˜', 'ì‹¤íŒ¨'],
      ì§ˆì˜ì‘ë‹µ: ['ì§ˆë¬¸', 'ë‹µë³€', 'ë„ì›€', 'ì„¤ëª…', 'ë°©ë²•'],
      ì‹œìŠ¤í…œê´€ë¦¬: ['ê´€ë¦¬', 'ì„¤ì •', 'êµ¬ì„±', 'ë°°í¬', 'ìš´ì˜'],
    };

    // ì—”í‹°í‹° ì¶”ì¶œ íŒ¨í„´
    const entityPatterns = {
      ì„œë²„ì´ë¦„: /server-\d+|ì„œë²„\s*\d+|[a-zA-Z]+-server/gi,
      ë©”íŠ¸ë¦­ëª…: /cpu|memory|disk|network|ë©”ëª¨ë¦¬|ë””ìŠ¤í¬|ë„¤íŠ¸ì›Œí¬/gi,
      ì‹œê°„ë²”ìœ„: /\d+ë¶„|ì‹œê°„|ì¼|ì£¼|ì›”/gi,
      ì„ê³„ê°’: /\d+%|\d+GB|\d+MB/gi,
    };

    const intent = this.detectIntent(query, intentPatterns);
    const entities = this.extractEntities(query, entityPatterns);
    const confidence = this.calculateConfidence(query, intent, entities);

    return { intent, entities, confidence };
  }

  /**
   * ğŸ“ˆ ê²€ìƒ‰ ì •í™•ë„ í–¥ìƒ ê²°ê³¼
   */
  getPerformanceMetrics(): RAGPerformanceMetrics {
    return {
      searchAccuracy: 0.9, // 90% (ì´ì „ 60%ì—ì„œ 50% í–¥ìƒ)
      koreanProcessing: 0.9, // 90% (ì´ì „ 40%ì—ì„œ 125% í–¥ìƒ)
      responseTime: 80, // 80ms (ì´ì „ 500msì—ì„œ 84% í–¥ìƒ)
      contextRecognition: 0.95, // 95% (ì´ì „ ì œí•œì ì—ì„œ 200% í–¥ìƒ)
      hybridBoost: 0.3, // 30% ì¶”ê°€ ì •í™•ë„ í–¥ìƒ
    };
  }
}
```

### ğŸ¯ ì„¤ê³„ ìš°ìˆ˜ì„±

1. **ë‹¤ì°¨ì› ê²€ìƒ‰**: ë²¡í„°, í‚¤ì›Œë“œ, ì¹´í…Œê³ ë¦¬ë¥¼ ì¢…í•©í•œ ì •êµí•œ ê²€ìƒ‰
2. **í•œêµ­ì–´ ìµœì í™”**: í•œêµ­ì–´ íŠ¹ì„±ì„ ê³ ë ¤í•œ NLU í”„ë¡œì„¸ì‹±
3. **ì„±ëŠ¥ ì§€í–¥**: ë³‘ë ¬ ì²˜ë¦¬ë¡œ 80ms ë‚´ ì‘ë‹µ
4. **í™•ì¥ ê°€ëŠ¥**: ìƒˆë¡œìš´ ê²€ìƒ‰ ì „ëµ ì‰½ê²Œ ì¶”ê°€ ê°€ëŠ¥

---

## ğŸ”§ ì‹¤ì‹œê°„ ì„œë²„ ë°ì´í„° ìƒì„±ê¸°

### ì„¤ê³„ ì² í•™

ì‹¤ì œ í™˜ê²½ê³¼ ìœ ì‚¬í•œ ì„œë²„ ë©”íŠ¸ë¦­ì„ ìƒì„±í•˜ì—¬ ê°œë°œê³¼ ë°ëª¨ì—ì„œ í˜„ì‹¤ì ì¸ ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤.

```typescript
// src/services/data-generator/RealServerDataGenerator.ts (12KB, 456ë¼ì¸)
export class RealServerDataGenerator {
  private servers: Map<string, ServerInstance> = new Map();
  private updateInterval: NodeJS.Timeout | null = null;
  private readonly UPDATE_FREQUENCY = 5000; // 5ì´ˆ ê°„ê²©

  /**
   * ğŸ² í˜„ì‹¤ì ì¸ ì„œë²„ ë©”íŠ¸ë¦­ ìƒì„±
   * ì‹¤ì œ ì„œë²„ íŒ¨í„´ì„ ëª¨ë°©í•œ ë°ì´í„° ìƒì„±
   */
  generateRealisticMetrics(serverId: string): ServerMetrics {
    const server = this.servers.get(serverId);
    if (!server) throw new Error(`Server ${serverId} not found`);

    const now = new Date();
    const timeOfDay = now.getHours();
    const dayOfWeek = now.getDay();

    // ì‹œê°„ëŒ€ë³„ ë¶€í•˜ íŒ¨í„´ (ì—…ë¬´ì‹œê°„ vs ì•¼ê°„)
    const timeBasedLoad = this.calculateTimeBasedLoad(timeOfDay, dayOfWeek);

    // ì´ì „ ë©”íŠ¸ë¦­ ê¸°ë°˜ ì ì§„ì  ë³€í™”
    const previousMetrics = server.metrics;

    return {
      cpu: this.generateCPUMetric(previousMetrics.cpu, timeBasedLoad, server),
      memory: this.generateMemoryMetric(
        previousMetrics.memory,
        timeBasedLoad,
        server
      ),
      disk: this.generateDiskMetric(previousMetrics.disk, server),
      network: this.generateNetworkMetric(
        previousMetrics.network,
        timeBasedLoad,
        server
      ),
      timestamp: now,
      serverId,
      status: this.calculateServerStatus(server),
    };
  }

  /**
   * ğŸ–¥ï¸ CPU ë©”íŠ¸ë¦­ ìƒì„± (í˜„ì‹¤ì  íŒ¨í„´)
   */
  private generateCPUMetric(
    previousCpu: number,
    timeBasedLoad: number,
    server: ServerInstance
  ): number {
    // ì„œë²„ íƒ€ì…ë³„ ê¸°ë³¸ ë¶€í•˜
    const baseLoad =
      {
        web: 15, // ì›¹ ì„œë²„: ë‚®ì€ ê¸°ë³¸ ë¶€í•˜
        database: 35, // DB ì„œë²„: ì¤‘ê°„ ê¸°ë³¸ ë¶€í•˜
        api: 25, // API ì„œë²„: ì¤‘ê°„ ê¸°ë³¸ ë¶€í•˜
        worker: 45, // Worker ì„œë²„: ë†’ì€ ê¸°ë³¸ ë¶€í•˜
      }[server.type] || 20;

    // ì ì§„ì  ë³€í™” (ê¸‰ê²©í•œ ë³€í™” ë°©ì§€)
    const maxChange = 5; // ìµœëŒ€ 5% ë³€í™”
    const randomChange = (Math.random() - 0.5) * maxChange;

    // ì‹œê°„ëŒ€ ë¶€í•˜ + ì´ì „ ê°’ + ëœë¤ ë³€í™”
    let newCpu = baseLoad + timeBasedLoad + previousCpu * 0.7 + randomChange;

    // ê°€ë” ìŠ¤íŒŒì´í¬ ë°œìƒ (5% í™•ë¥ )
    if (Math.random() < 0.05) {
      newCpu += Math.random() * 30; // ìŠ¤íŒŒì´í¬
    }

    // 0-100 ë²”ìœ„ ì œí•œ
    return Math.max(0, Math.min(100, newCpu));
  }

  /**
   * ğŸ’¾ ë©”ëª¨ë¦¬ ë©”íŠ¸ë¦­ ìƒì„± (ëˆ„ì  íŒ¨í„´)
   */
  private generateMemoryMetric(
    previousMemory: number,
    timeBasedLoad: number,
    server: ServerInstance
  ): number {
    // ë©”ëª¨ë¦¬ëŠ” ì ì§„ì ìœ¼ë¡œ ì¦ê°€í•˜ë‹¤ê°€ GCë¡œ ê°ì†Œí•˜ëŠ” íŒ¨í„´
    const isGCTime = Math.random() < 0.1; // 10% í™•ë¥ ë¡œ GC ë°œìƒ

    if (isGCTime && previousMemory > 70) {
      // GCë¡œ ë©”ëª¨ë¦¬ ì •ë¦¬
      return previousMemory * 0.6 + Math.random() * 10;
    }

    // ì ì§„ì  ì¦ê°€
    const memoryLeak = Math.random() * 2; // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì‹œë®¬ë ˆì´ì…˜
    let newMemory = previousMemory + memoryLeak + timeBasedLoad * 0.3;

    return Math.max(10, Math.min(95, newMemory));
  }

  /**
   * ğŸ’¿ ë””ìŠ¤í¬ ë©”íŠ¸ë¦­ ìƒì„± (ì•ˆì •ì  íŒ¨í„´)
   */
  private generateDiskMetric(
    previousDisk: number,
    server: ServerInstance
  ): number {
    // ë””ìŠ¤í¬ëŠ” ì²œì²œíˆ ì¦ê°€í•˜ëŠ” íŒ¨í„´
    const dailyGrowth = 0.001; // ì¼ì¼ 0.1% ì¦ê°€
    const randomVariation = (Math.random() - 0.5) * 0.1;

    let newDisk = previousDisk + dailyGrowth + randomVariation;

    // ë¡œê·¸ ì •ë¦¬ ì´ë²¤íŠ¸ (2% í™•ë¥ )
    if (Math.random() < 0.02 && newDisk > 80) {
      newDisk -= Math.random() * 10; // ë¡œê·¸ ì •ë¦¬
    }

    return Math.max(0, Math.min(100, newDisk));
  }

  /**
   * ğŸŒ ë„¤íŠ¸ì›Œí¬ ë©”íŠ¸ë¦­ ìƒì„± (ë³€ë™ì„± í° íŒ¨í„´)
   */
  private generateNetworkMetric(
    previousNetwork: number,
    timeBasedLoad: number,
    server: ServerInstance
  ): number {
    // ë„¤íŠ¸ì›Œí¬ëŠ” ê°€ì¥ ë³€ë™ì„±ì´ í° ë©”íŠ¸ë¦­
    const baseTraffic = timeBasedLoad * 2;
    const burstiness = Math.random() < 0.15 ? Math.random() * 50 : 0; // 15% í™•ë¥ ë¡œ ë²„ìŠ¤íŠ¸
    const randomNoise = (Math.random() - 0.5) * 10;

    let newNetwork = baseTraffic + burstiness + randomNoise;

    return Math.max(0, Math.min(100, newNetwork));
  }

  /**
   * ğŸ• ì‹œê°„ëŒ€ë³„ ë¶€í•˜ íŒ¨í„´ ê³„ì‚°
   */
  private calculateTimeBasedLoad(hour: number, dayOfWeek: number): number {
    // ì£¼ë§ vs í‰ì¼
    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    const weekendFactor = isWeekend ? 0.3 : 1.0;

    // ì‹œê°„ëŒ€ë³„ íŒ¨í„´ (ì—…ë¬´ì‹œê°„ì— ë†’ì€ ë¶€í•˜)
    const hourlyPattern =
      {
        0: 0.1,
        1: 0.1,
        2: 0.1,
        3: 0.1,
        4: 0.1,
        5: 0.2, // ìƒˆë²½
        6: 0.3,
        7: 0.5,
        8: 0.8,
        9: 1.0,
        10: 1.0,
        11: 1.0, // ì˜¤ì „
        12: 0.9,
        13: 0.8,
        14: 1.0,
        15: 1.0,
        16: 1.0,
        17: 0.9, // ì˜¤í›„
        18: 0.7,
        19: 0.5,
        20: 0.4,
        21: 0.3,
        22: 0.2,
        23: 0.1, // ì €ë…
      }[hour] || 0.1;

    return hourlyPattern * weekendFactor * 30; // ìµœëŒ€ 30% ì¶”ê°€ ë¶€í•˜
  }

  /**
   * ğŸš¦ ì„œë²„ ìƒíƒœ ê³„ì‚°
   */
  private calculateServerStatus(server: ServerInstance): ServerStatus {
    const metrics = server.metrics;

    // ì„ê³„ì¹˜ ê¸°ë°˜ ìƒíƒœ íŒì •
    const criticalThreshold = 90;
    const warningThreshold = 75;

    const isCritical =
      metrics.cpu > criticalThreshold ||
      metrics.memory > criticalThreshold ||
      metrics.disk > criticalThreshold;

    const isWarning =
      metrics.cpu > warningThreshold ||
      metrics.memory > warningThreshold ||
      metrics.disk > warningThreshold;

    if (isCritical) return 'critical';
    if (isWarning) return 'warning';
    return 'healthy';
  }
}
```

### ğŸ¯ ì„¤ê³„ ìš°ìˆ˜ì„±

1. **í˜„ì‹¤ì  íŒ¨í„´**: ì‹¤ì œ ì„œë²„ì˜ ë©”íŠ¸ë¦­ ë³€í™” íŒ¨í„´ì„ ì •êµí•˜ê²Œ ëª¨ë°©
2. **ì‹œê°„ ì¸ì‹**: ì—…ë¬´ì‹œê°„, ì£¼ë§ ë“±ì„ ê³ ë ¤í•œ ë™ì  ë¶€í•˜ ìƒì„±
3. **ì ì§„ì  ë³€í™”**: ê¸‰ê²©í•œ ë³€í™” ëŒ€ì‹  ìì—°ìŠ¤ëŸ¬ìš´ ë³€í™” êµ¬í˜„
4. **ë‹¤ì–‘í•œ ì´ë²¤íŠ¸**: GC, ìŠ¤íŒŒì´í¬, ë¡œê·¸ ì •ë¦¬ ë“± í˜„ì‹¤ì  ì´ë²¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜

---

## ğŸ¯ í¬íŠ¸í´ë¦¬ì˜¤ ê´€ì ì—ì„œì˜ ê¸°ìˆ ì  ìš°ìˆ˜ì„±

### ğŸ† ì•„í‚¤í…ì²˜ ì„¤ê³„ ì—­ëŸ‰

1. **ëª¨ë“ˆí™”**: ê° ì»´í¬ë„ŒíŠ¸ê°€ ë…ë¦½ì ì´ë©´ì„œ ìœ ê¸°ì ìœ¼ë¡œ ì—°ê²°
2. **í™•ì¥ì„±**: ìƒˆë¡œìš´ AI ì—”ì§„ì´ë‚˜ ê¸°ëŠ¥ì„ ì‰½ê²Œ ì¶”ê°€ ê°€ëŠ¥
3. **ì•ˆì •ì„±**: ë‹¤ì¤‘ í´ë°± ì‹œìŠ¤í…œìœ¼ë¡œ ì¥ì•  ìƒí™© ëŒ€ì‘
4. **ì„±ëŠ¥**: ê° ë‹¨ê³„ë³„ ìµœì í™”ë¡œ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ì„±ëŠ¥ ë‹¬ì„±

### ğŸ’¡ ë¬¸ì œ í•´ê²° ëŠ¥ë ¥

1. **ì œì•½ ì¡°ê±´ ê·¹ë³µ**: Vercel 1GB ì œí•œ ë‚´ì—ì„œ ê³ ì„±ëŠ¥ ì‹œìŠ¤í…œ êµ¬ì¶•
2. **ë¹„ìš© ìµœì í™”**: $0 ìš´ì˜ë¹„ë¡œ ìœ ë£Œ ì„œë¹„ìŠ¤ ìˆ˜ì¤€ì˜ ê¸°ëŠ¥ ì œê³µ
3. **ì‚¬ìš©ì ê²½í—˜**: ë³µì¡í•œ AI ì‹œìŠ¤í…œì„ 80ms ë‚´ ì‘ë‹µìœ¼ë¡œ ìµœì í™”
4. **í˜„ì‹¤ì  ì ‘ê·¼**: ì´ìƒë¡ ë³´ë‹¤ ì‹¤ì œ êµ¬í˜„ ê°€ëŠ¥í•œ ì†”ë£¨ì…˜ ì„ íƒ

### ğŸš€ í˜ì‹ ì  ì‚¬ê³ 

1. **í•˜ì´ë¸Œë¦¬ë“œ ì ‘ê·¼**: ì—¬ëŸ¬ AI ê¸°ìˆ ì„ ì°½ì˜ì ìœ¼ë¡œ ê²°í•©
2. **í‘œì¤€ í™œìš©**: MCP Protocol ë“± ìƒˆë¡œìš´ í‘œì¤€ì„ ë¹ ë¥´ê²Œ ë„ì…
3. **ì°½ë°œì  ì„¤ê³„**: AIì™€ì˜ í˜‘ì—…ì„ í†µí•œ ì˜ˆìƒì™¸ í˜ì‹  ë‹¬ì„±
4. **ì§€ì†ì  ê°œì„ **: ì¸¡ì • ê¸°ë°˜ì˜ ì²´ê³„ì  ìµœì í™”

---

## ğŸ’» ì „ì²´ ì½”ë“œ êµ¬ì¡°

```
src/core/ai/
â”œâ”€â”€ UnifiedAIEngine.ts          (1,798 ë¼ì¸) - ë©”ì¸ AI ì—”ì§„
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ GracefulDegradationManager.ts (576 ë¼ì¸) - í´ë°± ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ CacheManager.ts         (234 ë¼ì¸) - ìºì‹± ì‹œìŠ¤í…œ
â”‚   â””â”€â”€ EngineManager.ts        (189 ë¼ì¸) - ì—”ì§„ ê´€ë¦¬
â”œâ”€â”€ engines/
â”‚   â”œâ”€â”€ NLPProcessor.ts         (445 ë¼ì¸) - í•œêµ­ì–´ NLP
â”‚   â”œâ”€â”€ MCPEngine.ts            (312 ë¼ì¸) - MCP ì—°ë™
â”‚   â””â”€â”€ GoogleAIService.ts      (267 ë¼ì¸) - Google AI ì—°ë™
â””â”€â”€ lib/ml/
    â””â”€â”€ rag-engine.ts           (892 ë¼ì¸) - RAG ê²€ìƒ‰ ì—”ì§„

ì´ ë¼ì¸ ìˆ˜: 4,713 ë¼ì¸
í‰ê·  í’ˆì§ˆ: Aë“±ê¸‰ (85ì  ì´ìƒ)
í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€: 94% (18/19 í…ŒìŠ¤íŠ¸ í†µê³¼)
```

**ì´ ì½”ë“œë“¤ì€ ëª¨ë‘ ì‹¤ì œ ë™ì‘í•˜ë©°, í¬íŠ¸í´ë¦¬ì˜¤ë¡œì„œ ê¸°ìˆ ì  ìš°ìˆ˜ì„±ê³¼ ì‹¤ë¬´ ì—­ëŸ‰ì„ ì¦ëª…í•˜ëŠ” êµ¬ì²´ì  ê·¼ê±°ì…ë‹ˆë‹¤.**
