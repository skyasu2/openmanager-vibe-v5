# 🔧 OpenManager Vibe v5.44.2 시스템 관리 가이드

> **버전**: v5.44.2  
> **업데이트**: 2025년 6월 21일  
> **상태**: 완전 완성, 목업 시스템 통합, 프로덕션 준비 완료

---

## 🎯 시스템 관리 개요

### **관리 대상**

- **MCP 서버**: 6개 서버 (개발용 + 서비스용)
- **Google AI**: 할당량 보호 시스템
- **목업 시스템**: 자동 폴백 관리
- **성능 모니터링**: 실시간 지표 추적

### **핵심 특징**

- **자동 복구**: 3단계 폴백 시스템
- **할당량 보호**: Google AI API 절약 (95%)
- **목업 모드**: 외부 의존성 완전 제거
- **실시간 모니터링**: 24시간 무중단 감시

---

## 🤖 MCP (Model Context Protocol) 시스템

### **MCP 아키텍처**

#### **개발환경 (Cursor IDE)**

```typescript
// 6개 MCP 서버 (개발용)
const CURSOR_MCP_SERVERS = [
  'filesystem', 'brave_search', 'github',
  'postgres', 'sqlite', 'memory'
];

// cursor.mcp.json 설정
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["@modelcontextprotocol/server-filesystem", "/path/to/allowed"]
    },
    "brave_search": {
      "command": "npx",
      "args": ["@modelcontextprotocol/server-brave-search"],
      "env": { "BRAVE_API_KEY": "your-key" }
    }
  }
}
```

#### **서비스환경 (UnifiedAIEngine)**

```typescript
// RealMCPClient (서비스용)
class RealMCPClient {
  private servers = [
    'https://openmanager-vibe-v5.onrender.com', // 메인 서버
    'http://localhost:3001/api/mcp', // 로컬 폴백
  ];

  async sendRequest(request: MCPRequest): Promise<MCPResponse> {
    // 다중 서버 폴백 시스템
    for (const server of this.servers) {
      try {
        const response = await this.callMCPServer(server, request);
        return response;
      } catch (error) {
        console.warn(`MCP server ${server} failed:`, error);
        continue;
      }
    }

    // 최종 폴백: 목업 응답
    return this.generateMockMCPResponse(request);
  }
}
```

### **MCP 서버 관리**

#### **Render 서버 (메인)**

```bash
# 배포 정보
URL: https://openmanager-vibe-v5.onrender.com
Port: 10000
Status: 24시간 운영
Build: npm install
Start: node server.js
```

#### **로컬 서버 (폴백)**

```bash
# 로컬 MCP 서버 시작
cd mcp-server
npm install
npm start

# 포트 확인
curl http://localhost:3001/api/mcp/health
```

#### **헬스체크 시스템**

```typescript
class MCPHealthChecker {
  async checkAllServers(): Promise<MCPHealthStatus> {
    const results = await Promise.allSettled(
      this.servers.map(server => this.checkServer(server))
    );

    return {
      render: this.extractStatus(results[0]),
      local: this.extractStatus(results[1]),
      overall: this.calculateOverallHealth(results),
    };
  }

  private async checkServer(url: string): Promise<boolean> {
    try {
      const response = await fetch(`${url}/health`, {
        timeout: 3000,
        method: 'GET',
      });
      return response.ok;
    } catch (error) {
      return false;
    }
  }
}
```

---

## 🛡️ Google AI 할당량 보호 시스템

### **보호 메커니즘**

#### **1. 헬스체크 캐싱 (24시간)**

```typescript
class GoogleAIHealthCache {
  private cacheKey = 'google_ai_health_check';
  private cacheHours = 24; // 환경변수: GOOGLE_AI_HEALTH_CHECK_CACHE_HOURS

  async checkHealth(): Promise<boolean> {
    // 캐시된 결과 확인
    const cached = await this.getFromCache(this.cacheKey);
    if (cached && !this.isCacheExpired(cached)) {
      return cached.isHealthy;
    }

    // 실제 API 호출 (하루 1회만)
    const isHealthy = await this.performActualHealthCheck();

    // 24시간 캐싱
    await this.saveToCache(this.cacheKey, {
      isHealthy,
      timestamp: Date.now(),
      expiresAt: Date.now() + this.cacheHours * 60 * 60 * 1000,
    });

    return isHealthy;
  }
}
```

#### **2. 테스트 일일 제한 (5회)**

```typescript
class GoogleAITestLimiter {
  private dailyLimit = 5; // 환경변수: GOOGLE_AI_TEST_LIMIT_PER_DAY
  private testCountKey = 'google_ai_daily_test_count';

  async canRunTest(): Promise<boolean> {
    const today = new Date().toISOString().split('T')[0];
    const countKey = `${this.testCountKey}_${today}`;

    const currentCount = (await this.getCount(countKey)) || 0;

    if (currentCount >= this.dailyLimit) {
      console.warn(
        `Daily Google AI test limit reached: ${currentCount}/${this.dailyLimit}`
      );
      return false;
    }

    return true;
  }

  async incrementTestCount(): Promise<void> {
    const today = new Date().toISOString().split('T')[0];
    const countKey = `${this.testCountKey}_${today}`;

    const currentCount = (await this.getCount(countKey)) || 0;
    await this.setCount(countKey, currentCount + 1, 86400); // 24시간 TTL
  }
}
```

#### **3. Circuit Breaker 패턴**

```typescript
class GoogleAICircuitBreaker {
  private failureThreshold = 5; // 연속 실패 임계값
  private recoveryTimeout = 30 * 60 * 1000; // 30분 차단
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';

  async executeWithCircuitBreaker<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (this.shouldAttemptReset()) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error(
          'Circuit breaker is OPEN - Google AI temporarily unavailable'
        );
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onFailure(): void {
    this.failureCount++;

    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.lastFailureTime = Date.now();
      console.warn('Google AI Circuit Breaker OPENED - switching to mock mode');
    }
  }
}
```

### **목업 모드 통합**

#### **자동 목업 전환**

```typescript
class GoogleAIMockManager {
  detectMockMode(): boolean {
    return (
      this.isCircuitBreakerOpen() ||
      this.isQuotaExceeded() ||
      this.isHealthCheckFailed() ||
      process.env.FORCE_MOCK_GOOGLE_AI === 'true'
    );
  }

  async processWithMockFallback(
    request: GoogleAIRequest
  ): Promise<GoogleAIResponse> {
    if (this.detectMockMode()) {
      return this.generateMockResponse(request);
    }

    try {
      return await this.callRealGoogleAI(request);
    } catch (error) {
      // 실패 시 자동 목업 전환
      console.warn('Google AI failed, switching to mock mode:', error);
      return this.generateMockResponse(request);
    }
  }
}
```

### **할당량 모니터링**

#### **실시간 사용량 추적**

```typescript
class GoogleAIQuotaMonitor {
  private quotaLimits = {
    daily: 10000, // 일일 10,000개
    perMinute: 100, // 분당 100개
    perSecond: 2, // 초당 2개
  };

  async trackUsage(requestType: string): Promise<void> {
    const now = Date.now();
    const today = new Date().toISOString().split('T')[0];
    const currentMinute = Math.floor(now / 60000);
    const currentSecond = Math.floor(now / 1000);

    // 사용량 카운터 업데이트
    await Promise.all([
      this.incrementCounter(`daily_${today}`, 86400),
      this.incrementCounter(`minute_${currentMinute}`, 60),
      this.incrementCounter(`second_${currentSecond}`, 1),
    ]);

    // 임계값 확인
    await this.checkQuotaLimits();
  }

  private async checkQuotaLimits(): Promise<void> {
    const usage = await this.getCurrentUsage();

    if (usage.daily >= this.quotaLimits.daily * 0.9) {
      console.warn('Google AI daily quota 90% reached');
      await this.enableMockMode();
    }
  }
}
```

---

## 📊 실시간 모니터링 대시보드

### **관리자 페이지 (/admin/ai-agent)**

#### **MCP 서버 상태**

```typescript
interface MCPServerStatus {
  name: string;
  url: string;
  status: 'healthy' | 'degraded' | 'down';
  responseTime: number;
  lastCheck: string;
  errorCount: number;
}

// 실시간 상태 업데이트
const MCPStatusPanel = () => {
  const [servers, setServers] = useState<MCPServerStatus[]>([]);

  useEffect(() => {
    const interval = setInterval(async () => {
      const status = await fetch('/api/mcp/status').then(r => r.json());
      setServers(status.servers);
    }, 30000); // 30초마다 업데이트

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="mcp-status-grid">
      {servers.map(server => (
        <MCPServerCard key={server.name} server={server} />
      ))}
    </div>
  );
};
```

#### **Google AI 할당량 현황**

```typescript
interface GoogleAIQuotaStatus {
  daily: { used: number; limit: number; percentage: number };
  hourly: { used: number; limit: number; percentage: number };
  circuitBreakerState: 'CLOSED' | 'OPEN' | 'HALF_OPEN';
  mockModeActive: boolean;
  lastApiCall: string;
}

const GoogleAIQuotaPanel = () => {
  return (
    <div className="quota-dashboard">
      <QuotaProgressBar
        label="일일 사용량"
        used={quota.daily.used}
        limit={quota.daily.limit}
      />
      <CircuitBreakerStatus state={quota.circuitBreakerState} />
      <MockModeIndicator active={quota.mockModeActive} />
    </div>
  );
};
```

---

## 🔧 환경변수 관리

### **Google AI 설정**

```env
# Google AI API
GOOGLE_AI_API_KEY=your_api_key_here
GOOGLE_AI_ENABLED=true

# 할당량 보호
GOOGLE_AI_QUOTA_PROTECTION=true
GOOGLE_AI_TEST_LIMIT_PER_DAY=5
GOOGLE_AI_HEALTH_CHECK_CACHE_HOURS=24

# Circuit Breaker
GOOGLE_AI_FAILURE_THRESHOLD=5
GOOGLE_AI_RECOVERY_TIMEOUT_MINUTES=30

# 목업 모드 강제 활성화
FORCE_MOCK_GOOGLE_AI=false
```

### **MCP 설정**

```env
# MCP 서버
MCP_RENDER_URL=https://openmanager-vibe-v5.onrender.com
MCP_LOCAL_URL=http://localhost:3001/api/mcp
MCP_TIMEOUT_MS=3000

# 헬스체크
MCP_HEALTH_CHECK_INTERVAL=30000
MCP_MAX_RETRIES=2

# 목업 모드
FORCE_MOCK_MCP=false
```

---

## 🚨 장애 대응 가이드

### **MCP 서버 장애**

#### **1. Render 서버 다운**

```bash
# 상태 확인
curl https://openmanager-vibe-v5.onrender.com/health

# 로그 확인 (Render 대시보드)
# → Logs 탭에서 에러 확인

# 자동 복구 확인
# → 로컬 MCP 서버로 자동 폴백됨
```

#### **2. 로컬 서버 문제**

```bash
# 로컬 서버 재시작
cd mcp-server
npm run restart

# 포트 충돌 해결
lsof -ti:3001 | xargs kill -9
npm start
```

### **Google AI 할당량 초과**

#### **1. 일일 할당량 초과**

```typescript
// 자동 처리: 목업 모드로 전환
// 다음날 자동 복구
console.log('Google AI daily quota exceeded - switched to mock mode');
```

#### **2. Circuit Breaker 활성화**

```typescript
// 30분 후 자동 복구 시도
// 수동 리셋 가능
await circuitBreaker.manualReset();
```

### **전체 시스템 장애**

#### **목업 모드 강제 활성화**

```bash
# 환경변수 설정
export FORCE_MOCK_GOOGLE_AI=true
export FORCE_MOCK_MCP=true
export FORCE_MOCK_REDIS=true

# 애플리케이션 재시작
npm run dev
```

---

## 📈 성능 최적화

### **MCP 서버 최적화**

- **연결 풀링**: 최대 10개 동시 연결
- **요청 배치**: 여러 요청을 하나로 묶어 처리
- **캐싱**: 응답 결과 15분 캐싱

### **Google AI 최적화**

- **배치 처리**: 여러 질문을 하나의 요청으로 처리
- **응답 캐싱**: 동일 질문 1시간 캐싱
- **목업 우선**: 95% 할당량 절약

### **모니터링 최적화**

- **지연 로딩**: 필요할 때만 상태 확인
- **배치 업데이트**: 30초마다 일괄 업데이트
- **메모리 캐싱**: 자주 사용하는 데이터 메모리 보관

---

## 🎯 운영 체크리스트

### **일일 점검**

- [ ] MCP 서버 상태 확인
- [ ] Google AI 할당량 확인
- [ ] 목업 모드 비율 확인
- [ ] 에러 로그 검토

### **주간 점검**

- [ ] 성능 메트릭 분석
- [ ] Circuit Breaker 통계 확인
- [ ] 캐시 효율성 검토
- [ ] 문서 업데이트

### **월간 점검**

- [ ] 할당량 사용 패턴 분석
- [ ] 시스템 최적화 계획
- [ ] 백업 및 복구 테스트
- [ ] 보안 업데이트 적용

OpenManager Vibe v5.44.2의 시스템 관리는 **완전 자동화**되어 있어 최소한의 개입으로 안정적인 운영이 가능합니다! 🚀
