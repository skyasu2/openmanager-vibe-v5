# ğŸ”§ OpenManager Vibe v5.44.2 ì‹œìŠ¤í…œ ê´€ë¦¬ ê°€ì´ë“œ

> **ë²„ì „**: v5.44.2  
> **ì—…ë°ì´íŠ¸**: 2025ë…„ 6ì›” 21ì¼  
> **ìƒíƒœ**: ì™„ì „ ì™„ì„±, ëª©ì—… ì‹œìŠ¤í…œ í†µí•©, í”„ë¡œë•ì…˜ ì¤€ë¹„ ì™„ë£Œ

---

## ğŸ¯ ì‹œìŠ¤í…œ ê´€ë¦¬ ê°œìš”

### **ê´€ë¦¬ ëŒ€ìƒ**

- **MCP ì„œë²„**: 6ê°œ ì„œë²„ (ê°œë°œìš© + ì„œë¹„ìŠ¤ìš©)
- **Google AI**: í• ë‹¹ëŸ‰ ë³´í˜¸ ì‹œìŠ¤í…œ
- **ëª©ì—… ì‹œìŠ¤í…œ**: ìë™ í´ë°± ê´€ë¦¬
- **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ ì§€í‘œ ì¶”ì 

### **í•µì‹¬ íŠ¹ì§•**

- **ìë™ ë³µêµ¬**: 3ë‹¨ê³„ í´ë°± ì‹œìŠ¤í…œ
- **í• ë‹¹ëŸ‰ ë³´í˜¸**: Google AI API ì ˆì•½ (95%)
- **ëª©ì—… ëª¨ë“œ**: ì™¸ë¶€ ì˜ì¡´ì„± ì™„ì „ ì œê±°
- **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**: 24ì‹œê°„ ë¬´ì¤‘ë‹¨ ê°ì‹œ

---

## ğŸ¤– MCP (Model Context Protocol) ì‹œìŠ¤í…œ

### **MCP ì•„í‚¤í…ì²˜**

#### **ê°œë°œí™˜ê²½ (Cursor IDE)**

```typescript
// 6ê°œ MCP ì„œë²„ (ê°œë°œìš©)
const CURSOR_MCP_SERVERS = [
  'filesystem', 'brave_search', 'github',
  'postgres', 'sqlite', 'memory'
];

// cursor.mcp.json ì„¤ì •
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["@modelcontextprotocol/server-filesystem", "/path/to/allowed"]
    },
    "brave_search": {
      "command": "npx",
      "args": ["@modelcontextprotocol/server-brave-search"],
      "env": { "BRAVE_API_KEY": "your-key" }
    }
  }
}
```

#### **ì„œë¹„ìŠ¤í™˜ê²½ (UnifiedAIEngine)**

```typescript
// RealMCPClient (ì„œë¹„ìŠ¤ìš©)
class RealMCPClient {
  private servers = [
    'https://openmanager-vibe-v5.onrender.com', // ë©”ì¸ ì„œë²„
    'http://localhost:3001/api/mcp', // ë¡œì»¬ í´ë°±
  ];

  async sendRequest(request: MCPRequest): Promise<MCPResponse> {
    // ë‹¤ì¤‘ ì„œë²„ í´ë°± ì‹œìŠ¤í…œ
    for (const server of this.servers) {
      try {
        const response = await this.callMCPServer(server, request);
        return response;
      } catch (error) {
        console.warn(`MCP server ${server} failed:`, error);
        continue;
      }
    }

    // ìµœì¢… í´ë°±: ëª©ì—… ì‘ë‹µ
    return this.generateMockMCPResponse(request);
  }
}
```

### **MCP ì„œë²„ ê´€ë¦¬**

#### **Render ì„œë²„ (ë©”ì¸)**

```bash
# ë°°í¬ ì •ë³´
URL: https://openmanager-vibe-v5.onrender.com
Port: 10000
Status: 24ì‹œê°„ ìš´ì˜
Build: npm install
Start: node server.js
```

#### **ë¡œì»¬ ì„œë²„ (í´ë°±)**

```bash
# ë¡œì»¬ MCP ì„œë²„ ì‹œì‘
cd mcp-server
npm install
npm start

# í¬íŠ¸ í™•ì¸
curl http://localhost:3001/api/mcp/health
```

#### **í—¬ìŠ¤ì²´í¬ ì‹œìŠ¤í…œ**

```typescript
class MCPHealthChecker {
  async checkAllServers(): Promise<MCPHealthStatus> {
    const results = await Promise.allSettled(
      this.servers.map(server => this.checkServer(server))
    );

    return {
      render: this.extractStatus(results[0]),
      local: this.extractStatus(results[1]),
      overall: this.calculateOverallHealth(results),
    };
  }

  private async checkServer(url: string): Promise<boolean> {
    try {
      const response = await fetch(`${url}/health`, {
        timeout: 3000,
        method: 'GET',
      });
      return response.ok;
    } catch (error) {
      return false;
    }
  }
}
```

---

## ğŸ›¡ï¸ Google AI í• ë‹¹ëŸ‰ ë³´í˜¸ ì‹œìŠ¤í…œ

### **ë³´í˜¸ ë©”ì»¤ë‹ˆì¦˜**

#### **1. í—¬ìŠ¤ì²´í¬ ìºì‹± (24ì‹œê°„)**

```typescript
class GoogleAIHealthCache {
  private cacheKey = 'google_ai_health_check';
  private cacheHours = 24; // í™˜ê²½ë³€ìˆ˜: GOOGLE_AI_HEALTH_CHECK_CACHE_HOURS

  async checkHealth(): Promise<boolean> {
    // ìºì‹œëœ ê²°ê³¼ í™•ì¸
    const cached = await this.getFromCache(this.cacheKey);
    if (cached && !this.isCacheExpired(cached)) {
      return cached.isHealthy;
    }

    // ì‹¤ì œ API í˜¸ì¶œ (í•˜ë£¨ 1íšŒë§Œ)
    const isHealthy = await this.performActualHealthCheck();

    // 24ì‹œê°„ ìºì‹±
    await this.saveToCache(this.cacheKey, {
      isHealthy,
      timestamp: Date.now(),
      expiresAt: Date.now() + this.cacheHours * 60 * 60 * 1000,
    });

    return isHealthy;
  }
}
```

#### **2. í…ŒìŠ¤íŠ¸ ì¼ì¼ ì œí•œ (5íšŒ)**

```typescript
class GoogleAITestLimiter {
  private dailyLimit = 5; // í™˜ê²½ë³€ìˆ˜: GOOGLE_AI_TEST_LIMIT_PER_DAY
  private testCountKey = 'google_ai_daily_test_count';

  async canRunTest(): Promise<boolean> {
    const today = new Date().toISOString().split('T')[0];
    const countKey = `${this.testCountKey}_${today}`;

    const currentCount = (await this.getCount(countKey)) || 0;

    if (currentCount >= this.dailyLimit) {
      console.warn(
        `Daily Google AI test limit reached: ${currentCount}/${this.dailyLimit}`
      );
      return false;
    }

    return true;
  }

  async incrementTestCount(): Promise<void> {
    const today = new Date().toISOString().split('T')[0];
    const countKey = `${this.testCountKey}_${today}`;

    const currentCount = (await this.getCount(countKey)) || 0;
    await this.setCount(countKey, currentCount + 1, 86400); // 24ì‹œê°„ TTL
  }
}
```

#### **3. Circuit Breaker íŒ¨í„´**

```typescript
class GoogleAICircuitBreaker {
  private failureThreshold = 5; // ì—°ì† ì‹¤íŒ¨ ì„ê³„ê°’
  private recoveryTimeout = 30 * 60 * 1000; // 30ë¶„ ì°¨ë‹¨
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';

  async executeWithCircuitBreaker<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (this.shouldAttemptReset()) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error(
          'Circuit breaker is OPEN - Google AI temporarily unavailable'
        );
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onFailure(): void {
    this.failureCount++;

    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.lastFailureTime = Date.now();
      console.warn('Google AI Circuit Breaker OPENED - switching to mock mode');
    }
  }
}
```

### **ëª©ì—… ëª¨ë“œ í†µí•©**

#### **ìë™ ëª©ì—… ì „í™˜**

```typescript
class GoogleAIMockManager {
  detectMockMode(): boolean {
    return (
      this.isCircuitBreakerOpen() ||
      this.isQuotaExceeded() ||
      this.isHealthCheckFailed() ||
      process.env.FORCE_MOCK_GOOGLE_AI === 'true'
    );
  }

  async processWithMockFallback(
    request: GoogleAIRequest
  ): Promise<GoogleAIResponse> {
    if (this.detectMockMode()) {
      return this.generateMockResponse(request);
    }

    try {
      return await this.callRealGoogleAI(request);
    } catch (error) {
      // ì‹¤íŒ¨ ì‹œ ìë™ ëª©ì—… ì „í™˜
      console.warn('Google AI failed, switching to mock mode:', error);
      return this.generateMockResponse(request);
    }
  }
}
```

### **í• ë‹¹ëŸ‰ ëª¨ë‹ˆí„°ë§**

#### **ì‹¤ì‹œê°„ ì‚¬ìš©ëŸ‰ ì¶”ì **

```typescript
class GoogleAIQuotaMonitor {
  private quotaLimits = {
    daily: 10000, // ì¼ì¼ 10,000ê°œ
    perMinute: 100, // ë¶„ë‹¹ 100ê°œ
    perSecond: 2, // ì´ˆë‹¹ 2ê°œ
  };

  async trackUsage(requestType: string): Promise<void> {
    const now = Date.now();
    const today = new Date().toISOString().split('T')[0];
    const currentMinute = Math.floor(now / 60000);
    const currentSecond = Math.floor(now / 1000);

    // ì‚¬ìš©ëŸ‰ ì¹´ìš´í„° ì—…ë°ì´íŠ¸
    await Promise.all([
      this.incrementCounter(`daily_${today}`, 86400),
      this.incrementCounter(`minute_${currentMinute}`, 60),
      this.incrementCounter(`second_${currentSecond}`, 1),
    ]);

    // ì„ê³„ê°’ í™•ì¸
    await this.checkQuotaLimits();
  }

  private async checkQuotaLimits(): Promise<void> {
    const usage = await this.getCurrentUsage();

    if (usage.daily >= this.quotaLimits.daily * 0.9) {
      console.warn('Google AI daily quota 90% reached');
      await this.enableMockMode();
    }
  }
}
```

---

## ğŸ“Š ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

### **ê´€ë¦¬ì í˜ì´ì§€ (/admin/ai-agent)**

#### **MCP ì„œë²„ ìƒíƒœ**

```typescript
interface MCPServerStatus {
  name: string;
  url: string;
  status: 'healthy' | 'degraded' | 'down';
  responseTime: number;
  lastCheck: string;
  errorCount: number;
}

// ì‹¤ì‹œê°„ ìƒíƒœ ì—…ë°ì´íŠ¸
const MCPStatusPanel = () => {
  const [servers, setServers] = useState<MCPServerStatus[]>([]);

  useEffect(() => {
    const interval = setInterval(async () => {
      const status = await fetch('/api/mcp/status').then(r => r.json());
      setServers(status.servers);
    }, 30000); // 30ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="mcp-status-grid">
      {servers.map(server => (
        <MCPServerCard key={server.name} server={server} />
      ))}
    </div>
  );
};
```

#### **Google AI í• ë‹¹ëŸ‰ í˜„í™©**

```typescript
interface GoogleAIQuotaStatus {
  daily: { used: number; limit: number; percentage: number };
  hourly: { used: number; limit: number; percentage: number };
  circuitBreakerState: 'CLOSED' | 'OPEN' | 'HALF_OPEN';
  mockModeActive: boolean;
  lastApiCall: string;
}

const GoogleAIQuotaPanel = () => {
  return (
    <div className="quota-dashboard">
      <QuotaProgressBar
        label="ì¼ì¼ ì‚¬ìš©ëŸ‰"
        used={quota.daily.used}
        limit={quota.daily.limit}
      />
      <CircuitBreakerStatus state={quota.circuitBreakerState} />
      <MockModeIndicator active={quota.mockModeActive} />
    </div>
  );
};
```

---

## ğŸ”§ í™˜ê²½ë³€ìˆ˜ ê´€ë¦¬

### **Google AI ì„¤ì •**

```env
# Google AI API
GOOGLE_AI_API_KEY=your_api_key_here
GOOGLE_AI_ENABLED=true

# í• ë‹¹ëŸ‰ ë³´í˜¸
GOOGLE_AI_QUOTA_PROTECTION=true
GOOGLE_AI_TEST_LIMIT_PER_DAY=5
GOOGLE_AI_HEALTH_CHECK_CACHE_HOURS=24

# Circuit Breaker
GOOGLE_AI_FAILURE_THRESHOLD=5
GOOGLE_AI_RECOVERY_TIMEOUT_MINUTES=30

# ëª©ì—… ëª¨ë“œ ê°•ì œ í™œì„±í™”
FORCE_MOCK_GOOGLE_AI=false
```

### **MCP ì„¤ì •**

```env
# MCP ì„œë²„
MCP_RENDER_URL=https://openmanager-vibe-v5.onrender.com
MCP_LOCAL_URL=http://localhost:3001/api/mcp
MCP_TIMEOUT_MS=3000

# í—¬ìŠ¤ì²´í¬
MCP_HEALTH_CHECK_INTERVAL=30000
MCP_MAX_RETRIES=2

# ëª©ì—… ëª¨ë“œ
FORCE_MOCK_MCP=false
```

---

## ğŸš¨ ì¥ì•  ëŒ€ì‘ ê°€ì´ë“œ

### **MCP ì„œë²„ ì¥ì• **

#### **1. Render ì„œë²„ ë‹¤ìš´**

```bash
# ìƒíƒœ í™•ì¸
curl https://openmanager-vibe-v5.onrender.com/health

# ë¡œê·¸ í™•ì¸ (Render ëŒ€ì‹œë³´ë“œ)
# â†’ Logs íƒ­ì—ì„œ ì—ëŸ¬ í™•ì¸

# ìë™ ë³µêµ¬ í™•ì¸
# â†’ ë¡œì»¬ MCP ì„œë²„ë¡œ ìë™ í´ë°±ë¨
```

#### **2. ë¡œì»¬ ì„œë²„ ë¬¸ì œ**

```bash
# ë¡œì»¬ ì„œë²„ ì¬ì‹œì‘
cd mcp-server
npm run restart

# í¬íŠ¸ ì¶©ëŒ í•´ê²°
lsof -ti:3001 | xargs kill -9
npm start
```

### **Google AI í• ë‹¹ëŸ‰ ì´ˆê³¼**

#### **1. ì¼ì¼ í• ë‹¹ëŸ‰ ì´ˆê³¼**

```typescript
// ìë™ ì²˜ë¦¬: ëª©ì—… ëª¨ë“œë¡œ ì „í™˜
// ë‹¤ìŒë‚  ìë™ ë³µêµ¬
console.log('Google AI daily quota exceeded - switched to mock mode');
```

#### **2. Circuit Breaker í™œì„±í™”**

```typescript
// 30ë¶„ í›„ ìë™ ë³µêµ¬ ì‹œë„
// ìˆ˜ë™ ë¦¬ì…‹ ê°€ëŠ¥
await circuitBreaker.manualReset();
```

### **ì „ì²´ ì‹œìŠ¤í…œ ì¥ì• **

#### **ëª©ì—… ëª¨ë“œ ê°•ì œ í™œì„±í™”**

```bash
# í™˜ê²½ë³€ìˆ˜ ì„¤ì •
export FORCE_MOCK_GOOGLE_AI=true
export FORCE_MOCK_MCP=true
export FORCE_MOCK_REDIS=true

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì¬ì‹œì‘
npm run dev
```

---

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™”

### **MCP ì„œë²„ ìµœì í™”**

- **ì—°ê²° í’€ë§**: ìµœëŒ€ 10ê°œ ë™ì‹œ ì—°ê²°
- **ìš”ì²­ ë°°ì¹˜**: ì—¬ëŸ¬ ìš”ì²­ì„ í•˜ë‚˜ë¡œ ë¬¶ì–´ ì²˜ë¦¬
- **ìºì‹±**: ì‘ë‹µ ê²°ê³¼ 15ë¶„ ìºì‹±

### **Google AI ìµœì í™”**

- **ë°°ì¹˜ ì²˜ë¦¬**: ì—¬ëŸ¬ ì§ˆë¬¸ì„ í•˜ë‚˜ì˜ ìš”ì²­ìœ¼ë¡œ ì²˜ë¦¬
- **ì‘ë‹µ ìºì‹±**: ë™ì¼ ì§ˆë¬¸ 1ì‹œê°„ ìºì‹±
- **ëª©ì—… ìš°ì„ **: 95% í• ë‹¹ëŸ‰ ì ˆì•½

### **ëª¨ë‹ˆí„°ë§ ìµœì í™”**

- **ì§€ì—° ë¡œë”©**: í•„ìš”í•  ë•Œë§Œ ìƒíƒœ í™•ì¸
- **ë°°ì¹˜ ì—…ë°ì´íŠ¸**: 30ì´ˆë§ˆë‹¤ ì¼ê´„ ì—…ë°ì´íŠ¸
- **ë©”ëª¨ë¦¬ ìºì‹±**: ìì£¼ ì‚¬ìš©í•˜ëŠ” ë°ì´í„° ë©”ëª¨ë¦¬ ë³´ê´€

---

## ğŸ¯ ìš´ì˜ ì²´í¬ë¦¬ìŠ¤íŠ¸

### **ì¼ì¼ ì ê²€**

- [ ] MCP ì„œë²„ ìƒíƒœ í™•ì¸
- [ ] Google AI í• ë‹¹ëŸ‰ í™•ì¸
- [ ] ëª©ì—… ëª¨ë“œ ë¹„ìœ¨ í™•ì¸
- [ ] ì—ëŸ¬ ë¡œê·¸ ê²€í† 

### **ì£¼ê°„ ì ê²€**

- [ ] ì„±ëŠ¥ ë©”íŠ¸ë¦­ ë¶„ì„
- [ ] Circuit Breaker í†µê³„ í™•ì¸
- [ ] ìºì‹œ íš¨ìœ¨ì„± ê²€í† 
- [ ] ë¬¸ì„œ ì—…ë°ì´íŠ¸

### **ì›”ê°„ ì ê²€**

- [ ] í• ë‹¹ëŸ‰ ì‚¬ìš© íŒ¨í„´ ë¶„ì„
- [ ] ì‹œìŠ¤í…œ ìµœì í™” ê³„íš
- [ ] ë°±ì—… ë° ë³µêµ¬ í…ŒìŠ¤íŠ¸
- [ ] ë³´ì•ˆ ì—…ë°ì´íŠ¸ ì ìš©

OpenManager Vibe v5.44.2ì˜ ì‹œìŠ¤í…œ ê´€ë¦¬ëŠ” **ì™„ì „ ìë™í™”**ë˜ì–´ ìˆì–´ ìµœì†Œí•œì˜ ê°œì…ìœ¼ë¡œ ì•ˆì •ì ì¸ ìš´ì˜ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤! ğŸš€
