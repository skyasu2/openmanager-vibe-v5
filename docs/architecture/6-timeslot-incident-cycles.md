# 6개 시간대별 장애-해소 사이클 설계

## 🎯 설계 목표

**포트폴리오 시연 최적화**: 언제 접속해도 진행 중인 흥미로운 장애 시나리오와 해결 과정을 경험할 수 있는 동적 시스템

## ⏰ 6개 시간대 사이클 (4시간씩)

### 🌙 **시간대 1: 0-4시 - 백업 사이클**
```
0-2시: 야간 백업 시작
├── 장애: 전체 시스템 백업으로 디스크 I/O 급증
├── 영향: 응답시간 2-3배 증가, 디스크 사용률 80%+
├── 대상: backup-01, database-01, file-01 서버
└── 상태: 예상된 정기 작업

2-4시: 백업 완료 및 정상화
├── 해결: 백업 완료로 디스크 부하 감소
├── 결과: 응답시간 정상화, 시스템 안정화
└── 전환: 다음 사이클 준비 (유지보수)
```

### 🌅 **시간대 2: 4-8시 - 유지보수 사이클**
```
4-6시: 새벽 패치 및 재시작
├── 장애: 보안 패치 적용으로 일부 서버 재시작
├── 영향: CPU 스파이크, 일시적 서비스 중단
├── 대상: web-01, api-01, security-01 서버
└── 상태: 계획된 유지보수

6-8시: 패치 완료 및 성능 향상
├── 해결: 패치 적용 완료, 보안 강화
├── 결과: 시스템 성능 향상, 취약점 해결
└── 전환: 출근시간 트래픽 준비
```

### 🌞 **시간대 3: 8-12시 - 트래픽 폭증 사이클**
```
8-10시: 출근시간 트래픽 급증
├── 장애: 동시 접속자 폭증으로 웹서버 과부하
├── 영향: 로드밸런서 경고, 응답시간 지연
├── 대상: web-01, web-02, load_balancer-01
└── 상태: 예측 가능한 피크 시간

10-12시: 오토스케일링 작동
├── 해결: 자동 서버 추가, 트래픽 분산
├── 결과: 부하 분산 완료, 응답시간 정상화
└── 전환: 점심시간 데이터베이스 부하 준비
```

### 🍽️ **시간대 4: 12-16시 - 데이터베이스 사이클**
```
12-14시: 점심시간 주문 폭증
├── 장애: 주문 시스템 과부하로 DB 연결 포화
├── 영향: 슬로우 쿼리 증가, 데이터베이스 지연
├── 대상: database-01, api-01, cache-01
└── 상태: 비즈니스 피크 시간

14-16시: 쿼리 최적화 적용
├── 해결: 인덱스 재구성, 캐시 전략 개선
├── 결과: DB 성능 향상, 연결 풀 안정화
└── 전환: 퇴근시간 네트워크 부하 준비
```

### 🏃 **시간대 5: 16-20시 - 네트워크 포화 사이클**
```
16-18시: 퇴근시간 파일 다운로드
├── 장애: 대용량 파일 전송으로 네트워크 대역폭 포화
├── 영향: 전체 서비스 속도 저하, 타임아웃 증가
├── 대상: file-01, web-03, network 전반
└── 상태: 예상된 대역폭 병목

18-20시: 로드밸런싱 최적화
├── 해결: CDN 활성화, 트래픽 경로 최적화
├── 결과: 네트워크 부하 분산, 속도 개선
└── 전환: 저녁 배치작업 준비
```

### 🌆 **시간대 6: 20-24시 - 배치작업 사이클**
```
20-22시: 저녁 데이터 처리
├── 장애: 대량 배치작업으로 메모리 사용량 급증
├── 영향: 가비지 컬렉션 지연, 응답 불안정
├── 대상: api-02, database-02, monitoring-01
└── 상태: 정기 데이터 처리

22-24시: 메모리 정리 및 최적화
├── 해결: 배치작업 완료, 메모리 정리
├── 결과: 시스템 최적화, 다음 사이클 준비
└── 전환: 자정 백업 사이클 준비
```

## 📊 사이클별 특징

| 시간대 | 주요 장애 | 영향 서버 | 해결 방법 | AI 분석 포인트 |
|--------|-----------|-----------|-----------|----------------|
| **0-4시** | 디스크 I/O 과부하 | backup, db, file | 백업 완료 대기 | "정기 백업 진행 중" |
| **4-8시** | 서버 재시작/패치 | web, api, security | 패치 완료 대기 | "유지보수 진행 중" |
| **8-12시** | 트래픽 폭증 | web, load_balancer | 오토스케일링 | "출근시간 피크" |
| **12-16시** | DB 연결 포화 | database, api, cache | 쿼리 최적화 | "점심시간 주문 급증" |
| **16-20시** | 네트워크 병목 | file, web, network | CDN/로드밸런싱 | "퇴근시간 다운로드" |
| **20-24시** | 메모리 과사용 | api, db, monitoring | 배치작업 완료 | "저녁 데이터 처리" |

## 🎭 시연 시나리오 예시

### 📅 **오전 9시 접속 시**
```
사용자: "현재 서버 상태는?"
AI: "현재 출근시간 트래픽 폭증 상황입니다. 
웹서버 CPU가 85%로 높고, 로드밸런서에 경고가 있습니다.
약 1시간 후 오토스케일링이 완료되면 정상화될 예정입니다."

대시보드: [웹서버 빨간색, 높은 CPU 사용률 표시]
```

### 📅 **오후 1시 접속 시**  
```
사용자: "왜 응답이 느린가요?"
AI: "점심시간 주문 급증으로 데이터베이스 연결이 포화 상태입니다.
현재 슬로우 쿼리가 증가하고 있으며, 
오후 2시경 쿼리 최적화 작업으로 개선될 예정입니다."

대시보드: [데이터베이스 서버 주황색, 높은 메모리 사용률]
```

### 📅 **저녁 9시 접속 시**
```
사용자: "메모리 사용률이 높네요"
AI: "저녁 배치작업으로 대량 데이터 처리 중입니다.
현재 가비지 컬렉션이 지연되어 메모리 정리가 필요한 상황이며,
오후 10시경 배치작업 완료 후 메모리가 정리될 예정입니다."

대시보드: [API 서버들 높은 메모리 사용률, 배치작업 진행 중]
```

## 🔄 구현 원리

### 단계별 진행률 계산
```typescript
const getIncidentPhase = (timeSlot: number, progressInSlot: number) => {
  // 각 4시간을 5단계로 나눔
  if (progressInSlot < 0.2) return 'normal';      // 20% - 정상
  if (progressInSlot < 0.5) return 'incident';    // 30% - 장애 발생
  if (progressInSlot < 0.8) return 'peak';        // 30% - 장애 심화
  if (progressInSlot < 0.95) return 'resolving';  // 15% - 해결 중
  return 'resolved';                               // 5% - 해결 완료
};
```

### 메트릭 조정
```typescript
const applyIncidentEffect = (baseValue: number, phase: string, incidentType: string) => {
  const effects = {
    backup: { disk: +40, responseTime: +150 },
    maintenance: { cpu: +25, availability: -10 },
    traffic: { cpu: +30, network: +45 },
    database: { memory: +35, responseTime: +200 },
    network: { network: +50, responseTime: +100 },
    batch: { memory: +40, cpu: +20 }
  };
  
  return calculateAdjustedMetric(baseValue, effects[incidentType], phase);
};
```

## 💡 포트폴리오 시연 장점

### ✅ **언제나 흥미로운 상황**
- 새벽에 접속: "백업 진행 중" 
- 오전에 접속: "트래픽 급증으로 스케일링 중"
- 오후에 접속: "데이터베이스 최적화 진행 중"
- 저녁에 접속: "배치작업으로 메모리 정리 중"

### ✅ **AI 분석 풍부함**
- 현재 상황 정확한 진단
- 원인과 해결 방안 제시
- 해결 예상 시점 안내
- 이전 패턴과 비교 분석

### ✅ **30분 후 재방문 효과**
- 상황 변화 확인 가능
- "아, 정말로 해결되었네!" 경험
- 동적인 시스템임을 직관적으로 인식

### ✅ **실제 운영 환경 시뮬레이션**  
- 실제 발생하는 장애 패턴
- 현실적인 해결 과정
- 운영팀의 실제 업무 흐름

이 방식으로 구현하면 **완벽한 포트폴리오 시연 환경**이 됩니다! 🎉