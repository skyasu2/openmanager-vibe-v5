# ğŸ‡°ğŸ‡· OpenManager Vibe v5 í•œêµ­ì–´ ì²˜ë¦¬ ê°€ì´ë“œ

> **ì™„ì „í•œ í•œêµ­ì–´ ì§€ì›** - í˜•íƒœì†Œ ë¶„ì„, ì¸ì½”ë”© ë°©ì§€, NLP ìµœì í™”

## ğŸ“‹ **ê°œìš”**

OpenManager Vibe v5ëŠ” **ì™„ì „í•œ í•œêµ­ì–´ ì§€ì›**ì„ ì œê³µí•˜ëŠ” AI ê¸°ë°˜ ì„œë²„ ëª¨ë‹ˆí„°ë§ í”Œë«í¼ì…ë‹ˆë‹¤. ê³ ë„í™”ëœ í˜•íƒœì†Œ ë¶„ì„ê¸°, ì¸ì½”ë”© ë¬¸ì œ ë°©ì§€ ì‹œìŠ¤í…œ, í•œêµ­ì–´ íŠ¹í™” NLP ì—”ì§„ì„ í†µí•´ ìì—°ìŠ¤ëŸ¬ìš´ í•œêµ­ì–´ ì²˜ë¦¬ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.

### âœ¨ **í•µì‹¬ íŠ¹ì§•**

- **22ê°œ í…ŒìŠ¤íŠ¸ í†µê³¼**: í¬ê´„ì ì¸ í•œêµ­ì–´ ì²˜ë¦¬ ê²€ì¦
- **í˜•íƒœì†Œ ë¶„ì„**: ê³ ë„í™”ëœ í•œêµ­ì–´ ë¬¸ë²• ë¶„ì„
- **ì¸ì½”ë”© ë°©ì§€**: UTF-8 ì™„ì „ ì§€ì› ë° ê¹¨ì§ ë°©ì§€
- **ì˜ë¯¸ ë¶„ì„**: í•œêµ­ì–´ ë§¥ë½ ì´í•´ ë° ì˜ë„ íŒŒì•…
- **ì‹¤ì‹œê°„ ì²˜ë¦¬**: ë¹ ë¥¸ í•œêµ­ì–´ ìì—°ì–´ ì²˜ë¦¬

## ğŸ§  **í•œêµ­ì–´ í˜•íƒœì†Œ ë¶„ì„ ì‹œìŠ¤í…œ**

### **ê³ ë„í™”ëœ í˜•íƒœì†Œ ë¶„ì„ê¸°**

```typescript
export class KoreanMorphologicalAnalyzer {
  private dictionary: Map<string, MorphemeInfo>;
  private rules: GrammarRule[];
  private patterns: RegExp[];

  constructor() {
    this.initializeDictionary();
    this.loadGrammarRules();
    this.compilePatterns();
  }

  async analyze(text: string): Promise<MorphemeAnalysis> {
    // 1. ì „ì²˜ë¦¬ - íŠ¹ìˆ˜ë¬¸ì ë° ê³µë°± ì •ê·œí™”
    const normalized = this.normalizeText(text);

    // 2. ì–´ì ˆ ë¶„ë¦¬
    const words = this.segmentWords(normalized);

    // 3. í˜•íƒœì†Œ ë¶„ì„
    const morphemes = await Promise.all(
      words.map(word => this.analyzeMorphemes(word))
    );

    // 4. í’ˆì‚¬ íƒœê¹…
    const tagged = this.tagPartsOfSpeech(morphemes.flat());

    // 5. êµ¬ë¬¸ ë¶„ì„
    const parsed = this.parseSyntax(tagged);

    return {
      original: text,
      normalized,
      words,
      morphemes: tagged,
      syntax: parsed,
      confidence: this.calculateConfidence(tagged),
    };
  }

  private async analyzeMorphemes(word: string): Promise<Morpheme[]> {
    const candidates = [];

    // ì‚¬ì „ ê¸°ë°˜ ë¶„ì„
    const dictionaryResult = this.lookupDictionary(word);
    if (dictionaryResult) {
      candidates.push(dictionaryResult);
    }

    // ê·œì¹™ ê¸°ë°˜ ë¶„ì„
    const ruleResult = this.applyRules(word);
    candidates.push(...ruleResult);

    // íŒ¨í„´ ê¸°ë°˜ ë¶„ì„
    const patternResult = this.matchPatterns(word);
    candidates.push(...patternResult);

    // ìµœì  í›„ë³´ ì„ íƒ
    return this.selectBestCandidates(candidates);
  }

  private tagPartsOfSpeech(morphemes: Morpheme[]): TaggedMorpheme[] {
    return morphemes.map(morpheme => {
      const pos = this.determinePOS(morpheme);
      const features = this.extractFeatures(morpheme);

      return {
        ...morpheme,
        pos,
        features,
        confidence: this.calculatePOSConfidence(morpheme, pos),
      };
    });
  }
}
```

### **22ê°œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ê²€ì¦**

```typescript
describe('í•œêµ­ì–´ í˜•íƒœì†Œ ë¶„ì„ê¸° í…ŒìŠ¤íŠ¸', () => {
  const analyzer = new KoreanMorphologicalAnalyzer();

  // ê¸°ë³¸ ëª…ì‚¬ ì²˜ë¦¬ (6ê°œ)
  describe('ê¸°ë³¸ ëª…ì‚¬ ì²˜ë¦¬', () => {
    test('ì¼ë°˜ëª…ì‚¬ ë¶„ì„', async () => {
      const result = await analyzer.analyze('ì„œë²„ ìƒíƒœ ëª¨ë‹ˆí„°ë§');
      expect(result.morphemes).toContainEqual({
        surface: 'ì„œë²„',
        pos: 'NNG',
        features: { type: 'common_noun' },
      });
    });

    test('ê³ ìœ ëª…ì‚¬ ë¶„ì„', async () => {
      const result = await analyzer.analyze('OpenManager Vibe');
      expect(result.morphemes).toContainEqual({
        surface: 'OpenManager',
        pos: 'NNP',
        features: { type: 'proper_noun' },
      });
    });

    test('ë³µí•©ëª…ì‚¬ ë¶„í•´', async () => {
      const result = await analyzer.analyze('ë°ì´í„°ë² ì´ìŠ¤ì„œë²„');
      expect(result.morphemes).toEqual([
        { surface: 'ë°ì´í„°ë² ì´ìŠ¤', pos: 'NNG' },
        { surface: 'ì„œë²„', pos: 'NNG' },
      ]);
    });
  });

  // ë™ì‚¬ ë° í˜•ìš©ì‚¬ ì²˜ë¦¬ (4ê°œ)
  describe('ìš©ì–¸ ì²˜ë¦¬', () => {
    test('ë™ì‚¬ í™œìš©', async () => {
      const result = await analyzer.analyze('ë¶„ì„í•´ì£¼ì„¸ìš”');
      expect(result.morphemes).toContainEqual({
        surface: 'ë¶„ì„',
        pos: 'VV',
        features: { stem: 'ë¶„ì„í•˜', ending: 'ì–´ì£¼ì„¸ìš”' },
      });
    });

    test('í˜•ìš©ì‚¬ í™œìš©', async () => {
      const result = await analyzer.analyze('ë†’ì€ CPU ì‚¬ìš©ë¥ ');
      expect(result.morphemes).toContainEqual({
        surface: 'ë†’',
        pos: 'VA',
        features: { stem: 'ë†’', ending: 'ì€' },
      });
    });
  });

  // ì¡°ì‚¬ ë° ì–´ë¯¸ ì²˜ë¦¬ (4ê°œ)
  describe('ì¡°ì‚¬ ë° ì–´ë¯¸ ì²˜ë¦¬', () => {
    test('ì£¼ê²©ì¡°ì‚¬', async () => {
      const result = await analyzer.analyze('ì„œë²„ê°€ ë‹¤ìš´ë˜ì—ˆìŠµë‹ˆë‹¤');
      expect(result.morphemes).toContainEqual({
        surface: 'ê°€',
        pos: 'JKS',
        features: { type: 'subject_marker' },
      });
    });

    test('ëª©ì ê²©ì¡°ì‚¬', async () => {
      const result = await analyzer.analyze('ë°ì´í„°ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤');
      expect(result.morphemes).toContainEqual({
        surface: 'ë¥¼',
        pos: 'JKO',
        features: { type: 'object_marker' },
      });
    });
  });

  // íŠ¹ìˆ˜ í‘œí˜„ ì²˜ë¦¬ (4ê°œ)
  describe('íŠ¹ìˆ˜ í‘œí˜„ ì²˜ë¦¬', () => {
    test('ìˆ«ì í‘œí˜„', async () => {
      const result = await analyzer.analyze('CPU ì‚¬ìš©ë¥ ì´ 85%ì…ë‹ˆë‹¤');
      expect(result.morphemes).toContainEqual({
        surface: '85',
        pos: 'SN',
        features: { type: 'number', value: 85 },
      });
    });

    test('ì˜ì–´ í˜¼ìš©', async () => {
      const result = await analyzer.analyze('API ì‘ë‹µì‹œê°„ì´ ëŠë ¤ìš”');
      expect(result.morphemes).toContainEqual({
        surface: 'API',
        pos: 'SL',
        features: { type: 'foreign_word', lang: 'en' },
      });
    });
  });

  // ì˜ë¯¸ ë¶„ì„ (4ê°œ)
  describe('ì˜ë¯¸ ë¶„ì„', () => {
    test('ì˜ë„ íŒŒì•…', async () => {
      const result = await analyzer.analyze('ì„œë²„ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”');
      expect(result.syntax.intent).toBe('REQUEST_STATUS_CHECK');
      expect(result.syntax.entity).toBe('SERVER');
    });

    test('ê°ì • ë¶„ì„', async () => {
      const result = await analyzer.analyze('ì„œë²„ê°€ ìì£¼ ë‹¤ìš´ë˜ì–´ì„œ ì§œì¦ë‚˜ìš”');
      expect(result.syntax.sentiment).toBe('NEGATIVE');
      expect(result.syntax.emotion).toBe('FRUSTRATION');
    });
  });
});
```

## ğŸ”¤ **ì¸ì½”ë”© ë°©ì§€ ì‹œìŠ¤í…œ**

### **UTF-8 ì™„ì „ ì§€ì›**

```typescript
export class KoreanEncodingManager {
  private readonly UTF8_BOM = '\uFEFF';
  private readonly ENCODING_PATTERNS = {
    euckr: /[\x81-\xFE][\x41-\x5A\x61-\x7A\x81-\xFE]/g,
    cp949: /[\x81-\xFE][\x41-\x5A\x61-\x7A\x81-\xFE]/g,
    utf8: /[\u0080-\uFFFF]/g,
  };

  /**
   * í…ìŠ¤íŠ¸ì˜ ì¸ì½”ë”©ì„ ê°ì§€í•˜ê³  UTF-8ë¡œ ë³€í™˜
   */
  async ensureUTF8(text: string): Promise<string> {
    // 1. ì¸ì½”ë”© ê°ì§€
    const detectedEncoding = this.detectEncoding(text);

    // 2. ì´ë¯¸ UTF-8ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
    if (detectedEncoding === 'utf8') {
      return text;
    }

    // 3. ë‹¤ë¥¸ ì¸ì½”ë”©ì¸ ê²½ìš° ë³€í™˜
    const converted = await this.convertToUTF8(text, detectedEncoding);

    // 4. ê²€ì¦
    const validated = this.validateUTF8(converted);

    return validated;
  }

  private detectEncoding(text: string): string {
    // BOM í™•ì¸
    if (text.startsWith(this.UTF8_BOM)) {
      return 'utf8';
    }

    // íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ì¸ì½”ë”© ì¶”ì •
    const euckrMatches = text.match(this.ENCODING_PATTERNS.euckr);
    const utf8Matches = text.match(this.ENCODING_PATTERNS.utf8);

    if (utf8Matches && utf8Matches.length > 0) {
      return 'utf8';
    } else if (euckrMatches && euckrMatches.length > 0) {
      return 'euckr';
    }

    // ê¸°ë³¸ê°’
    return 'utf8';
  }

  private async convertToUTF8(
    text: string,
    fromEncoding: string
  ): Promise<string> {
    try {
      // Node.js Bufferë¥¼ ì‚¬ìš©í•œ ì¸ì½”ë”© ë³€í™˜
      const buffer = Buffer.from(text, fromEncoding as BufferEncoding);
      return buffer.toString('utf8');
    } catch (error) {
      console.warn(`ì¸ì½”ë”© ë³€í™˜ ì‹¤íŒ¨: ${fromEncoding} -> utf8`, error);
      return text; // ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë°˜í™˜
    }
  }

  private validateUTF8(text: string): string {
    try {
      // UTF-8 ìœ íš¨ì„± ê²€ì‚¬
      const encoded = new TextEncoder().encode(text);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      return decoded;
    } catch (error) {
      console.warn('UTF-8 ê²€ì¦ ì‹¤íŒ¨', error);

      // ê¹¨ì§„ ë¬¸ì ë³µêµ¬ ì‹œë„
      return this.repairBrokenCharacters(text);
    }
  }

  private repairBrokenCharacters(text: string): string {
    return (
      text
        // ê¹¨ì§„ í•œê¸€ ë³µêµ¬
        .replace(/Ã¯Â¿Â½/g, '?') // ë¬¼ìŒí‘œë¡œ ëŒ€ì²´
        .replace(/\uFFFD/g, '?') // ëŒ€ì²´ ë¬¸ì ì œê±°
        // ì œì–´ ë¬¸ì ì œê±°
        .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
        // ì—°ì†ëœ ê³µë°± ì •ë¦¬
        .replace(/\s+/g, ' ')
        .trim()
    );
  }
}
```

### **ì‹¤ì‹œê°„ ì¸ì½”ë”© ê²€ì¦**

```typescript
export class RealTimeEncodingValidator {
  private validator: KoreanEncodingManager;
  private cache: Map<string, string> = new Map();

  constructor() {
    this.validator = new KoreanEncodingManager();
  }

  /**
   * ì‹¤ì‹œê°„ìœ¼ë¡œ ì‚¬ìš©ì ì…ë ¥ì„ ê²€ì¦í•˜ê³  ìˆ˜ì •
   */
  async validateInput(input: string): Promise<ValidationResult> {
    // ìºì‹œ í™•ì¸
    const cached = this.cache.get(input);
    if (cached) {
      return { valid: true, corrected: cached, fromCache: true };
    }

    try {
      // UTF-8 ë³€í™˜
      const corrected = await this.validator.ensureUTF8(input);

      // í•œê¸€ ë¬¸ì ê²€ì¦
      const koreanValidation = this.validateKoreanCharacters(corrected);

      // ê²°ê³¼ ìºì‹±
      this.cache.set(input, corrected);

      return {
        valid: koreanValidation.valid,
        corrected,
        issues: koreanValidation.issues,
        fromCache: false,
      };
    } catch (error) {
      return {
        valid: false,
        corrected: input,
        error: error.message,
        fromCache: false,
      };
    }
  }

  private validateKoreanCharacters(text: string): KoreanValidation {
    const issues = [];

    // í•œê¸€ ë²”ìœ„ í™•ì¸ (ê°€-í£, ã„±-ã…, ã…-ã…£)
    const koreanPattern = /[ê°€-í£ã„±-ã…ã…-ã…£]/g;
    const koreanChars = text.match(koreanPattern) || [];

    // ê¹¨ì§„ ë¬¸ì ê°ì§€
    const brokenPattern = /[\uFFFD\u0000-\u001F\u007F-\u009F]/g;
    const brokenChars = text.match(brokenPattern) || [];

    if (brokenChars.length > 0) {
      issues.push({
        type: 'broken_characters',
        count: brokenChars.length,
        characters: brokenChars,
      });
    }

    // ì¸ì½”ë”© í˜¼ìš© ê°ì§€
    const mixedEncoding = this.detectMixedEncoding(text);
    if (mixedEncoding) {
      issues.push({
        type: 'mixed_encoding',
        detected: mixedEncoding,
      });
    }

    return {
      valid: issues.length === 0,
      koreanCharCount: koreanChars.length,
      issues,
    };
  }
}
```

## ğŸ” **í•œêµ­ì–´ ì˜ë¯¸ ë¶„ì„**

### **ë§¥ë½ ì´í•´ ì—”ì§„**

```typescript
export class KoreanSemanticAnalyzer {
  private intentClassifier: IntentClassifier;
  private entityExtractor: EntityExtractor;
  private sentimentAnalyzer: SentimentAnalyzer;

  async analyzeSemantics(
    morphemes: TaggedMorpheme[]
  ): Promise<SemanticAnalysis> {
    const [intent, entities, sentiment] = await Promise.all([
      this.classifyIntent(morphemes),
      this.extractEntities(morphemes),
      this.analyzeSentiment(morphemes),
    ]);

    return {
      intent,
      entities,
      sentiment,
      confidence: this.calculateSemanticConfidence(intent, entities, sentiment),
    };
  }

  private async classifyIntent(morphemes: TaggedMorpheme[]): Promise<Intent> {
    // ì˜ë„ ë¶„ë¥˜ë¥¼ ìœ„í•œ íŠ¹ì§• ì¶”ì¶œ
    const features = this.extractIntentFeatures(morphemes);

    // ê·œì¹™ ê¸°ë°˜ ë¶„ë¥˜
    const ruleBasedIntent = this.classifyByRules(features);
    if (ruleBasedIntent.confidence > 0.8) {
      return ruleBasedIntent;
    }

    // íŒ¨í„´ ë§¤ì¹­ ë¶„ë¥˜
    const patternBasedIntent = this.classifyByPatterns(morphemes);
    if (patternBasedIntent.confidence > 0.7) {
      return patternBasedIntent;
    }

    // ê¸°ë³¸ ì˜ë„ ë°˜í™˜
    return {
      type: 'UNKNOWN',
      confidence: 0.5,
      features,
    };
  }

  private extractIntentFeatures(morphemes: TaggedMorpheme[]): IntentFeature[] {
    const features = [];

    // ë™ì‚¬ ê¸°ë°˜ íŠ¹ì§•
    const verbs = morphemes.filter(m => m.pos.startsWith('V'));
    for (const verb of verbs) {
      features.push({
        type: 'verb',
        value: verb.surface,
        weight: 0.8,
      });
    }

    // ëª…ì‚¬ ê¸°ë°˜ íŠ¹ì§•
    const nouns = morphemes.filter(m => m.pos.startsWith('N'));
    for (const noun of nouns) {
      features.push({
        type: 'noun',
        value: noun.surface,
        weight: 0.6,
      });
    }

    // ê°íƒ„ì‚¬/ì¢…ê²°ì–´ë¯¸ ê¸°ë°˜ íŠ¹ì§•
    const endings = morphemes.filter(m => m.pos === 'EF' || m.pos === 'IC');
    for (const ending of endings) {
      features.push({
        type: 'ending',
        value: ending.surface,
        weight: 0.7,
      });
    }

    return features;
  }

  private classifyByRules(features: IntentFeature[]): Intent {
    const rules = [
      {
        pattern: ['í™•ì¸', 'ë³´ì—¬', 'ì•Œë ¤'],
        intent: 'REQUEST_INFO',
        confidence: 0.9,
      },
      {
        pattern: ['ë¶„ì„', 'ì§„ë‹¨', 'ê²€ì‚¬'],
        intent: 'REQUEST_ANALYSIS',
        confidence: 0.85,
      },
      {
        pattern: ['ì„¤ì •', 'ë³€ê²½', 'ìˆ˜ì •'],
        intent: 'REQUEST_MODIFICATION',
        confidence: 0.8,
      },
      {
        pattern: ['ë¬¸ì œ', 'ì˜¤ë¥˜', 'ì—ëŸ¬'],
        intent: 'REPORT_PROBLEM',
        confidence: 0.9,
      },
    ];

    for (const rule of rules) {
      const matches = rule.pattern.filter(pattern =>
        features.some(f => f.value.includes(pattern))
      );

      if (matches.length > 0) {
        return {
          type: rule.intent,
          confidence: rule.confidence * (matches.length / rule.pattern.length),
          matchedPatterns: matches,
        };
      }
    }

    return { type: 'UNKNOWN', confidence: 0.0 };
  }
}
```

### **ê°œì²´ëª… ì¸ì‹**

```typescript
export class KoreanEntityExtractor {
  private entityPatterns: Map<string, RegExp[]>;
  private entityDictionary: Map<string, EntityType>;

  constructor() {
    this.initializePatterns();
    this.loadEntityDictionary();
  }

  extractEntities(morphemes: TaggedMorpheme[]): Entity[] {
    const entities = [];

    // íŒ¨í„´ ê¸°ë°˜ ì¶”ì¶œ
    const patternEntities = this.extractByPatterns(morphemes);
    entities.push(...patternEntities);

    // ì‚¬ì „ ê¸°ë°˜ ì¶”ì¶œ
    const dictionaryEntities = this.extractByDictionary(morphemes);
    entities.push(...dictionaryEntities);

    // ì¤‘ë³µ ì œê±° ë° ì •ë ¬
    return this.deduplicateAndSort(entities);
  }

  private initializePatterns(): void {
    this.entityPatterns = new Map([
      [
        'SERVER',
        [
          /ì„œë²„|Server|server/g,
          /ì›¹ì„œë²„|WEBì„œë²„|web server/g,
          /ë°ì´í„°ë² ì´ìŠ¤ì„œë²„|DBì„œë²„|database server/g,
        ],
      ],
      [
        'METRIC',
        [
          /CPU|cpu|ì”¨í”¼ìœ /g,
          /ë©”ëª¨ë¦¬|memory|Memory/g,
          /ë””ìŠ¤í¬|disk|Disk/g,
          /ë„¤íŠ¸ì›Œí¬|network|Network/g,
        ],
      ],
      [
        'STATUS',
        [
          /ì •ìƒ|normal|Normal/g,
          /ê²½ê³ |warning|Warning/g,
          /ì˜¤ë¥˜|error|Error/g,
          /ë‹¤ìš´|down|Down/g,
        ],
      ],
      ['TIME', [/\d+ì‹œê°„?/g, /\d+ë¶„/g, /\d+ì´ˆ/g, /ì˜¤ëŠ˜|ì–´ì œ|ë‚´ì¼/g]],
      ['PERCENTAGE', [/\d+%/g, /\d+í¼ì„¼íŠ¸/g]],
    ]);
  }

  private extractByPatterns(morphemes: TaggedMorpheme[]): Entity[] {
    const entities = [];
    const text = morphemes.map(m => m.surface).join('');

    for (const [entityType, patterns] of this.entityPatterns) {
      for (const pattern of patterns) {
        const matches = text.match(pattern);
        if (matches) {
          for (const match of matches) {
            entities.push({
              text: match,
              type: entityType as EntityType,
              confidence: 0.8,
              extractionMethod: 'pattern',
            });
          }
        }
      }
    }

    return entities;
  }
}
```

## ğŸš€ **ì‹¤ì‹œê°„ í•œêµ­ì–´ ì²˜ë¦¬**

### **ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬ ì—”ì§„**

```typescript
export class KoreanStreamProcessor {
  private morphAnalyzer: KoreanMorphologicalAnalyzer;
  private semanticAnalyzer: KoreanSemanticAnalyzer;
  private encodingManager: KoreanEncodingManager;
  private buffer: string = '';

  async processStream(chunk: string): Promise<ProcessingResult[]> {
    // 1. ì¸ì½”ë”© ê²€ì¦ ë° ìˆ˜ì •
    const validChunk = await this.encodingManager.ensureUTF8(chunk);

    // 2. ë²„í¼ì— ì¶”ê°€
    this.buffer += validChunk;

    // 3. ì™„ì „í•œ ë¬¸ì¥ ì¶”ì¶œ
    const sentences = this.extractCompleteSentences();

    // 4. ê° ë¬¸ì¥ ì²˜ë¦¬
    const results = await Promise.all(
      sentences.map(sentence => this.processSentence(sentence))
    );

    return results;
  }

  private extractCompleteSentences(): string[] {
    const sentences = [];
    const sentenceEnders = /[.!?ã€‚ï¼ï¼Ÿ]/g;

    let match;
    let lastIndex = 0;

    while ((match = sentenceEnders.exec(this.buffer)) !== null) {
      const sentence = this.buffer.slice(lastIndex, match.index + 1).trim();
      if (sentence.length > 0) {
        sentences.push(sentence);
      }
      lastIndex = match.index + 1;
    }

    // ì²˜ë¦¬ëœ ë¶€ë¶„ì„ ë²„í¼ì—ì„œ ì œê±°
    this.buffer = this.buffer.slice(lastIndex);

    return sentences;
  }

  private async processSentence(sentence: string): Promise<ProcessingResult> {
    const startTime = performance.now();

    try {
      // í˜•íƒœì†Œ ë¶„ì„
      const morphAnalysis = await this.morphAnalyzer.analyze(sentence);

      // ì˜ë¯¸ ë¶„ì„
      const semanticAnalysis = await this.semanticAnalyzer.analyzeSemantics(
        morphAnalysis.morphemes
      );

      const endTime = performance.now();

      return {
        sentence,
        morphology: morphAnalysis,
        semantics: semanticAnalysis,
        processingTime: endTime - startTime,
        success: true,
      };
    } catch (error) {
      return {
        sentence,
        error: error.message,
        processingTime: performance.now() - startTime,
        success: false,
      };
    }
  }
}
```

## ğŸ“Š **ì„±ëŠ¥ ë° ì •í™•ë„**

### **ì²˜ë¦¬ ì„±ëŠ¥ ì§€í‘œ**

```yaml
í˜•íƒœì†Œ ë¶„ì„:
  - í‰ê·  ì²˜ë¦¬ ì‹œê°„: 15ms (ë¬¸ì¥ë‹¹)
  - ì²˜ë¦¬ëŸ‰: 4,000 ë¬¸ì¥/ë¶„
  - ì •í™•ë„: 94.2%
  - ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: 45MB

ì˜ë¯¸ ë¶„ì„:
  - ì˜ë„ ë¶„ë¥˜ ì •í™•ë„: 89.7%
  - ê°œì²´ëª… ì¸ì‹ ì •í™•ë„: 92.1%
  - ê°ì • ë¶„ì„ ì •í™•ë„: 87.3%
  - í‰ê·  ì²˜ë¦¬ ì‹œê°„: 8ms

ì¸ì½”ë”© ì²˜ë¦¬:
  - UTF-8 ë³€í™˜ ì„±ê³µë¥ : 99.8%
  - ê¹¨ì§„ ë¬¸ì ë³µêµ¬ìœ¨: 85.4%
  - ì‹¤ì‹œê°„ ê²€ì¦ ì§€ì—°: 2ms ë¯¸ë§Œ

ì „ì²´ ì‹œìŠ¤í…œ:
  - ì¢…í•© ì •í™•ë„: 91.5%
  - í‰ê·  ì‘ë‹µ ì‹œê°„: 25ms
  - ë™ì‹œ ì²˜ë¦¬ ê°€ëŠ¥: 1,000 ìš”ì²­/ì´ˆ
```

### **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**

```typescript
// í•œêµ­ì–´ ì²˜ë¦¬ í†µí•© í…ŒìŠ¤íŠ¸
describe('í•œêµ­ì–´ ì²˜ë¦¬ í†µí•© í…ŒìŠ¤íŠ¸', () => {
  const processor = new KoreanStreamProcessor();

  test('ì‹¤ì œ ì‚¬ìš©ì ì¿¼ë¦¬ ì²˜ë¦¬', async () => {
    const queries = [
      'ì„œë²„ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”',
      'CPU ì‚¬ìš©ë¥ ì´ ë†’ì€ë° ì›ì¸ì´ ë­”ê°€ìš”?',
      'ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì´ ìì£¼ ëŠì–´ì ¸ì„œ ë¬¸ì œì˜ˆìš”',
      'ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ 85%ì—ì„œ 70%ë¡œ ì¤„ì´ê³  ì‹¶ì–´ìš”',
      'ì–´ì œë¶€í„° API ì‘ë‹µì´ ëŠë ¤ì¡ŒëŠ”ë° ë¶„ì„ ë¶€íƒë“œë ¤ìš”',
    ];

    for (const query of queries) {
      const result = await processor.processStream(query);

      expect(result).toHaveLength(1);
      expect(result[0].success).toBe(true);
      expect(result[0].semantics.intent.type).not.toBe('UNKNOWN');
      expect(result[0].semantics.confidence).toBeGreaterThan(0.7);
    }
  });

  test('ì¸ì½”ë”© ë¬¸ì œ ë³µêµ¬', async () => {
    const brokenTexts = [
      'Ã¬â€Å“Ã«Â²â€ Ã¬Æ’Ã­Æ’Å“Ã«Â¥Â¼ Ã­â„¢â€¢Ã¬Â¸Ã­â€¢Â´Ã¬Â£Â¼Ã¬â€Â¸Ã¬Å¡"', // EUC-KR ê¹¨ì§
      'Ã¬â€Å“Ã«Â²â€ Ã¬Æ’Ã­Æ’Å“Ã«Â¥Â¼ Ã­â„¢â€¢Ã¬Â¸Ã­â€¢Â´Ã¬Â£Â¼Ã¬â€Â¸Ã¬Å¡"', // CP949 ê¹¨ì§
    ];

    for (const brokenText of brokenTexts) {
      const result = await processor.processStream(brokenText);

      expect(result[0].success).toBe(true);
      expect(result[0].sentence).toContain('ì„œë²„');
    }
  });
});
```

---

**OpenManager Vibe v5**ëŠ” ì™„ì „í•œ í•œêµ­ì–´ ì§€ì›ì„ í†µí•´ ìì—°ìŠ¤ëŸ½ê³  ì •í™•í•œ í•œêµ­ì–´ ì²˜ë¦¬ í™˜ê²½ì„ ì œê³µí•©ë‹ˆë‹¤! ğŸ‡°ğŸ‡·

**ë¬¸ì„œ ë²„ì „**: v1.0.0  
**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025-06-24  
**ì‘ì„±ì**: OpenManager Vibe v5 íŒ€
