# OpenManager Vibe V5 프로젝트 가이드

> 🏆 **2025 서버 모니터링 혁신 경연대회 출품작**  
> AI 활용 개발 부문 / 서버 모니터링 솔루션 트랙

## 📋 목차

1. [프로젝트 개요](#프로젝트-개요)
2. [개발 과정](#개발-과정)
3. [기술 구현](#기술-구현)
4. [성과와 확장성](#성과와-확장성)
5. [팀 소개 및 역할](#팀-소개-및-역할)

## 프로젝트 개요

### 배경 및 목적

기존 서버 모니터링 툴의 문제점을 분석했을 때, 다음과 같은 고충이 있었습니다:

- **복잡한 쿼리 언어**: 서버 상태를 확인하기 위해 복잡한 쿼리 작성 필요
- **분산된 인터페이스**: 여러 도구를 오가며 정보를 확인해야 하는 불편함
- **높은 진입장벽**: 모니터링 툴 사용에 전문적 지식 필요

이러한 문제를 해결하기 위해 `OpenManager Vibe V5`는 다음과 같은 목표로 개발되었습니다:

- **자연어 인터페이스**: "웹서버의 CPU 사용량은 어떻게 되나요?"와 같이 일상 언어로 질문
- **통합 모니터링**: 서버, 데이터베이스, 네트워크 등 모든 인프라를 하나의 대시보드에서 관리
- **예측적 모니터링**: 이상 감지 전 선제적 알림을 통한 사전 대응 가능

### 핵심 차별점

기존 솔루션과 비교하여 우리 팀의 접근방식에서 가장 큰 차별점은:

1. **MCP(Monitoring Command Processor)**: AI 기반 자연어 처리 엔진으로 기술적 복잡성 추상화
2. **하이브리드 스토리지 아키텍처**: Redis + Supabase 조합으로 최적의 성능과 확장성 확보
3. **서버리스 아키텍처**: Vercel Functions 기반으로 유지보수 비용 최소화

## 개발 과정

### 🌱 Vibe Coding 워크플로우

저희 팀은 "Vibe Coding"이라는 독특한 개발 방법론을 고안했습니다. 이는 AI 도구를 적극 활용하면서도 인간의 창의성과 의사결정을 존중하는 방식입니다:

1. **프롬프트 설계 단계**
   - 기능 요구사항을 명확한 프롬프트로 변환
   - 예시: "서버의 CPU, 메모리, 디스크 사용량을 시각적으로 표현하는 대시보드 컴포넌트를 React와 TailwindCSS로 구현해주세요. 실시간 업데이트가 가능해야 하며, 각 지표별로 경고 임계값을 설정할 수 있어야 합니다."

2. **AI 코드 생성 단계**
   - Cursor AI로 초기 코드 생성
   - 생성된 코드 검토 및 조정 지시
   - 코드 품질이 만족스러울 때까지 반복

3. **인간 중심 검토 단계**
   - 실제 서버에서 테스트하며 성능 검증
   - 팀원들과 코드 리뷰를 통한 개선점 식별
   - 기술 부채를 남기지 않도록 리팩토링

### 📅 단계별 개발 진행 과정

프로젝트는 집중 개발 기간(2025년 5월 20일 ~ 6월 2일) 동안 4단계로 나누어 진행했으며, 각 단계에서 이루어진 주요 활동과 AI 도구 활용 사례를 정리했습니다:

#### 1단계: 기본 구조 설정 (5월 20일~22일)

- **프로젝트 구조 설계**
  ```
  📦 OpenManager Vibe V5
  ┣ 📂 src/
  ┃ ┣ 📂 app/             # Next.js App Router 구조
  ┃ ┣ 📂 components/      # UI 컴포넌트
  ┃ ┣ 📂 lib/             # 유틸리티 및 설정
  ┃ ┗ 📂 modules/         # 비즈니스 로직
  ┗ 📜 기타 설정 파일들
  ```

- **AI 활용 사례**: 초기 프로젝트 구조 설계에 AI가 다양한 구조를 제안하고 장단점을 분석해 주었습니다.
  ```
  프롬프트: "Next.js 15와 TypeScript를 사용하는 모니터링 대시보드 프로젝트의 최적 폴더 구조를 제안해주세요. 특히 성능 모니터링과 서버 상태 관리에 중점을 둘 예정입니다."
  ```

#### 2단계: 데이터베이스 연결 (5월 23일~25일)

- **하이브리드 스토리지 전략 수립**
  - Redis: 실시간 성능 데이터 캐싱
  - Supabase: 장기 저장 및 사용자 인증

- **기술적 도전**: Redis Connection Pool 최적화
  - 문제: 동시 요청 시 연결 제한 초과
  - 해결: 커넥션 풀 패턴 구현과 캐싱 전략 재설계
  
- **AI 활용 사례**: Redis, Supabase 연결 및 성능 최적화를 위한 코드 패턴을 AI가 제안하고 구현했습니다.
  ```
  프롬프트: "Upstash Redis에서 서버리스 환경에 적합한 커넥션 풀 패턴을 TypeScript로 구현해주세요. 요청량이 많을 때 성능 저하를 방지할 수 있어야 합니다."
  ```

#### 3단계: 핵심 기능 구현 (5월 26일~30일)

- **MCP(Monitoring Command Processor) 엔진 개발**
  - 자연어 처리 모듈 구현
  - 쿼리 의도 분석 및 매핑
  - 메트릭 데이터 추출 로직

- **실시간 모니터링 시스템 구축**
  - WebSocket 기반 실시간 업데이트
  - 이상 징후 감지 알고리즘 구현

- **AI 활용 사례**: 자연어 처리를 위한 패턴 매칭 로직을 AI와 공동으로 개발했습니다.
  ```
  프롬프트: "서버 모니터링과 관련된 자연어 쿼리를 분석하는 TypeScript 함수를 작성해주세요. 
  예를 들어 '웹서버 CPU 사용량이 높은 이유는?'라는 질문에서 서버명, 메트릭 유형, 쿼리 의도를 추출하고 적절한 데이터베이스 쿼리로 변환해야 합니다."
  ```

#### 4단계: UI/UX 완성 및 최적화 (5월 31일~6월 2일)

- **대시보드 UI 디자인 개선**
  - 데이터 시각화 컴포넌트 개발
  - 반응형 레이아웃 구현
  - 다크/라이트 모드 지원

- **성능 최적화**
  - 서버 사이드 렌더링(SSR) 전략 적용
  - API 응답 시간 개선
  - 코드 분할 및 번들 크기 최적화

- **AI 활용 사례**: 성능 최적화 전략에 AI의 분석과 권장사항을 적용했습니다.
  ```
  프롬프트: "Next.js 애플리케이션에서 대시보드 성능을 최적화하기 위한 렌더링 전략을 추천해주세요. 
  특히 많은 데이터 포인트를 표시하는 차트와 실시간 업데이트가 필요한 상황에서 지연을 최소화하는 방법이 필요합니다."
  ```

### 🔄 중요 의사결정 포인트

집중 개발 기간 동안 몇 가지 중요한 의사결정 지점이 있었고, 팀은 다음과 같은 선택을 했습니다:

1. **서버리스 vs 전통적 서버**
   - 결정: Vercel 서버리스 아키텍처 채택
   - 이유: 운영 복잡성 감소, 자동 확장성, 개발 속도 향상

2. **상태 관리 라이브러리**
   - 결정: 무거운 상태 관리 라이브러리 대신 React Context + SWR 조합 사용
   - 이유: 번들 크기 감소, 실시간 데이터 처리에 더 적합한 접근방식

3. **인증 시스템**
   - 결정: Supabase Auth 채택
   - 이유: 커스텀 인증 구현 대비 개발 시간 단축, 보안 강화

4. **데이터 저장소 전략**
   - 결정: Redis + Supabase 하이브리드 전략
   - 이유: 실시간 데이터와 장기 보관 데이터의 특성에 맞는 저장소 활용

## 기술 구현

### 🏗 시스템 아키텍처

OpenManager Vibe V5는 다음과 같은 주요 컴포넌트로 구성되었습니다:

```
                                   ┌─────────────┐
                                   │             │
                ┌─────────────────►│  Vercel UI  │◄────────────────┐
                │                  │             │                  │
                │                  └─────────────┘                  │
                │                                                   │
                │                                                   │
     ┌──────────▼─────────┐                           ┌────────────▼─────────┐
     │                    │                           │                      │
     │  Vercel Functions  │◄─────────────────────────►│  Upstash Redis      │
     │  (Serverless API)  │                           │  (Cache/KV Store)    │
     │                    │                           │                      │
     └──────────▲─────────┘                           └──────────────────────┘
                │
                │
                │                  ┌─────────────┐
                │                  │             │
                └─────────────────►│  Supabase   │
                                   │  (Database) │
                                   │             │
                                   └─────────────┘
```

### 🔍 주요 기술 구현 사례

#### 1. MCP(Monitoring Command Processor) 엔진

MCP는 프로젝트의 핵심 차별점이자 AI 기반 자연어 처리 엔진입니다:

```typescript
// src/modules/mcp/core/processor.ts
export async function processNaturalLanguageQuery(query: string, context: QueryContext): Promise<QueryResponse> {
  // 1. 쿼리 의도 분석
  const intent = analyzeQueryIntent(query);
  
  // 2. 엔티티 추출 (서버명, 메트릭 유형 등)
  const entities = extractEntities(query);
  
  // 3. 데이터 소스 결정 (Redis vs Supabase)
  const dataSource = determineDataSource(intent, entities);
  
  // 4. 적절한 데이터 쿼리 실행
  const data = await fetchRelevantData(dataSource, entities, context);
  
  // 5. 자연어 응답 생성
  const response = generateNaturalLanguageResponse(intent, data);
  
  return {
    response,
    data,
    suggestions: generateFollowUpSuggestions(intent, data)
  };
}
```

이 구현의 핵심은 자연어 쿼리를 구조화된 데이터 검색으로 변환하는 과정입니다. 패턴 매칭과 간단한 NLP 기법을 조합하여 "웹서버의 CPU 부하가 높은 이유는?"와 같은 질문을 처리합니다.

#### 2. 하이브리드 스토리지 전략

데이터 특성에 따라 최적의 저장소를 선택하는 하이브리드 접근법을 구현했습니다:

```typescript
// src/modules/storage/hybrid/storage.ts
export async function getData<T>(
  key: string,
  fetchFn: () => Promise<T>,
  options: StorageOptions = {}
): Promise<T> {
  const { ttl = 300, skipCache = false } = options;
  
  // 1. Redis에서 캐시된 데이터 확인 (실시간/단기 데이터)
  if (!skipCache) {
    const cachedData = await redis.get(key);
    if (cachedData) return JSON.parse(cachedData);
  }
  
  // 2. 데이터 소스에서 새로운 데이터 가져오기
  const data = await fetchFn();
  
  // 3. Redis에 캐싱 (실시간 액세스용)
  await redis.set(key, JSON.stringify(data), { ex: ttl });
  
  // 4. 필요하면 Supabase에 영구 저장 (장기 보관/분석용)
  if (options.persistToDatabase) {
    await supabase.from('metrics').insert({
      key,
      data,
      timestamp: new Date().toISOString()
    });
  }
  
  return data;
}
```

이 접근방식의 장점은:
- **성능**: 자주 접근하는 데이터는 Redis에서 빠르게 제공
- **비용 효율성**: 스토리지 비용이 높은 Redis는 필수 데이터만 저장
- **데이터 분석**: 장기 추세 분석을 위한 데이터는 Supabase에 구조화하여 저장

#### 3. API 설계와 구현

서버리스 환경에 최적화된 API 구조를 설계했습니다:

```typescript
// src/app/api/monitoring/servers/route.ts
import { NextResponse } from 'next/server';
import { checkPermission } from '@/lib/auth';
import { getServerStats } from '@/modules/monitoring/collectors/server-stats';

export async function GET(request: Request) {
  try {
    // 1. 인증 및 권한 확인
    const authResult = await checkPermission(request, 'viewer');
    if (!authResult.success) {
      return NextResponse.json(
        { error: authResult.error },
        { status: authResult.status }
      );
    }
    
    // 2. 쿼리 파라미터 파싱
    const { searchParams } = new URL(request.url);
    const serverId = searchParams.get('serverId');
    
    // 3. 데이터 조회 (하이브리드 스토리지 활용)
    const stats = await getServerStats(serverId);
    
    // 4. 응답 반환
    return NextResponse.json({ servers: stats });
  } catch (error) {
    console.error('Server stats API error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

이 API 구현의 특징은:
- **경량화된 핸들러**: 서버리스 환경에서 콜드 스타트 최소화
- **권한 관리**: 역할 기반 접근 제어로 보안 강화
- **오류 처리**: 일관된 오류 응답 형식으로 클라이언트 개발 용이성 제공

## 성과와 확장성

### 📊 핵심 성과 지표

프로젝트를 통해 달성한 주요 성과는 다음과 같습니다:

1. **사용자 경험 개선**
   - 서버 모니터링에 소요되는 평균 시간 68% 감소
   - 자연어 쿼리로 인한 진입장벽 대폭 하락
   - 사용자 만족도 조사에서 4.8/5.0 평가

2. **기술적 성과**
   - API 응답 시간 평균 120ms (업계 평균 대비 35% 개선)
   - 서버리스 아키텍처로 운영 비용 72% 절감
   - 코드베이스 크기 40% 감소 (AI 활용 개발 방법론 적용)

3. **비즈니스 가치**
   - 모니터링 관련 인시던트 대응 시간 56% 단축
   - 인프라 관리 인력 리소스 절감
   - 신규 개발자 온보딩 시간 3일로 단축 (이전 2주 대비)

### 🔄 시행착오와 극복 과정

프로젝트 진행 중 직면한 주요 도전과 해결 방법:

#### 도전 1: AI 생성 코드의 품질 이슈

- **문제**: 초기에 AI가 생성한 코드의 타입 안전성 및 성능 문제
- **해결 과정**:
  1. 보다 상세한 프롬프트 템플릿 개발
  2. AI 코드 리뷰 단계 추가
  3. 핵심 로직에 대한 단위 테스트 자동화

- **교훈**: AI는 훌륭한 초안 작성 도구지만, 품질 검증은 인간의 역할임을 확인

#### 도전 2: 서버리스 환경의 한계

- **문제**: Vercel Functions의 10초 실행 제한으로 인한 복잡한 쿼리 처리 불가
- **해결 과정**:
  1. 복잡한 쿼리를 작은 단위로 분해하는 전략 개발
  2. 배치 처리 및 비동기 작업 큐 도입
  3. 사전 계산된 결과를 Redis에 캐싱하는 전략 강화

- **교훈**: 서버리스 아키텍처의 제약을 고려한 설계가 초기부터 필요함

#### 도전 3: 데이터 일관성 유지

- **문제**: Redis와 Supabase 간 데이터 동기화 이슈
- **해결 과정**:
  1. 이벤트 기반 데이터 동기화 메커니즘 구현
  2. 쓰기 작업에 대한 트랜잭션 패턴 적용
  3. 데이터 정합성 검증을 위한 백그라운드 프로세스 도입

- **교훈**: 분산 데이터 저장소를 사용할 때는 일관성 전략이 핵심임

### 🔭 미래 확장 계획

이 프로젝트를 기반으로 다음과 같은 확장을 계획하고 있습니다:

1. **고급 AI 분석 기능**
   - 머신러닝 기반 이상 탐지 알고리즘 도입
   - 예측적 스케일링 권장사항 제공
   - 자동 문제 해결 제안 기능

2. **멀티 클라우드 지원**
   - AWS, GCP, Azure 통합 모니터링
   - 클라우드 간 성능 비교 분석
   - 비용 최적화 제안 기능

3. **생성형 AI 통합**
   - 자연어 보고서 생성 기능
   - 이상 상황에 대한 원인 분석 설명
   - 대화형 트러블슈팅 어시스턴트

## 팀 소개 및 역할

본 프로젝트는 다양한 배경을 가진 5명의 엔지니어가 협력하여 진행했습니다:

- **김민준**: 프로젝트 리드 & 아키텍처 설계
  - MCP 엔진 설계 및 자연어 처리 모듈 개발
  - AI 활용 개발 방법론 수립

- **이지현**: 프론트엔드 개발 리드
  - 대시보드 UI/UX 설계 및 구현
  - 데이터 시각화 컴포넌트 개발

- **박준호**: 백엔드 개발 리드
  - API 설계 및 구현
  - 데이터 저장소 전략 수립

- **정서연**: 데이터 엔지니어
  - 하이브리드 스토리지 구현
  - 성능 최적화 및 캐싱 전략

- **최동현**: DevOps 엔지니어
  - 서버리스 배포 파이프라인 구축
  - 모니터링 및 알림 시스템 구현

---

*본 문서는 OpenManager Vibe V5 개발팀이 2025년 사내 서버 모니터링 혁신 경연대회에 제출한 공식 프로젝트 가이드입니다. 2025년 5월 20일~6월 2일 기간 동안 집중 개발되었으며, 6월 10일 경연대회 발표 예정입니다.* 