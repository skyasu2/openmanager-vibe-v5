# React 컴포넌트 구조

OpenManager Vibe V5의 React 컴포넌트 구조와 사용 방법에 대한 가이드입니다.

## UI 컴포넌트 (shadcn/ui)

OpenManager Vibe V5는 [shadcn/ui](https://ui.shadcn.com/)를 기반으로 구축된 재사용 가능한 컴포넌트 시스템을 사용합니다. 이 컴포넌트들은 스타일링과 동작이 일관되며, 접근성을 고려하여 설계되었습니다.

### 핵심 UI 컴포넌트

#### 1. Button

다양한 크기, 변형, 상태를 지원하는 버튼 컴포넌트입니다.

```tsx
// src/components/ui/Button.tsx 사용 예시
import { Button } from "@/components/ui/Button";

export function ActionButtons() {
  return (
    <div className="flex gap-2">
      <Button variant="default">기본</Button>
      <Button variant="destructive">삭제</Button>
      <Button variant="outline">아웃라인</Button>
      <Button variant="ghost">고스트</Button>
      <Button variant="link">링크</Button>
      <Button disabled>비활성화</Button>
    </div>
  );
}
```

#### 2. Card

콘텐츠를 담는 카드 컴포넌트입니다. `Card`, `CardHeader`, `CardTitle`, `CardDescription`, `CardContent`, `CardFooter`로 구성됩니다.

```tsx
// src/components/ui/Card.tsx 사용 예시
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/Card";

export function ServerCard({ server }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{server.name}</CardTitle>
        <CardDescription>서버 ID: {server.id}</CardDescription>
      </CardHeader>
      <CardContent>
        <p>CPU: {server.cpu.usage}%</p>
        <p>메모리: {server.memory.usage}%</p>
        <p>디스크: {server.disk.usage}%</p>
      </CardContent>
      <CardFooter>
        <p>최근 업데이트: {formatDate(server.lastChecked)}</p>
      </CardFooter>
    </Card>
  );
}
```

#### 3. Dialog

모달 다이얼로그 컴포넌트입니다. `Dialog`, `DialogTrigger`, `DialogContent`, `DialogHeader`, `DialogTitle`, `DialogDescription`, `DialogFooter`로 구성됩니다.

```tsx
// src/components/ui/Dialog.tsx 사용 예시
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/Dialog";
import { Button } from "@/components/ui/Button";

export function AlertDialog({ server }) {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="destructive">서버 재시작</Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>서버 재시작 확인</DialogTitle>
          <DialogDescription>
            정말로 {server.name} 서버를 재시작하시겠습니까? 이 작업은 되돌릴 수 없습니다.
          </DialogDescription>
        </DialogHeader>
        <DialogFooter>
          <Button variant="outline" onClick={() => {}}>취소</Button>
          <Button variant="destructive" onClick={() => {}}>재시작</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

#### 4. Form 컴포넌트

리액트 훅 폼(React Hook Form)과 통합된 폼 컴포넌트입니다. 유효성 검사와 접근성을 고려하여 설계되었습니다.

```tsx
// src/components/ui/Form.tsx 사용 예시
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import * as z from "zod";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/Form";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/Button";

// 폼 스키마 정의
const formSchema = z.object({
  serverName: z.string().min(3, "서버 이름은 최소 3자 이상이어야 합니다."),
  hostname: z.string().min(1, "호스트명을 입력해주세요."),
});

export function ServerForm() {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      serverName: "",
      hostname: "",
    },
  });

  function onSubmit(values: z.infer<typeof formSchema>) {
    console.log(values);
    // 서버 추가 로직
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <FormField
          control={form.control}
          name="serverName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>서버 이름</FormLabel>
              <FormControl>
                <Input placeholder="웹 서버 1" {...field} />
              </FormControl>
              <FormDescription>서버를 식별하기 위한 이름입니다.</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="hostname"
          render={({ field }) => (
            <FormItem>
              <FormLabel>호스트명 / IP</FormLabel>
              <FormControl>
                <Input placeholder="example.com 또는 192.168.1.1" {...field} />
              </FormControl>
              <FormDescription>서버의 호스트명 또는 IP 주소입니다.</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit">서버 추가</Button>
      </form>
    </Form>
  );
}
```

## 비즈니스 컴포넌트

비즈니스 컴포넌트는 UI 컴포넌트를 조합하여 특정 비즈니스 목적에 맞게 구현된 컴포넌트입니다.

### 모니터링 대시보드 컴포넌트

#### 1. ServerStatusCard

서버의 현재 상태를 보여주는 카드 컴포넌트입니다.

```tsx
// src/components/monitoring/ServerStatusCard.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
import { ServerStatus, ServerStats } from "@/types";
import { CircularProgressbar } from "@/components/ui/CircularProgressbar";

interface ServerStatusCardProps {
  server: ServerStats;
  onRefresh?: () => void;
}

export function ServerStatusCard({ server, onRefresh }: ServerStatusCardProps) {
  const getStatusColor = (status: ServerStatus) => {
    switch (status) {
      case "healthy": return "text-green-500";
      case "warning": return "text-yellow-500";
      case "critical": return "text-red-500";
      case "offline": return "text-gray-500";
      default: return "text-gray-700";
    }
  };

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <CardTitle className="text-sm font-medium">{server.name}</CardTitle>
        <div className={`text-xs font-bold ${getStatusColor(server.status)}`}>
          {server.status.toUpperCase()}
        </div>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-3 gap-4">
          <div className="flex flex-col items-center">
            <CircularProgressbar 
              value={server.cpu.usage} 
              strokeWidth={10}
              pathColor={server.cpu.usage > 80 ? "rgb(239, 68, 68)" : "rgb(59, 130, 246)"}
            />
            <div className="mt-2 text-xs font-semibold">CPU</div>
            <div className="text-xs text-muted-foreground">{server.cpu.usage}%</div>
          </div>
          <div className="flex flex-col items-center">
            <CircularProgressbar 
              value={server.memory.usage} 
              strokeWidth={10}
              pathColor={server.memory.usage > 80 ? "rgb(239, 68, 68)" : "rgb(59, 130, 246)"}
            />
            <div className="mt-2 text-xs font-semibold">메모리</div>
            <div className="text-xs text-muted-foreground">{server.memory.usage}%</div>
          </div>
          <div className="flex flex-col items-center">
            <CircularProgressbar 
              value={server.disk.usage} 
              strokeWidth={10}
              pathColor={server.disk.usage > 80 ? "rgb(239, 68, 68)" : "rgb(59, 130, 246)"}
            />
            <div className="mt-2 text-xs font-semibold">디스크</div>
            <div className="text-xs text-muted-foreground">{server.disk.usage}%</div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

#### 2. PerformanceChart

성능 데이터를 시각화하는 차트 컴포넌트입니다.

```tsx
// src/components/monitoring/PerformanceChart.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/Tabs";
import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer } from "recharts";
import { PerformanceData } from "@/types";
import { formatDate } from "@/lib/utils";

interface PerformanceChartProps {
  data: PerformanceData[];
  title: string;
  timeRanges: Array<{ value: string; label: string }>;
}

export function PerformanceChart({ data, title, timeRanges }: PerformanceChartProps) {
  return (
    <Card className="col-span-4">
      <CardHeader>
        <CardTitle>{title}</CardTitle>
        <Tabs defaultValue={timeRanges[0].value} className="w-full">
          <TabsList className="grid w-full max-w-md grid-cols-4">
            {timeRanges.map((range) => (
              <TabsTrigger key={range.value} value={range.value}>
                {range.label}
              </TabsTrigger>
            ))}
          </TabsList>
          {timeRanges.map((range) => (
            <TabsContent key={range.value} value={range.value}>
              <CardContent className="pt-4">
                <ResponsiveContainer width="100%" height={300}>
                  <LineChart data={data}>
                    <XAxis 
                      dataKey="timestamp" 
                      tickFormatter={(timestamp) => formatDate(timestamp, 'HH:mm')}
                    />
                    <YAxis />
                    <Tooltip 
                      labelFormatter={(label) => formatDate(label)}
                      formatter={(value) => [`${value}%`, "사용률"]}
                    />
                    <Line 
                      type="monotone" 
                      dataKey="value" 
                      stroke="#2563eb" 
                      strokeWidth={2} 
                      dot={false} 
                      activeDot={{ r: 4 }}
                    />
                  </LineChart>
                </ResponsiveContainer>
              </CardContent>
            </TabsContent>
          ))}
        </Tabs>
      </CardHeader>
    </Card>
  );
}
```

#### 3. AlertsPanel

알림을 표시하는 패널 컴포넌트입니다.

```tsx
// src/components/monitoring/AlertsPanel.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/Alert";
import { AlertCircle, Info, CheckCircle } from "lucide-react";
import { Alert as AlertType } from "@/types";
import { formatDistanceToNow } from "date-fns";
import { ko } from "date-fns/locale";

interface AlertsPanelProps {
  alerts: AlertType[];
}

export function AlertsPanel({ alerts }: AlertsPanelProps) {
  const getAlertIcon = (type: AlertType['type']) => {
    switch (type) {
      case "error": return <AlertCircle className="h-4 w-4 text-red-500" />;
      case "warning": return <AlertCircle className="h-4 w-4 text-yellow-500" />;
      case "info": return <Info className="h-4 w-4 text-blue-500" />;
      case "success": return <CheckCircle className="h-4 w-4 text-green-500" />;
      default: return <Info className="h-4 w-4" />;
    }
  };
  
  const formatAlertTime = (timestamp: string) => {
    return formatDistanceToNow(new Date(timestamp), { addSuffix: true, locale: ko });
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>알림</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4 max-h-[400px] overflow-y-auto">
        {alerts.length === 0 ? (
          <p className="text-muted-foreground text-sm">현재 알림이 없습니다.</p>
        ) : (
          alerts.map((alert) => (
            <Alert key={alert.id} variant={alert.type === "error" ? "destructive" : "default"}>
              <div className="flex items-start">
                {getAlertIcon(alert.type)}
                <div className="ml-2">
                  <AlertTitle className="text-sm font-medium">
                    {alert.title}
                  </AlertTitle>
                  <AlertDescription className="text-sm">{alert.message}</AlertDescription>
                  <div className="text-xs text-muted-foreground mt-1">
                    {formatAlertTime(alert.timestamp)}
                  </div>
                </div>
              </div>
            </Alert>
          ))
        )}
      </CardContent>
    </Card>
  );
}
```

## 실시간 차트 컴포넌트

Recharts 라이브러리를 활용한 실시간 데이터 시각화 컴포넌트입니다.

### 1. LineChartComponent

시계열 데이터를 표시하는 선 차트입니다.

```tsx
// src/components/monitoring/LineChartComponent.tsx
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/Card";
import { TimeSeriesData } from "@/types";
import { formatDate } from "@/lib/utils";

interface LineChartComponentProps {
  data: TimeSeriesData[];
  title: string;
  dataKey: string;
  yAxisLabel?: string;
  color?: string;
}

export function LineChartComponent({
  data,
  title,
  dataKey,
  yAxisLabel = "값",
  color = "#2563eb",
}: LineChartComponentProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={300}>
          <LineChart data={data} margin={{ top: 5, right: 20, left: 20, bottom: 5 }}>
            <CartesianGrid strokeDasharray="3 3" opacity={0.2} />
            <XAxis
              dataKey="timestamp"
              tick={{ fontSize: 12 }}
              tickFormatter={(timestamp) => formatDate(timestamp, 'HH:mm')}
            />
            <YAxis
              label={{ 
                value: yAxisLabel, 
                angle: -90, 
                position: 'insideLeft', 
                style: { textAnchor: 'middle' } 
              }}
              tick={{ fontSize: 12 }}
            />
            <Tooltip
              labelFormatter={(label) => formatDate(label)}
              formatter={(value) => [`${value}`, yAxisLabel]}
            />
            <Legend />
            <Line
              type="monotone"
              dataKey={dataKey}
              stroke={color}
              strokeWidth={2}
              dot={false}
              activeDot={{ r: 5 }}
              animationDuration={500}
            />
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
}
```

### 2. MultiLineChart

여러 지표를 동시에 표시하는 차트입니다.

```tsx
// src/components/monitoring/MultiLineChart.tsx
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/Card";
import { TimeSeriesData } from "@/types";
import { formatDate } from "@/lib/utils";

interface LineConfig {
  key: string;
  color: string;
  label: string;
}

interface MultiLineChartProps {
  data: TimeSeriesData[];
  title: string;
  lines: LineConfig[];
  yAxisLabel?: string;
}

export function MultiLineChart({
  data,
  title,
  lines,
  yAxisLabel = "값",
}: MultiLineChartProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={300}>
          <LineChart data={data} margin={{ top: 5, right: 20, left: 20, bottom: 5 }}>
            <CartesianGrid strokeDasharray="3 3" opacity={0.2} />
            <XAxis
              dataKey="timestamp"
              tick={{ fontSize: 12 }}
              tickFormatter={(timestamp) => formatDate(timestamp, 'HH:mm')}
            />
            <YAxis
              label={{ 
                value: yAxisLabel, 
                angle: -90, 
                position: 'insideLeft', 
                style: { textAnchor: 'middle' } 
              }}
              tick={{ fontSize: 12 }}
            />
            <Tooltip
              labelFormatter={(label) => formatDate(label)}
            />
            <Legend />
            {lines.map((line) => (
              <Line
                key={line.key}
                type="monotone"
                dataKey={line.key}
                name={line.label}
                stroke={line.color}
                strokeWidth={2}
                dot={false}
                activeDot={{ r: 5 }}
                animationDuration={500}
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
}
```

## 알림 시스템 컴포넌트

사용자에게 알림을 표시하는 컴포넌트입니다.

### ToastNotification

시스템 알림을 toast 형태로 표시합니다.

```tsx
// src/components/monitoring/ToastNotification.tsx
import { useEffect } from "react";
import { Toast, ToastDescription, ToastTitle } from "@/components/ui/Toast";
import { useToast } from "@/hooks/useToast";
import { AlertCircle, Info, CheckCircle } from "lucide-react";
import { Alert } from "@/types";

interface ToastNotificationProps {
  alert: Alert;
  autoDismiss?: boolean;
  dismissDuration?: number;
}

export function ToastNotification({
  alert,
  autoDismiss = true,
  dismissDuration = 5000,
}: ToastNotificationProps) {
  const { dismiss } = useToast();

  useEffect(() => {
    if (autoDismiss) {
      const timer = setTimeout(() => {
        dismiss(alert.id);
      }, dismissDuration);
      return () => clearTimeout(timer);
    }
  }, [alert.id, autoDismiss, dismissDuration, dismiss]);

  const getAlertIcon = () => {
    switch (alert.type) {
      case "error": return <AlertCircle className="h-5 w-5 text-red-500" />;
      case "warning": return <AlertCircle className="h-5 w-5 text-yellow-500" />;
      case "info": return <Info className="h-5 w-5 text-blue-500" />;
      case "success": return <CheckCircle className="h-5 w-5 text-green-500" />;
      default: return <Info className="h-5 w-5" />;
    }
  };

  return (
    <Toast variant={alert.type === "error" ? "destructive" : "default"}>
      <div className="flex items-start gap-2">
        {getAlertIcon()}
        <div>
          <ToastTitle>{alert.title}</ToastTitle>
          <ToastDescription>{alert.message}</ToastDescription>
        </div>
      </div>
    </Toast>
  );
}
```

## 상태 관리 (Zustand)

Zustand를 사용한 상태 관리 예시입니다.

### ServerStore

서버 상태를 관리하는 스토어입니다.

```typescript
// src/stores/serverStore.ts
import { create } from 'zustand';
import { ServerStats } from '@/types';
import { fetchServers } from '@/lib/api';

interface ServerState {
  servers: ServerStats[];
  isLoading: boolean;
  error: Error | null;
  fetchServers: () => Promise<void>;
  getServerById: (id: string) => ServerStats | undefined;
}

export const useServerStore = create<ServerState>((set, get) => ({
  servers: [],
  isLoading: false,
  error: null,

  fetchServers: async () => {
    try {
      set({ isLoading: true, error: null });
      const servers = await fetchServers();
      set({ servers, isLoading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error : new Error('서버 데이터 로딩 실패'), 
        isLoading: false 
      });
    }
  },

  getServerById: (id: string) => {
    return get().servers.find(server => server.id === id);
  },
}));
```

### AlertStore

알림을 관리하는 스토어입니다.

```typescript
// src/stores/alertStore.ts
import { create } from 'zustand';
import { Alert, ServerStats } from '@/types';
import { fetchAlerts } from '@/lib/api';

interface AlertState {
  alerts: Alert[];
  isLoading: boolean;
  error: Error | null;
  fetchAlerts: () => Promise<void>;
  addAlert: (alert: Omit<Alert, 'id' | 'timestamp'>) => void;
  markAsRead: (id: string) => void;
  clearAll: () => void;
}

export const useAlertStore = create<AlertState>((set, get) => ({
  alerts: [],
  isLoading: false,
  error: null,

  fetchAlerts: async () => {
    try {
      set({ isLoading: true, error: null });
      const alerts = await fetchAlerts();
      set({ alerts, isLoading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error : new Error('알림 데이터 로딩 실패'), 
        isLoading: false 
      });
    }
  },

  addAlert: (alert) => {
    const newAlert: Alert = {
      id: Date.now().toString(),
      timestamp: new Date().toISOString(),
      read: false,
      ...alert
    };

    set(state => ({
      alerts: [newAlert, ...state.alerts]
    }));
  },

  markAsRead: (id) => {
    set(state => ({
      alerts: state.alerts.map(alert => 
        alert.id === id ? { ...alert, read: true } : alert
      )
    }));
  },

  clearAll: () => {
    set({ alerts: [] });
  }
}));
```

## 컴포넌트 사용 예시

실제 페이지에서 컴포넌트를 조합하여 사용하는 방법입니다.

```tsx
// src/app/dashboard/page.tsx
import { Suspense } from "react";
import { ServerStatusCard } from "@/components/monitoring/ServerStatusCard";
import { PerformanceChart } from "@/components/monitoring/PerformanceChart";
import { AlertsPanel } from "@/components/monitoring/AlertsPanel";
import { MultiLineChart } from "@/components/monitoring/MultiLineChart";
import { getServerStats, getPerformanceData, getAlerts } from "@/lib/api";
import { Skeleton } from "@/components/ui/Skeleton";

export default async function DashboardPage() {
  // 서버 데이터 가져오기
  const servers = await getServerStats();
  const performanceData = await getPerformanceData();
  const alerts = await getAlerts();
  
  // 시간 범위 정의
  const timeRanges = [
    { value: "1h", label: "1시간" },
    { value: "6h", label: "6시간" },
    { value: "24h", label: "1일" },
    { value: "7d", label: "7일" },
  ];

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">서버 모니터링 대시보드</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
        {servers.map(server => (
          <ServerStatusCard key={server.id} server={server} />
        ))}
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-8">
        <div className="lg:col-span-2">
          <Suspense fallback={<Skeleton className="h-[400px]" />}>
            <PerformanceChart 
              data={performanceData.cpu} 
              title="CPU 사용량 추이" 
              timeRanges={timeRanges}
            />
          </Suspense>
        </div>
        <div className="lg:col-span-1">
          <AlertsPanel alerts={alerts} />
        </div>
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
        <Suspense fallback={<Skeleton className="h-[300px]" />}>
          <MultiLineChart 
            data={performanceData.network} 
            title="네트워크 트래픽" 
            lines={[
              { key: "rx", color: "#2563eb", label: "수신" },
              { key: "tx", color: "#16a34a", label: "송신" }
            ]}
            yAxisLabel="KB/s"
          />
        </Suspense>
        <Suspense fallback={<Skeleton className="h-[300px]" />}>
          <LineChartComponent 
            data={performanceData.memory} 
            title="메모리 사용량" 
            dataKey="value"
            yAxisLabel="사용률 (%)"
          />
        </Suspense>
      </div>
    </div>
  );
}
```

## 컴포넌트 모범 사례

### 1. 컴포넌트 구조

- **단일 책임 원칙**: 각 컴포넌트는 한 가지 책임만 가지도록 합니다.
- **컴포넌트 크기**: 200줄 이하를 유지하고, 더 크다면 분리를 고려합니다.
- **폴더 구조**: 기능별 또는 도메인별로 컴포넌트를 구성합니다.

### 2. 성능 최적화

- **메모이제이션**: `React.memo`, `useMemo`, `useCallback`을 적절히 사용합니다.
- **상태 선택**: Zustand의 선택자를 사용하여 필요한 상태만 가져옵니다.
- **가상화**: 긴 목록을 렌더링할 때 `react-virtualized`나 `react-window`를 사용합니다.

### 3. 접근성

- **시멘틱 HTML**: 의미 있는 HTML 요소를 사용합니다.
- **ARIA 속성**: 접근성을 향상시키는 ARIA 속성을 추가합니다.
- **키보드 탐색**: 모든 인터랙티브 요소는 키보드로 탐색 가능해야 합니다.

---

이 문서는 OpenManager Vibe V5의 React 컴포넌트 구조와 사용법에 대한 가이드입니다. 추가 질문이나 변경 사항이 있으면 개발팀에 문의하세요.