# 🔧 OpenManager Vibe V5 - 문제해결 가이드

> **프로젝트**: OpenManager Vibe V5 - 지능형 AI 기반 서버 모니터링 시스템  
> **대상**: 개발자, 시스템 관리자, 문제 해결 담당자  
> **최종 업데이트**: 2025-01-27  

---

## 📋 **개요**

이 문서는 OpenManager Vibe V5에서 발생할 수 있는 다양한 문제들과 해결방법을 종합적으로 다룹니다.

### 🎯 **주요 내용**
- **일반적인 문제**: 설치, 빌드, 배포 오류
- **순차 서버 생성 문제**: API 지연, 생성 중단 등
- **AI 에이전트 문제**: 응답 지연, 오류 처리
- **성능 문제**: 메모리, CPU, 네트워크 최적화
- **아키텍처 분석**: 코드 품질 및 개선 방향

---

## 🚨 **긴급 문제 해결**

### **1. 서비스 중단 상황**

#### **1.1 전체 서비스 다운**
```bash
# 1. 즉시 확인 사항
curl -I http://localhost:3000
curl -I https://your-domain.vercel.app

# 2. 로그 확인
npm run logs
# 또는 Vercel
vercel logs --follow

# 3. 프로세스 상태 확인
ps aux | grep node
systemctl status openmanager  # systemd 사용 시

# 4. 긴급 복구
npm run build && npm start
# 또는 Docker
docker-compose restart
```

#### **1.2 데이터베이스 연결 실패**
```bash
# Supabase 연결 테스트
curl -X GET "https://your-project.supabase.co/rest/v1/servers" \
  -H "apikey: your-anon-key" \
  -H "Authorization: Bearer your-anon-key"

# 환경 변수 확인
echo $SUPABASE_URL
echo $SUPABASE_ANON_KEY

# Fallback 모드 강제 활성화
export FORCE_FALLBACK=true
npm restart
```

---

## 🔄 **순차 서버 생성 문제**

### **1. 서버 생성 중단**

#### **증상**
- 진행률이 특정 지점에서 멈춤
- "서버 생성 중..." 상태에서 무한 대기
- API 응답 없음

#### **원인 분석**
```bash
# 1. API 상태 확인
curl -X GET http://localhost:3000/api/servers/next

# 2. VirtualServerManager 상태 확인
curl -X POST http://localhost:3000/api/servers/next \
  -H "Content-Type: application/json" \
  -d '{"action": "status"}'

# 3. 메모리 사용량 확인
free -h  # Linux
Get-Process node | Select-Object CPU,WorkingSet  # Windows PowerShell
```

#### **해결방법**
```bash
# 1. 서버 생성 리셋
curl -X POST http://localhost:3000/api/servers/next \
  -H "Content-Type: application/json" \
  -d '{"reset": true}'

# 2. 캐시 정리
rm -rf .next/cache
npm run clean

# 3. VirtualServerManager 재시작 (애플리케이션 재시작)
npm run dev  # 개발 환경
pm2 restart openmanager  # 프로덕션
```

### **2. 서버 생성 속도 저하**

#### **증상**
- 1초 간격이 아닌 더 긴 간격으로 생성
- API 응답시간 100ms 이상

#### **해결방법**
```typescript
// src/app/api/servers/next/route.ts 확인
// 응답시간 측정 추가
const startTime = Date.now();
// ... 처리 로직
const processingTime = Date.now() - startTime;
console.log(`API 처리시간: ${processingTime}ms`);
```

```bash
# 성능 모니터링
npm run monitor  # 커스텀 스크립트
top -p $(pgrep -f "node.*next")  # CPU 사용률 확인
```

---

## 🤖 **AI 에이전트 문제**

### **1. AI 응답 지연 및 타임아웃**

#### **증상**
- AI 에이전트 응답 시간 5초 이상
- "AI 처리 중..." 상태에서 멈춤
- Fallback 시스템 작동

#### **원인 분석**
```bash
# 1. AI 엔진 상태 확인
curl -X POST http://localhost:3000/api/ai-agent/optimized \
  -H "Content-Type: application/json" \
  -d '{"action": "health-check"}'

# 2. Python 프로세스 확인
ps aux | grep python
python3 --version

# 3. 메모리 사용량 확인
cat /proc/meminfo | grep Available  # Linux
wmic OS get TotalVisibleMemorySize,FreePhysicalMemory  # Windows
```

#### **해결방법**

**1차: 최적화된 엔진 재시작**
```bash
# Python 패키지 재설치
pip3 install -r requirements-light.txt

# Node.js 메모리 증가
export NODE_OPTIONS="--max-old-space-size=4096"
npm run dev
```

**2차: Fallback 시스템 확인**
```bash
# 패턴 매칭 엔진 테스트
curl -X POST http://localhost:3000/api/ai-agent/pattern-query \
  -H "Content-Type: application/json" \
  -d '{"action": "test"}'

# 통합 시스템 테스트
curl -X POST http://localhost:3000/api/ai-agent/integrated \
  -H "Content-Type: application/json" \
  -d '{"action": "test"}'
```

### **2. AI 응답 품질 저하**

#### **증상**
- 부정확한 분석 결과
- 일반적인 응답만 제공
- 컨텍스트 이해 부족

#### **해결방법**
```typescript
// src/modules/ai-agent/core/EnhancedAIAgentEngine.ts
// 컨텍스트 강화
const enhancedContext = {
  ...baseContext,
  serverMetrics: detailedMetrics,
  historicalData: recentHistory,
  systemStatus: currentStatus
};

// 응답 품질 체크
if (response.confidence < 0.7) {
  // 추가 분석 수행
  response = await performDeepAnalysis(query, enhancedContext);
}
```

---

## 💾 **메모리 및 성능 문제**

### **1. 메모리 누수**

#### **증상**
- 시간이 지날수록 메모리 사용량 증가
- 서버 응답 속도 저하
- Out of Memory 오류

#### **진단**
```bash
# Node.js 메모리 사용량 모니터링
npm install -g clinic
clinic doctor -- npm start

# 힙 덤프 생성
kill -USR2 $(pgrep -f "node.*next")
# 생성된 heapdump 파일 분석
```

#### **해결방법**
```typescript
// 메모리 모니터링 추가
setInterval(() => {
  const usage = process.memoryUsage();
  console.log('메모리 사용량:', {
    rss: `${Math.round(usage.rss / 1024 / 1024)}MB`,
    heap: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`
  });
  
  // 임계값 초과 시 가비지 컬렉션
  if (usage.heapUsed > 512 * 1024 * 1024 && global.gc) {
    global.gc();
  }
}, 30000);
```

### **2. CPU 과부하**

#### **증상**
- CPU 사용률 90% 이상 지속
- 서버 응답 지연
- 프론트엔드 렌더링 지연

#### **해결방법**
```bash
# CPU 사용률이 높은 프로세스 확인
top -p $(pgrep -f "node.*next")
htop  # 더 자세한 정보

# 워커 프로세스 수 조정
export UV_THREADPOOL_SIZE=4  # 기본값보다 증가
```

```typescript
// CPU 집약적 작업을 워커 스레드로 분리
import { Worker } from 'worker_threads';

const performHeavyTask = (data: any) => {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./cpu-intensive-worker.js', {
      workerData: data
    });
    
    worker.on('message', resolve);
    worker.on('error', reject);
  });
};
```

---

## 🌐 **네트워크 및 API 문제**

### **1. API 응답 지연**

#### **증상**
- API 호출 시 응답시간 1초 이상
- 프론트엔드에서 로딩 상태 지속
- 타임아웃 오류 발생

#### **진단 및 해결**
```bash
# API 응답시간 측정
curl -w "@curl-format.txt" -o /dev/null http://localhost:3000/api/servers/next

# curl-format.txt 내용:
#     time_namelookup:  %{time_namelookup}\n
#        time_connect:  %{time_connect}\n
#     time_appconnect:  %{time_appconnect}\n
#    time_pretransfer:  %{time_pretransfer}\n
#       time_redirect:  %{time_redirect}\n
#  time_starttransfer:  %{time_starttransfer}\n
#                     ----------\n
#          time_total:  %{time_total}\n

# 네트워크 연결 상태 확인
netstat -an | grep :3000
ss -tulpn | grep :3000  # Linux
```

#### **최적화 방법**
```typescript
// API 응답 캐싱
import { LRUCache } from 'lru-cache';

const apiCache = new LRUCache<string, any>({
  max: 500,
  ttl: 1000 * 60 * 5 // 5분
});

export async function GET(request: NextRequest) {
  const cacheKey = request.url;
  const cached = apiCache.get(cacheKey);
  
  if (cached) {
    return NextResponse.json(cached);
  }
  
  const result = await processRequest(request);
  apiCache.set(cacheKey, result);
  
  return NextResponse.json(result);
}
```

### **2. Vercel 배포 문제**

#### **빌드 실패**
```bash
# 로컬 빌드 테스트
npm run build

# TypeScript 오류 확인
npm run type-check

# ESLint 오류 수정
npm run lint:fix

# 의존성 문제 해결
rm -rf node_modules package-lock.json
npm install
```

#### **함수 타임아웃**
```javascript
// vercel.json
{
  "functions": {
    "src/app/api/**/*.ts": {
      "maxDuration": 10
    }
  }
}
```

```typescript
// 장시간 작업을 백그라운드로 분리
export async function POST(request: NextRequest) {
  // 즉시 응답
  const jobId = generateJobId();
  
  // 백그라운드 작업 시작
  processInBackground(jobId, requestData);
  
  return NextResponse.json({
    success: true,
    jobId,
    message: '작업이 시작되었습니다'
  });
}
```

---

## 🏗️ **아키텍처 품질 분석**

### **1. 코드 품질 평가**

#### **SOLID 원칙 준수도**
```typescript
// ✅ 좋은 예: 단일 책임 원칙
class ServerGenerator {
  generateServer(hostname: string): Server {
    // 서버 생성만 담당
  }
}

class ServerMetricsCalculator {
  calculateMetrics(server: Server): Metrics {
    // 메트릭 계산만 담당
  }
}

// ❌ 나쁜 예: 여러 책임 혼재
class ServerManager {
  generateServer() { /* 생성 */ }
  calculateMetrics() { /* 계산 */ }
  sendNotification() { /* 알림 */ }
  saveToDatabase() { /* 저장 */ }
}
```

#### **의존성 주입 개선**
```typescript
// ✅ 개선된 구조
interface StorageService {
  save(data: any): Promise<void>;
  load(id: string): Promise<any>;
}

class VirtualServerManager {
  constructor(
    private storage: StorageService,
    private logger: Logger
  ) {}
}

// 의존성 주입
const manager = new VirtualServerManager(
  new SupabaseStorage(),
  new Logger()
);
```

### **2. 성능 최적화 분석**

#### **번들 크기 분석**
```bash
# 번들 분석 도구 설치
npm install --save-dev @next/bundle-analyzer

# package.json에 스크립트 추가
"analyze": "ANALYZE=true npm run build"

# 분석 실행
npm run analyze
```

#### **렌더링 성능 개선**
```typescript
// React.memo로 불필요한 렌더링 방지
const ServerCard = React.memo(({ server }: { server: Server }) => {
  return (
    <div className="server-card">
      {/* 서버 정보 표시 */}
    </div>
  );
});

// useMemo로 비싼 계산 캐싱
const ServerStats = ({ servers }: { servers: Server[] }) => {
  const stats = useMemo(() => {
    return calculateComplexStats(servers);
  }, [servers]);

  return <div>{/* 통계 표시 */}</div>;
};
```

### **3. 리팩토링 권장사항**

#### **모듈화 개선**
```typescript
// 현재 구조 개선
src/modules/
├── server-generation/
│   ├── core/
│   │   ├── VirtualServerManager.ts
│   │   └── ServerGenerator.ts
│   ├── adapters/
│   │   └── StorageAdapter.ts
│   └── types/
│       └── ServerTypes.ts
├── ai-agent/
│   ├── engines/
│   │   ├── OptimizedEngine.ts
│   │   └── FallbackEngine.ts
│   └── processors/
│       ├── QueryProcessor.ts
│       └── ResponseGenerator.ts
└── shared/
    ├── utils/
    ├── types/
    └── constants/
```

#### **에러 처리 표준화**
```typescript
// 통일된 에러 처리
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500,
    public context?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// 사용 예시
throw new AppError(
  '서버 생성 실패',
  'SERVER_GENERATION_FAILED',
  500,
  { hostname: 'web-01', attempt: 3 }
);
```

---

## 📊 **모니터링 및 로깅**

### **1. 실시간 모니터링 설정**

#### **Health Check 엔드포인트**
```typescript
// src/app/api/health/route.ts
export async function GET() {
  const checks = {
    server: 'healthy',
    database: await checkDatabase(),
    ai_engine: await checkAIEngine(),
    memory: getMemoryStatus(),
    timestamp: new Date().toISOString()
  };

  const isHealthy = Object.values(checks).every(
    status => status === 'healthy' || typeof status === 'object'
  );

  return NextResponse.json(checks, {
    status: isHealthy ? 200 : 503
  });
}
```

#### **로그 수집 시스템**
```typescript
// src/utils/Logger.ts
export class Logger {
  static info(message: string, context?: any) {
    console.log(JSON.stringify({
      level: 'info',
      message,
      context,
      timestamp: new Date().toISOString(),
      service: 'openmanager-v5'
    }));
  }

  static error(message: string, error?: Error, context?: any) {
    console.error(JSON.stringify({
      level: 'error',
      message,
      error: error?.message,
      stack: error?.stack,
      context,
      timestamp: new Date().toISOString(),
      service: 'openmanager-v5'
    }));
  }
}
```

---

## 🔍 **디버깅 도구**

### **1. 개발 도구 설정**
```bash
# React DevTools
npm install -g react-devtools

# Next.js 디버깅
NODE_OPTIONS='--inspect' npm run dev

# Chrome DevTools에서 debugging 접속
chrome://inspect
```

### **2. 프로덕션 디버깅**
```typescript
// 프로덕션에서 디버그 정보 수집
if (process.env.NODE_ENV === 'production' && process.env.DEBUG_MODE === 'true') {
  console.log('🔍 디버그 모드 활성화');
  
  // 성능 메트릭 수집
  performance.mark('api-start');
  // ... API 처리
  performance.mark('api-end');
  performance.measure('api-duration', 'api-start', 'api-end');
}
```

---

## 📞 **지원 요청**

### **문제 보고 시 필요한 정보**

1. **환경 정보**
   - OS 및 버전
   - Node.js 버전
   - 브라우저 및 버전

2. **문제 상황**
   - 발생 시간
   - 재현 단계
   - 오류 메시지

3. **로그 정보**
   - 브라우저 콘솔 로그
   - 서버 로그
   - 네트워크 요청/응답

4. **시스템 상태**
   - 메모리 사용량
   - CPU 사용률
   - 네트워크 상태

**연락처**: GitHub Issues 또는 개발팀 이메일

---

**🎯 체계적인 문제 해결로 안정적인 시스템을 유지하세요!**

---

*최종 업데이트: 2025년 1월 27일* 