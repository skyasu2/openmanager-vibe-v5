/**
 * üß† Korean NLP Function
 * 
 * ÌïúÍµ≠Ïñ¥ ÏûêÏó∞Ïñ¥ Ï≤òÎ¶¨ Ï†ÑÎ¨∏ Function
 * Î©îÎ™®Î¶¨: 512MB, ÌÉÄÏûÑÏïÑÏõÉ: 180Ï¥à
 */

const functions = require('@google-cloud/functions-framework');
const { createErrorResponse, createSuccessResponse, validateRequest, isKorean, calculateProcessingTime } = require('../shared/types');

// ÌïúÍµ≠Ïñ¥ NLP ÎèÑÍµ¨ (Í≤ΩÎüâ Î≤ÑÏ†Ñ)
const KOREAN_PARTICLES = ['ÏùÄ', 'Îäî', 'Ïù¥', 'Í∞Ä', 'ÏùÑ', 'Î•º', 'Ïóê', 'Ïùò', 'Î°ú', 'ÏôÄ', 'Í≥º', 'ÏóêÏÑú', 'Î∂ÄÌÑ∞', 'ÍπåÏßÄ', 'Îßå', 'ÎèÑ', 'ÎùºÎèÑ', 'Ï°∞Ï∞®', 'ÎßàÏ†Ä'];
const KOREAN_ENDINGS = ['Îã§', 'Ïöî', 'ÏäµÎãàÎã§', 'Ïù¥Îã§', 'ÏòÄÎã§', 'ÌñàÎã§', 'Îê†', 'Îê†Íπå', 'ÌïòÏûê', 'ÌïòÏßÄÎßå', 'Í∑∏Îü¨ÎÇò', 'Í∑∏Îü∞Îç∞'];

/**
 * ÌïúÍµ≠Ïñ¥ ÏùòÎèÑ Î∂ÑÎ•ò
 * @param {string} query - ÏÇ¨Ïö©Ïûê ÏßàÏùò
 * @returns {string}
 */
function classifyIntent(query) {
    const lowerQuery = query.toLowerCase();

    // ÏßàÎ¨∏ Ìå®ÌÑ¥
    if (lowerQuery.includes('Î¨¥Ïóá') || lowerQuery.includes('Î≠ê') || lowerQuery.includes('?')) {
        return 'question';
    }

    // Î™ÖÎ†π Ìå®ÌÑ¥
    if (lowerQuery.includes('Ìï¥Ï§ò') || lowerQuery.includes('Ìï¥Ï£ºÏÑ∏Ïöî') || lowerQuery.includes('ÌïòÏûê')) {
        return 'command';
    }

    // ÏöîÏ≤≠ Ìå®ÌÑ¥
    if (lowerQuery.includes('ÏïåÎ†§') || lowerQuery.includes('Î≥¥Ïó¨') || lowerQuery.includes('ÏÑ§Î™Ö')) {
        return 'request';
    }

    // ÌôïÏù∏ Ìå®ÌÑ¥
    if (lowerQuery.includes('ÌôïÏù∏') || lowerQuery.includes('Ï≤¥ÌÅ¨') || lowerQuery.includes('Í≤ÄÏÇ¨')) {
        return 'check';
    }

    // Î∂ÑÏÑù Ìå®ÌÑ¥
    if (lowerQuery.includes('Î∂ÑÏÑù') || lowerQuery.includes('Î∂ÑÏÑùÌï¥') || lowerQuery.includes('Ï°∞ÏÇ¨')) {
        return 'analysis';
    }

    // ÏÑúÎ≤Ñ Í¥ÄÎ†® Ìå®ÌÑ¥
    if (lowerQuery.includes('ÏÑúÎ≤Ñ') || lowerQuery.includes('ÏãúÏä§ÌÖú') || lowerQuery.includes('ÏÉÅÌÉú')) {
        return 'server-info';
    }

    return 'general';
}

/**
 * ÌïúÍµ≠Ïñ¥ Í∞êÏ†ï Î∂ÑÏÑù
 * @param {string} query - ÏÇ¨Ïö©Ïûê ÏßàÏùò
 * @returns {string}
 */
function analyzeSentiment(query) {
    const positiveWords = ['Ï¢ãÎã§', 'Ï¢ãÏïÑ', 'ÌõåÎ•≠', 'ÏôÑÎ≤Ω', 'ÏµúÍ≥†', 'Í∞êÏÇ¨', 'Í≥†ÎßàÏõå', 'ÏûòÎêêÎã§', 'ÏÑ±Í≥µ'];
    const negativeWords = ['ÎÇòÏÅòÎã§', 'ÏïàÏ¢ãÎã§', 'Î¨∏Ï†ú', 'Ïò§Î•ò', 'ÏóêÎü¨', 'Ïã§Ìå®', 'ÏïàÎê®', 'Î™ªÌï®', 'Ïñ¥Î†§Ïõå'];
    const urgentWords = ['Í∏âÌï¥', 'Îπ®Î¶¨', 'Ï¶âÏãú', 'ÏßÄÍ∏à', 'ÎãπÏû•', 'Í∏¥Í∏â', 'Ï§ëÏöîÌï¥'];

    const lowerQuery = query.toLowerCase();

    if (urgentWords.some(word => lowerQuery.includes(word))) {
        return 'urgent';
    }

    if (positiveWords.some(word => lowerQuery.includes(word))) {
        return 'positive';
    }

    if (negativeWords.some(word => lowerQuery.includes(word))) {
        return 'negative';
    }

    return 'neutral';
}

/**
 * ÌïúÍµ≠Ïñ¥ ÏóîÌã∞Ìã∞ Ï∂îÏ∂ú
 * @param {string} query - ÏÇ¨Ïö©Ïûê ÏßàÏùò
 * @returns {string[]}
 */
function extractEntities(query) {
    const entities = [];

    // ÏÑúÎ≤Ñ Í¥ÄÎ†® ÏóîÌã∞Ìã∞
    const serverPatterns = [
        /ÏÑúÎ≤Ñ\s*([Í∞Ä-Ìû£\w]+)/g,
        /ÏãúÏä§ÌÖú\s*([Í∞Ä-Ìû£\w]+)/g,
        /(\w+)\s*ÏÑúÎ≤Ñ/g
    ];

    serverPatterns.forEach(pattern => {
        const matches = query.match(pattern);
        if (matches) {
            entities.push(...matches.map(match => match.trim()));
        }
    });

    // Ïà´Ïûê ÏóîÌã∞Ìã∞
    const numberPattern = /\d+/g;
    const numbers = query.match(numberPattern);
    if (numbers) {
        entities.push(...numbers.map(num => `NUMBER:${num}`));
    }

    // ÏãúÍ∞Ñ ÏóîÌã∞Ìã∞
    const timePattern = /(Ïò§Îäò|Ïñ¥Ï†ú|ÎÇ¥Ïùº|Ïù¥Î≤à|ÏßÄÎÇú|Îã§Ïùå)\s*(Ï£º|Îã¨|ÎÖÑ|ÏãúÍ∞Ñ|Î∂Ñ|Ï¥à)?/g;
    const times = query.match(timePattern);
    if (times) {
        entities.push(...times.map(time => `TIME:${time}`));
    }

    return [...new Set(entities)];
}

/**
 * ÌïúÍµ≠Ïñ¥ ÌòïÌÉúÏÜå Î∂ÑÏÑù (Îã®Ïàú Î≤ÑÏ†Ñ)
 * @param {string} query - ÏÇ¨Ïö©Ïûê ÏßàÏùò
 * @returns {Object}
 */
function analyzeMorphology(query) {
    const words = query.split(/\s+/);
    const morphology = {
        nouns: [],
        verbs: [],
        adjectives: [],
        particles: []
    };

    words.forEach(word => {
        // Ï°∞ÏÇ¨ ÌôïÏù∏
        const hasParticle = KOREAN_PARTICLES.some(particle => word.includes(particle));
        if (hasParticle) {
            morphology.particles.push(word);
        }

        // ÎèôÏÇ¨ ÌôïÏù∏ (Í∞ÑÎã®Ìïú Ìå®ÌÑ¥)
        if (word.includes('ÌïòÎã§') || word.includes('ÎêòÎã§') || word.includes('ÏûàÎã§') || KOREAN_ENDINGS.some(ending => word.endsWith(ending))) {
            morphology.verbs.push(word);
        }

        // ÌòïÏö©ÏÇ¨ ÌôïÏù∏
        if (word.includes('Ï¢ãÎã§') || word.includes('ÎÇòÏÅòÎã§') || word.includes('ÌÅ¨Îã§') || word.includes('ÏûëÎã§')) {
            morphology.adjectives.push(word);
        }

        // ÎÇòÎ®∏ÏßÄÎäî Î™ÖÏÇ¨Î°ú Î∂ÑÎ•ò
        if (!hasParticle && !morphology.verbs.includes(word) && !morphology.adjectives.includes(word)) {
            morphology.nouns.push(word);
        }
    });

    return morphology;
}

/**
 * ÌïúÍµ≠Ïñ¥ ÏùëÎãµ ÏÉùÏÑ±
 * @param {Object} analysis - Î∂ÑÏÑù Í≤∞Í≥º
 * @param {string} query - ÏõêÎ≥∏ ÏßàÏùò
 * @returns {string}
 */
function generateKoreanResponse(analysis, query) {
    const { intent, sentiment, entities } = analysis;

    // ÏùòÎèÑÎ≥Ñ ÏùëÎãµ ÌÖúÌîåÎ¶ø
    const templates = {
        question: [
            "ÏßàÎ¨∏Ìï¥Ï£ºÏã† ÎÇ¥Ïö©ÏùÑ Î∂ÑÏÑùÌï¥Î≥¥Í≤†ÏäµÎãàÎã§.",
            "Í∂ÅÍ∏àÌï¥ÌïòÏãúÎäî Ï†êÏóê ÎåÄÌï¥ ÏïåÎ†§ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§.",
            "Î¨∏ÏùòÌïòÏã† ÎÇ¥Ïö©ÏùÑ ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§."
        ],
        command: [
            "ÏöîÏ≤≠ÌïòÏã† ÏûëÏóÖÏùÑ ÏàòÌñâÌïòÍ≤†ÏäµÎãàÎã§.",
            "ÏßÄÏãúÏÇ¨Ìï≠ÏùÑ Ïã§ÌñâÌïòÍ≤†ÏäµÎãàÎã§.",
            "Î™ÖÎ†πÏùÑ Ï≤òÎ¶¨ÌïòÍ≤†ÏäµÎãàÎã§."
        ],
        request: [
            "ÏöîÏ≤≠ÌïòÏã† Ï†ïÎ≥¥Î•º Ï†úÍ≥µÌï¥ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§.",
            "ÌïÑÏöîÌïòÏã† ÎÇ¥Ïö©ÏùÑ ÏïåÎ†§ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§.",
            "ÏõêÌïòÏãúÎäî Ï†ïÎ≥¥Î•º Ï∞æÏïÑÎ≥¥Í≤†ÏäµÎãàÎã§."
        ],
        check: [
            "ÌôïÏù∏ ÏûëÏóÖÏùÑ ÏßÑÌñâÌïòÍ≤†ÏäµÎãàÎã§.",
            "Í≤ÄÏÇ¨ Í≤∞Í≥ºÎ•º ÏïåÎ†§ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§.",
            "ÏÉÅÌÉúÎ•º Ï≤¥ÌÅ¨Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§."
        ],
        analysis: [
            "Î∂ÑÏÑù ÏûëÏóÖÏùÑ ÏàòÌñâÌïòÍ≤†ÏäµÎãàÎã§.",
            "Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌï¥Î≥¥Í≤†ÏäµÎãàÎã§.",
            "ÏÉÅÏÑ∏Ìïú Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Ï†úÍ≥µÌïòÍ≤†ÏäµÎãàÎã§."
        ],
        'server-info': [
            "ÏÑúÎ≤Ñ Ï†ïÎ≥¥Î•º ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§.",
            "ÏãúÏä§ÌÖú ÏÉÅÌÉúÎ•º Ï†êÍ≤ÄÌïòÍ≤†ÏäµÎãàÎã§.",
            "ÏÑúÎ≤Ñ Î™®ÎãàÌÑ∞ÎßÅ Í≤∞Í≥ºÎ•º ÏïåÎ†§ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§."
        ],
        general: [
            "ÏöîÏ≤≠ÏùÑ Ï≤òÎ¶¨ÌïòÍ≤†ÏäµÎãàÎã§.",
            "ÎèÑÏõÄÏùÑ ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§.",
            "Î¨∏ÏùòÏÇ¨Ìï≠ÏùÑ Ìï¥Í≤∞Ìï¥ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§."
        ]
    };

    // Í∞êÏ†ïÏóê Îî∞Î•∏ ÏùëÎãµ ÏàòÏ†ï
    let response = templates[intent][Math.floor(Math.random() * templates[intent].length)];

    if (sentiment === 'urgent') {
        response = 'Í∏¥Í∏â ' + response.replace('Í≤†ÏäµÎãàÎã§', 'ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§');
    } else if (sentiment === 'positive') {
        response = response.replace('Í≤†ÏäµÎãàÎã§', 'ÎìúÎ¶¨Í≤†ÏäµÎãàÎã§');
    } else if (sentiment === 'negative') {
        response = 'Î¨∏Ï†ú Ìï¥Í≤∞ÏùÑ ÏúÑÌï¥ ' + response;
    }

    // ÏóîÌã∞Ìã∞ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    if (entities.length > 0) {
        const entityInfo = entities.filter(e => !e.startsWith('NUMBER:') && !e.startsWith('TIME:'));
        if (entityInfo.length > 0) {
            response += ` ${entityInfo.join(', ')}Ïóê ÎåÄÌïú Ï†ïÎ≥¥Î•º Ìè¨Ìï®ÌïòÏó¨ ÎãµÎ≥ÄÎìúÎ¶¨Í≤†ÏäµÎãàÎã§.`;
        }
    }

    return response;
}

/**
 * Î©îÏù∏ ÌïúÍµ≠Ïñ¥ NLP Ï≤òÎ¶¨
 * @param {string} query - ÏÇ¨Ïö©Ïûê ÏßàÏùò
 * @returns {Object}
 */
function processKoreanNLP(query) {
    const startTime = Date.now();

    // ÌïúÍµ≠Ïñ¥ Í≤ÄÏ¶ù
    if (!isKorean(query)) {
        return {
            success: false,
            confidence: 0.1,
            error: 'Not a Korean query'
        };
    }

    // Î∂ÑÏÑù ÏàòÌñâ
    const intent = classifyIntent(query);
    const sentiment = analyzeSentiment(query);
    const entities = extractEntities(query);
    const morphology = analyzeMorphology(query);

    const analysis = {
        intent,
        sentiment,
        entities,
        morphology,
        confidence: 0.85 // ÌïúÍµ≠Ïñ¥ ÌäπÌôî Ï≤òÎ¶¨Ïóê ÎåÄÌïú Í∏∞Î≥∏ Ïã†Î¢∞ÎèÑ
    };

    // ÏùëÎãµ ÏÉùÏÑ±
    const response = generateKoreanResponse(analysis, query);

    // Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
    let confidence = 0.85;
    if (entities.length > 0) confidence += 0.05;
    if (intent !== 'general') confidence += 0.05;
    if (sentiment !== 'neutral') confidence += 0.03;

    const processingTime = Date.now() - startTime;

    return {
        success: true,
        response,
        confidence: Math.min(confidence, 0.98),
        analysis,
        processingTime
    };
}

/**
 * Î©îÏù∏ Ìï∏Îì§Îü¨
 */
functions.http('korean-nlp', async (req, res) => {
    const startTime = Date.now();

    // CORS ÏÑ§Ï†ï
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');

    if (req.method === 'OPTIONS') {
        res.status(204).send('');
        return;
    }

    if (req.method !== 'POST') {
        res.status(405).json(createErrorResponse('Method not allowed', 'korean-nlp'));
        return;
    }

    try {
        // ÏöîÏ≤≠ Í≤ÄÏ¶ù
        const requestData = validateRequest(req);
        if (!requestData) {
            res.status(400).json(createErrorResponse('Invalid request format', 'korean-nlp'));
            return;
        }

        console.log(`Korean NLP: Processing "${requestData.query}"`);

        // ÌïúÍµ≠Ïñ¥ NLP Ï≤òÎ¶¨
        const result = processKoreanNLP(requestData.query);

        if (!result.success) {
            res.status(400).json(createErrorResponse(result.error, 'korean-nlp'));
            return;
        }

        // ÏùëÎãµ ÏÉùÏÑ±
        const response = createSuccessResponse(
            result.response,
            'korean-nlp',
            result.confidence,
            calculateProcessingTime(startTime),
            {
                analysis: result.analysis,
                koreanSpecific: true
            }
        );

        console.log(`Korean NLP: Completed in ${response.processingTime}ms (confidence: ${result.confidence})`);

        res.status(200).json(response);

    } catch (error) {
        console.error('Korean NLP error:', error);

        const errorResponse = createErrorResponse(
            error.message || 'Korean NLP processing failed',
            'korean-nlp',
            calculateProcessingTime(startTime)
        );

        res.status(500).json(errorResponse);
    }
});

// Ìó¨Ïä§ Ï≤¥ÌÅ¨
functions.http('korean-nlp-health', async (req, res) => {
    res.set('Access-Control-Allow-Origin', '*');

    if (req.method === 'OPTIONS') {
        res.status(204).send('');
        return;
    }

    // Í∞ÑÎã®Ìïú ÌïúÍµ≠Ïñ¥ Ï≤òÎ¶¨ ÌÖåÏä§Ìä∏
    const testResult = processKoreanNLP('ÏÑúÎ≤Ñ ÏÉÅÌÉúÍ∞Ä Ïñ¥ÎñªÏäµÎãàÍπå?');

    const health = {
        status: testResult.success ? 'healthy' : 'unhealthy',
        timestamp: new Date().toISOString(),
        function: 'korean-nlp',
        memory: '512MB',
        timeout: '180s',
        version: '1.0.0',
        test: {
            query: 'ÏÑúÎ≤Ñ ÏÉÅÌÉúÍ∞Ä Ïñ¥ÎñªÏäµÎãàÍπå?',
            confidence: testResult.confidence,
            processingTime: testResult.processingTime
        }
    };

    res.status(testResult.success ? 200 : 500).json(health);
}); 