# useState vs useReducer 선택 기준 - AI 교차검증 의사결정

**날짜**: 2025-10-10
**상황**: React 상태 관리에서 useState와 useReducer 중 어느 것을 선택해야 하는지에 대한 가이드라인 필요

---

## 🤖 AI 의견 요약

### 📊 Codex (실무 관점)
- **핵심 주장**: 단순할 땐 useState, 복잡해지면 useReducer
- **근거**:
  - useState는 보일러플레이트가 적어 빠른 개발
  - useReducer는 로직이 분기/검증/비동기 처리로 복잡해질 때 테스트와 리팩토링이 쉬움
- **추천 사항**:
  - 단순 상태 → useState 유지
  - 상태 전이 패턴 복잡해지면 reducer 도입 검토
  - 컴포넌트 무거워지면 커스텀 훅으로 분리

### 📐 Gemini (아키텍처 관점)
- **핵심 주장**: useReducer는 관심사 분리(SoC) 원칙 실현
- **근거**:
  - UI는 "무엇이 발생했는지"만 알림 (action dispatch)
  - reducer는 "어떻게 변경할지" 담당 (순수 함수)
  - 중앙화된 로직으로 유지보수 용이
- **추천 사항**:
  - 처음에는 useState로 시작
  - 상태 로직이 복잡해지거나 여러 상태가 얽히면 useReducer로 리팩토링

### ⚡ Qwen (성능 관점)
- **핵심 주장**: useReducer가 렌더링 최적화에 유리
- **근거**:
  - dispatch는 안정적인 참조 유지 → useCallback 불필요
  - 복잡한 상태 업데이트 시 불필요한 복사 방지
- **추천 사항**:
  - dispatch를 자식 컴포넌트에 전달하는 경우 useReducer 우선
  - 성능 최적화가 중요한 경우 useReducer

---

## ⚖️ 합의점과 충돌점

### ✅ 합의
- **기본은 useState**: 단순한 상태는 useState로 시작
- **점진적 마이그레이션**: useState → useReducer 리팩토링 가능
- **복잡도가 기준**: 복잡해지면 useReducer 도입

### ⚠️ 충돌
- **"복잡함"의 기준이 각각 다름**:
  - Codex: 분기/검증/비동기 처리 등장 시
  - Gemini: 여러 상태가 서로 얽힐 때
  - Qwen: dispatch를 자식에 전달하거나 성능 이슈 발생 시

---

## 🎯 최종 결정

**채택된 방안**: **3-AI 종합 기준** - 다음 3가지 신호 중 하나라도 나타나면 useReducer 검토

1. **업데이트 로직 복잡** (Codex 기준)
   - 분기 처리가 많음
   - 검증 로직이 필요
   - 비동기 후속 처리

2. **상태 간 의존성** (Gemini 기준)
   - 여러 필드가 얽혀 있음
   - 다음 상태가 이전 상태에 의존
   - 관련 상태와 로직이 많음

3. **렌더링 최적화 필요** (Qwen 기준)
   - dispatch를 자식 컴포넌트에 전달
   - 성능 최적화가 중요
   - 불필요한 리렌더링 발생

**근거**:
- 각 AI의 특화 영역 (실무/아키텍처/성능)을 모두 반영
- 명확한 판단 기준 제시
- 실무에서 즉시 적용 가능

**기각된 의견**: 없음
- 3-AI 모두 "단순→useState, 복잡→useReducer"에 합의
- 차이는 "복잡함"의 정의뿐

---

## 📝 실행 내역

**즉시 실행**:
- [x] 가이드라인 문서화 (이 파일)
- [x] 3가지 신호 체크리스트 확립

**향후 계획**:
- [ ] 기존 컴포넌트 리뷰 시 체크리스트 적용
- [ ] 복잡한 상태 발견 시 useReducer 리팩토링 검토

**참고 사항**:
- 이 가이드라인은 React 공식 문서와도 일치
- 팀원들과 공유하여 일관된 코드 스타일 유지

---

**작성**: Claude Code
**검증**: 3-AI 교차검증 (Codex + Gemini + Qwen)
**원본 검증 로그**: logs/ai-cross-verification/2025-10-10/110759-useState-vs-useReducer--/
