/**
 * üéØ ÏãúÏä§ÌÖú ÌÜµÌï© Hook - Phase 1 + 2.1 ÏôÑÏ†Ñ ÌÜµÌï©
 *
 * ‚úÖ Phase 1 Î™®ÎìàÎì§:
 * - RealTimeHub: WebSocket Ïã§ÏãúÍ∞Ñ ÌÜµÏã†
 * - PatternMatcherEngine: Ïù¥ÏÉÅ Ìå®ÌÑ¥ ÌÉêÏßÄ
 * - DataRetentionScheduler: ÏûêÎèô Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
 *
 * ‚úÖ Phase 2.1 Î™®ÎìàÎì§:
 * - NotificationHub: Slack/Discord ÏïåÎ¶º
 *
 * üîÑ ÌÜµÌï© Í∏∞Îä•:
 * - Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ Ïó∞Îèô
 * - ÏûêÎèô ÏïåÎ¶º Î∞úÏÜ°
 * - ÏÉÅÌÉú ÌÜµÌï© Í¥ÄÎ¶¨
 * - UI ÏóÖÎç∞Ïù¥Ìä∏ Ìä∏Î¶¨Í±∞
 */

'use client';

import {
  useCallback,
  useEffect,
  useRef,
  useState,
  useSyncExternalStore,
} from 'react';
// import { useToast } from '@/components/ui/ToastNotification'; // ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå
import { calculateOptimalCollectionInterval } from '@/config/serverConfig';
import {
  MetricDataPoint,
  predictiveAnalysisEngine,
} from '@/engines/PredictiveAnalysisEngine';
// MCP ÏõúÏóÖ ÏÑúÎπÑÏä§ Ï†úÍ±∞Îê® - Google Cloud VM 24ÏãúÍ∞Ñ ÎèôÏûë

// Phase 1 + 2.1 Î™®Îìà ÌÉÄÏûÖ Ï†ïÏùò
interface RealTimeHubStatus {
  isConnected: boolean;
  connectionCount: number;
  activeGroups: string[];
  messageHistory: number;
}

interface PatternMatcherStatus {
  isActive: boolean;
  activeRules: number;
  lastAnalysis: Date | null;
  detectedAnomalies: number;
  averageProcessingTime: number;
}

interface DataRetentionStatus {
  isRunning: boolean;
  lastCleanup: Date | null;
  cleanupInterval: number;
  activePolicies: number;
  cleanedDataPoints: number;
}

interface NotificationStatus {
  isEnabled: boolean;
  channels: {
    slack: boolean;
    discord: boolean;
    email: boolean;
  };
  pendingNotifications: number;
  lastNotification: Date | null;
}

interface SystemStatus {
  initialized: boolean;
  healthy: boolean;
  mcpConnected: boolean;
  aiEngineReady: boolean;
  databaseConnected: boolean;
  lastCheck: string;
  errors: string[];
}

interface SystemIntegrationState {
  // Î™®Îìà ÏÉÅÌÉú
  realTimeHub: RealTimeHubStatus;
  patternMatcher: PatternMatcherStatus;
  dataRetention: DataRetentionStatus;
  notifications: NotificationStatus;

  // ÌÜµÌï© ÏÉÅÌÉú
  overallHealth: 'healthy' | 'warning' | 'critical' | 'offline';
  lastUpdate: Date | null;
  isInitialized: boolean;
  initializationProgress: number;

  // Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏
  recentEvents: SystemEvent[];
  eventCount: number;

  status: SystemStatus;
  isLoading: boolean;
  error: string | null;
}

interface SystemEvent {
  id: string;
  type:
  | 'pattern_detected'
  | 'notification_sent'
  | 'data_cleaned'
  | 'connection_change'
  | 'error'
  | 'prediction'
  | 'server_alert'
  | 'security';
  severity: 'info' | 'warning' | 'critical';
  message: string;
  timestamp: Date;
  metadata?: any;
  source: string;
}

interface SystemIntegrationActions {
  // ÏãúÏä§ÌÖú Ï†úÏñ¥
  initializeSystem: () => Promise<boolean>;
  shutdownSystem: () => Promise<void>;
  restartSystem: () => Promise<boolean>;

  // Î™®ÎìàÎ≥Ñ Ï†úÏñ¥
  testRealTimeHub: () => Promise<boolean>;
  triggerPatternAnalysis: () => Promise<any>;
  forceDataCleanup: () => Promise<any>;
  sendTestNotification: (channel?: string) => Promise<boolean>;

  // ÌÜµÌï© Í∏∞Îä•
  runSystemDiagnostics: () => Promise<any>;
  exportSystemReport: () => Promise<any>;

  // Ïù¥Î≤§Ìä∏ Í¥ÄÎ¶¨
  clearEvents: () => void;
  subscribeToEvents: (callback: (event: SystemEvent) => void) => () => void;
}

const useSystemIntegrationStore = (
  initialState: SystemIntegrationState
): {
  getState: () => SystemIntegrationState;
  setState: (
    newState:
      | SystemIntegrationState
      | ((prev: SystemIntegrationState) => SystemIntegrationState)
  ) => void;
  subscribe: (callback: () => void) => () => void;
} => {
  const [state, setState] = useState<SystemIntegrationState>(initialState);
  const subscribers = useRef<Set<(event: SystemEvent) => void>>(new Set());

  const getState = () => state;

  const subscribe = (callback: () => void) => {
    subscribers.current.add(callback);
    return () => {
      subscribers.current.delete(callback);
    };
  };

  return {
    getState,
    setState,
    subscribe,
  };
};

/**
 * üéØ ÏãúÏä§ÌÖú ÌÜµÌï© Hook
 */
export const useSystemIntegration = () => {
  // const { success, warning, error: showError } = useToast(); // ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå
  const store = useRef(
    useSystemIntegrationStore({
      realTimeHub: {
        isConnected: false,
        connectionCount: 0,
        activeGroups: [],
        messageHistory: 0,
      },
      patternMatcher: {
        isActive: false,
        activeRules: 0,
        lastAnalysis: null,
        detectedAnomalies: 0,
        averageProcessingTime: 0,
      },
      dataRetention: {
        isRunning: false,
        lastCleanup: null,
        cleanupInterval: 300000,
        activePolicies: 0,
        cleanedDataPoints: 0,
      },
      notifications: {
        isEnabled: false,
        channels: {
          slack: false,
          discord: false,
          email: false,
        },
        pendingNotifications: 0,
        lastNotification: null,
      },
      overallHealth: 'offline',
      lastUpdate: null,
      isInitialized: false,
      initializationProgress: 0,
      recentEvents: [],
      eventCount: 0,
      status: {
        initialized: false,
        healthy: false,
        mcpConnected: false,
        aiEngineReady: false,
        databaseConnected: false,
        lastCheck: '',
        errors: []
      },
      isLoading: true,
      error: null,
    })
  ).current;

  const state = useSyncExternalStore(store.subscribe, store.getState);
  const setState = store.setState;
  const getState = store.getState;

  const eventSubscribers = useRef<Set<(event: SystemEvent) => void>>(new Set());
  const pollingInterval = useRef<NodeJS.Timeout | null>(null);
  const eventCounter = useRef(0);

  // üß† ÏòàÏ∏° Î∂ÑÏÑù ÏÉÅÌÉú
  const [predictionResults, setPredictionResults] = useState<{
    [serverId: string]: any;
  }>({});
  const [predictionAccuracy, setPredictionAccuracy] = useState<number>(0);

  /**
   * üîî Ïù¥Î≤§Ìä∏ Î∞úÏÉù Ï≤òÎ¶¨
   */
  const emitEvent = useCallback(
    (
      type: SystemEvent['type'],
      severity: SystemEvent['severity'],
      message: string,
      metadata?: any
    ) => {
      const event: SystemEvent = {
        id: `event_${eventCounter.current++}`,
        type,
        severity,
        message,
        timestamp: new Date(),
        metadata,
        source: 'SystemIntegration',
      };

      setState(prev => ({
        ...prev,
        recentEvents: [event, ...prev.recentEvents].slice(0, 50), // ÏµúÎåÄ 50Í∞ú Ïú†ÏßÄ
        eventCount: prev.eventCount + 1,
      }));

      // Íµ¨ÎèÖÏûêÎì§ÏóêÍ≤å Ïù¥Î≤§Ìä∏ ÏïåÎ¶º
      eventSubscribers.current.forEach(callback => callback(event));

      // UI ÌÜ†Ïä§Ìä∏ ÌëúÏãú
      switch (severity) {
        case 'critical':
          // showError(message);
          break;
        case 'warning':
          // warning(message);
          break;
        case 'info':
          // success(message);
          break;
      }
    },
    []
  );

  /**
   * üìä ÏãúÏä§ÌÖú ÏÉÅÌÉú Ìè¥ÎßÅ
   */
  const pollSystemStatus = useCallback(async () => {
    try {
      // RealTimeHub ÏÉÅÌÉú Ï°∞Ìöå
      const realTimeResponse = await fetch('/api/realtime/connect');
      const realTimeData = await realTimeResponse.json();

      // PatternMatcher ÏÉÅÌÉú Ï°∞Ìöå
      const patternResponse = await fetch('/api/metrics/pattern-check');
      const patternData = await patternResponse.json();

      // DataRetention ÏÉÅÌÉú Ï°∞Ìöå (API ÏÇ≠Ï†úÎê® - Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©)
      const retentionData = {
        success: false,
        data: {
          isActive: false,
          stats: {
            lastCleanup: null,
            interval: 300000,
            totalPolicies: 0,
            totalCleaned: 0,
          },
        },
      };

      // Notifications ÏÉÅÌÉú Ï°∞Ìöå (Phase 2.1)
      let notificationData = { success: false, data: {} };
      try {
        const notificationResponse = await fetch('/api/notifications/status');
        notificationData = await notificationResponse.json();
      } catch (err) {
        console.log('üì± ÏïåÎ¶º ÏÑúÎπÑÏä§ ÎπÑÌôúÏÑ±ÌôîÎê® (Phase 2.1)');
      }

      // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      setState(prev => {
        const newState = {
          ...prev,
          realTimeHub: {
            isConnected: realTimeData.success && realTimeData.data?.isActive,
            connectionCount: realTimeData.data?.stats?.totalConnections || 0,
            activeGroups: realTimeData.data?.stats?.groups || [],
            messageHistory: realTimeData.data?.stats?.messageHistory || 0,
          },
          patternMatcher: {
            isActive: patternData.success && patternData.data?.isActive,
            activeRules: patternData.data?.stats?.totalRules || 0,
            lastAnalysis: patternData.data?.stats?.lastAnalysis
              ? new Date(patternData.data.stats.lastAnalysis)
              : null,
            detectedAnomalies: patternData.data?.stats?.totalAlerts || 0,
            averageProcessingTime:
              patternData.data?.stats?.averageProcessingTime || 0,
          },
          dataRetention: {
            isRunning: retentionData.success && retentionData.data?.isActive,
            lastCleanup: retentionData.data?.stats?.lastCleanup
              ? new Date(retentionData.data.stats.lastCleanup)
              : null,
            cleanupInterval: retentionData.data?.stats?.interval || 300000,
            activePolicies: retentionData.data?.stats?.totalPolicies || 0,
            cleanedDataPoints: retentionData.data?.stats?.totalCleaned || 0,
          },
          notifications: {
            isEnabled: notificationData.success,
            channels: (notificationData.data as any)?.channels || {
              slack: false,
              discord: false,
              email: false,
            },
            pendingNotifications: (notificationData.data as any)?.pending || 0,
            lastNotification: (notificationData.data as any)?.lastSent
              ? new Date((notificationData.data as any).lastSent)
              : null,
          },
          lastUpdate: new Date(),
        };

        // Ï†ÑÏ≤¥ Ìó¨Ïä§ ÏÉÅÌÉú Í≥ÑÏÇ∞
        const healthScores = [
          newState.realTimeHub.isConnected ? 100 : 0,
          newState.patternMatcher.isActive ? 100 : 0,
          newState.dataRetention.isRunning ? 100 : 0,
          newState.notifications.isEnabled ? 100 : 50, // ÏÑ†ÌÉùÏ†Å
        ];

        const averageHealth =
          healthScores.reduce((sum, score) => sum + score, 0) /
          healthScores.length;

        newState.overallHealth =
          averageHealth >= 80
            ? 'healthy'
            : averageHealth >= 60
              ? 'warning'
              : averageHealth >= 30
                ? 'critical'
                : 'offline';

        return newState;
      });
    } catch (error) {
      console.error('‚ùå ÏãúÏä§ÌÖú ÏÉÅÌÉú Ìè¥ÎßÅ Ïã§Ìå®:', error);
      emitEvent('error', 'critical', `ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï°∞Ìöå Ïã§Ìå®: ${error}`);
    }
  }, [emitEvent]);

  /**
   * üöÄ MCP ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏ (Google Cloud VM 24ÏãúÍ∞Ñ ÎèôÏûë)
   */
  const wakeupMCPServer = useCallback(async (): Promise<boolean> => {
    try {
      setState(prev => ({
        ...prev,
        mcpWakeupStatus: {
          isInProgress: true,
          stage: 'connecting',
          message: 'MCP ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏ Ï§ë...',
          progress: 50,
          elapsedTime: 0,
        },
      }));

      // Google Cloud VMÏóêÏÑú 24ÏãúÍ∞Ñ ÎèôÏûëÌïòÎØÄÎ°ú Ï¶âÏãú ready ÏÉÅÌÉúÎ°ú ÏÑ§Ï†ï
      setState(prev => ({
        ...prev,
        mcpWakeupStatus: {
          isInProgress: false,
          stage: 'ready',
          message: '‚úÖ MCP ÏÑúÎ≤ÑÍ∞Ä ÌôúÏÑ± ÏÉÅÌÉúÏûÖÎãàÎã§ (Google Cloud VM 24ÏãúÍ∞Ñ ÎèôÏûë)',
          progress: 100,
          elapsedTime: 100,
        },
      }));

      emitEvent(
        'connection_change',
        'info',
        'üöÄ MCP ÏÑúÎ≤ÑÍ∞Ä Google Cloud VMÏóêÏÑú 24ÏãúÍ∞Ñ ÎèôÏûë Ï§ëÏûÖÎãàÎã§'
      );

      return true;
    } catch (error) {
      setState(prev => ({
        ...prev,
        mcpWakeupStatus: {
          isInProgress: false,
          stage: 'error',
          message: `‚ùå MCP ÏÉÅÌÉú ÌôïÏù∏ Ïò§Î•ò: ${error.message}`,
          progress: 100,
          elapsedTime: 0,
        },
      }));

      emitEvent('error', 'critical', `‚ùå MCP ÏÉÅÌÉú ÌôïÏù∏ Ïò§Î•ò: ${error}`);
      return false;
    }
  }, [emitEvent]);

  /**
   * üöÄ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî (ÌÜµÌï© API ÏÇ¨Ïö©)
   */
  const initializeSystem = useCallback(async (): Promise<boolean> => {
    if (getState().isInitialized) {
      console.log('üëç ÏãúÏä§ÌÖúÏùÄ Ïù¥ÎØ∏ Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.');
      return true;
    }

    if (
      getState().initializationProgress > 0 &&
      getState().initializationProgress < 100
    ) {
      console.log('üîÑ ÏãúÏä§ÌÖúÏù¥ Ïù¥ÎØ∏ Ï¥àÍ∏∞Ìôî Ï§ëÏûÖÎãàÎã§.');
      return false;
    }

    try {
      setState(prev => ({
        ...prev,
        initializationProgress: 10,
        isError: false,
        error: null,
      }));
      emitEvent(
        'connection_change',
        'info',
        '‚öôÔ∏è ÏãúÏä§ÌÖú Ï¥àÍ∏∞ÌôîÎ•º ÏãúÏûëÌï©ÎãàÎã§...'
      );

      const response = await fetch('/api/system/initialize', {
        method: 'POST',
      });

      setState(prev => ({ ...prev, initializationProgress: 70 }));

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          errorData.message ||
          `ÏÑúÎ≤ÑÏóêÏÑú ${response.status} Ïò§Î•òÎ•º Î∞òÌôòÌñàÏäµÎãàÎã§.`
        );
      }

      const result = await response.json();
      console.log('‚úÖ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî Î°úÍ∑∏:', result.logs);

      setState(prev => ({
        ...prev,
        initializationProgress: 100,
        isInitialized: true,
      }));

      emitEvent(
        'connection_change',
        'info',
        'üéâ ÏãúÏä§ÌÖúÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§!'
      );

      // üö® Î¨¥Î£å Ìã∞Ïñ¥ Ï†àÏïΩ: ÏÉÅÌÉú Ìè¥ÎßÅ ÏãúÏûë (5Î∂Ñ Í∞ÑÍ≤©)
      if (pollingInterval.current) clearInterval(pollingInterval.current);
      // üéØ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Í∞ÑÍ≤©Í≥º ÎèôÍ∏∞Ìôî (5-10Î∂Ñ)
      pollingInterval.current = setInterval(
        pollSystemStatus,
        calculateOptimalCollectionInterval()
      );
      await pollSystemStatus();

      return true;
    } catch (error) {
      console.error('‚ùå ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
      setState(prev => ({
        ...prev,
        initializationProgress: 100,
        isInitialized: false,
        isError: true,
        error: error.message,
      }));
      emitEvent('error', 'critical', `ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî Ïã§Ìå®: ${error.message}`);
      return false;
    }
  }, [emitEvent, pollSystemStatus, getState]);

  /**
   * üõë ÏãúÏä§ÌÖú Ï¢ÖÎ£å
   */
  const shutdownSystem = useCallback(async (): Promise<void> => {
    try {
      emitEvent('connection_change', 'info', 'ÏãúÏä§ÌÖú Ï¢ÖÎ£å Ï§ë...');

      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
        pollingInterval.current = null;
      }

      setState(prev => ({
        ...prev,
        isInitialized: false,
        overallHealth: 'offline',
      }));

      emitEvent('connection_change', 'info', '‚úÖ ÏãúÏä§ÌÖú Ï¢ÖÎ£å ÏôÑÎ£å');
    } catch (error) {
      emitEvent('error', 'critical', `‚ùå ÏãúÏä§ÌÖú Ï¢ÖÎ£å Ïã§Ìå®: ${error}`);
    }
  }, [emitEvent]);

  /**
   * üîÑ ÏãúÏä§ÌÖú Ïû¨ÏãúÏûë
   */
  const restartSystem = useCallback(async (): Promise<boolean> => {
    await shutdownSystem();
    await new Promise(resolve => setTimeout(resolve, 2000)); // 2Ï¥à ÎåÄÍ∏∞
    return await initializeSystem();
  }, [shutdownSystem, initializeSystem]);

  /**
   * üß™ Í∞úÎ≥Ñ Î™®Îìà ÌÖåÏä§Ìä∏ Ìï®ÏàòÎì§
   */
  const testRealTimeHub = useCallback(async (): Promise<boolean> => {
    try {
      const response = await fetch('/api/realtime/connect', { method: 'POST' });
      const result = await response.json();

      if (result.success) {
        emitEvent('connection_change', 'info', '‚úÖ RealTimeHub ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ');
        return true;
      } else {
        throw new Error(result.error || 'RealTimeHub ÌÖåÏä§Ìä∏ Ïã§Ìå®');
      }
    } catch (error) {
      emitEvent('error', 'critical', `‚ùå RealTimeHub ÌÖåÏä§Ìä∏ Ïã§Ìå®: ${error}`);
      return false;
    }
  }, [emitEvent]);

  const triggerPatternAnalysis = useCallback(async (): Promise<any> => {
    try {
      const response = await fetch('/api/metrics/pattern-check', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'analyze' }),
      });
      const result = await response.json();

      if (result.success) {
        emitEvent(
          'pattern_detected',
          'info',
          `‚úÖ Ìå®ÌÑ¥ Î∂ÑÏÑù ÏôÑÎ£å: ${result.data?.detectedPatterns || 0}Í∞ú Ìå®ÌÑ¥ Î∞úÍ≤¨`
        );
        return result.data;
      } else {
        throw new Error(result.error || 'Ìå®ÌÑ¥ Î∂ÑÏÑù Ïã§Ìå®');
      }
    } catch (error) {
      emitEvent('error', 'warning', `‚ùå Ìå®ÌÑ¥ Î∂ÑÏÑù Ïã§Ìå®: ${error}`);
      return null;
    }
  }, [emitEvent]);

  const forceDataCleanup = useCallback(async (): Promise<any> => {
    try {
      // API ÏÇ≠Ï†úÎê® - Î∏åÎùºÏö∞Ï†Ä Î©îÎ™®Î¶¨ Ï†ïÎ¶¨Î°ú ÎåÄÏ≤¥
      if (typeof window !== 'undefined' && window.gc) {
        window.gc(); // Chrome DevToolsÏóêÏÑúÎßå Í∞ÄÎä•
      }

      // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ïÎ¶¨
      const beforeSize = localStorage.length;
      Object.keys(localStorage).forEach(key => {
        if (key.startsWith('cache_') || key.startsWith('temp_')) {
          localStorage.removeItem(key);
        }
      });
      const afterSize = localStorage.length;
      const cleanedCount = beforeSize - afterSize;

      emitEvent(
        'data_cleaned',
        'info',
        `‚úÖ Î°úÏª¨ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ ÏôÑÎ£å: ${cleanedCount}Í∞ú Ìï≠Î™© Ï†ïÎ¶¨ (API ÏÇ≠Ï†úÎ°ú Ïù∏Ìïú ÎåÄÏ≤¥ Í∏∞Îä•)`
      );

      return { cleanedCount, type: 'local_cleanup' };
    } catch (error) {
      emitEvent('error', 'warning', `‚ùå Î°úÏª¨ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ Ïã§Ìå®: ${error}`);
      return null;
    }
  }, [emitEvent]);

  const sendTestNotification = useCallback(
    async (channel?: string): Promise<boolean> => {
      try {
        const response = await fetch('/api/notifications/test', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            channel: channel || 'all',
            message: 'üß™ ÏãúÏä§ÌÖú ÌÜµÌï© ÌÖåÏä§Ìä∏ ÏïåÎ¶º',
          }),
        });
        const result = await response.json();

        if (result.success) {
          emitEvent(
            'notification_sent',
            'info',
            `‚úÖ ÌÖåÏä§Ìä∏ ÏïåÎ¶º Î∞úÏÜ° ÏÑ±Í≥µ (${channel || 'all'})`
          );
          return true;
        } else {
          throw new Error(result.error || 'ÏïåÎ¶º Î∞úÏÜ° Ïã§Ìå®');
        }
      } catch (error) {
        emitEvent('error', 'warning', `‚ùå ÌÖåÏä§Ìä∏ ÏïåÎ¶º Ïã§Ìå®: ${error}`);
        return false;
      }
    },
    [emitEvent]
  );

  /**
   * üîç ÏãúÏä§ÌÖú ÏßÑÎã®
   */
  const runSystemDiagnostics = useCallback(async (): Promise<any> => {
    try {
      emitEvent('connection_change', 'info', 'üîç ÏãúÏä§ÌÖú ÏßÑÎã® ÏãúÏûë...');

      const diagnostics = {
        realTimeHub: await testRealTimeHub(),
        patternMatcher: await triggerPatternAnalysis(),
        dataRetention: await forceDataCleanup(),
        notifications: await sendTestNotification(),
        timestamp: new Date(),
        overallScore: 0,
      };

      // Ï†ÑÏ≤¥ Ï†êÏàò Í≥ÑÏÇ∞
      const scores = [
        diagnostics.realTimeHub ? 25 : 0,
        diagnostics.patternMatcher ? 25 : 0,
        diagnostics.dataRetention ? 25 : 0,
        diagnostics.notifications ? 25 : 0,
      ];
      diagnostics.overallScore = scores.reduce((sum, score) => sum + score, 0);

      emitEvent(
        'connection_change',
        diagnostics.overallScore >= 75 ? 'info' : 'warning',
        `üîç ÏãúÏä§ÌÖú ÏßÑÎã® ÏôÑÎ£å: ${diagnostics.overallScore}/100Ï†ê`
      );

      return diagnostics;
    } catch (error) {
      emitEvent('error', 'critical', `‚ùå ÏãúÏä§ÌÖú ÏßÑÎã® Ïã§Ìå®: ${error}`);
      return null;
    }
  }, [
    testRealTimeHub,
    triggerPatternAnalysis,
    forceDataCleanup,
    sendTestNotification,
    emitEvent,
  ]);

  /**
   * üìã ÏãúÏä§ÌÖú Î¶¨Ìè¨Ìä∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
   */
  const exportSystemReport = useCallback(async (): Promise<any> => {
    const report = {
      timestamp: new Date(),
      systemState: state,
      recentEvents: state.recentEvents.slice(0, 20),
      summary: {
        uptime: state.lastUpdate ? Date.now() - state.lastUpdate.getTime() : 0,
        totalEvents: state.eventCount,
        criticalEvents: state.recentEvents.filter(
          e => e.severity === 'critical'
        ).length,
        warningEvents: state.recentEvents.filter(e => e.severity === 'warning')
          .length,
        moduleStatus: {
          realTimeHub: state.realTimeHub.isConnected,
          patternMatcher: state.patternMatcher.isActive,
          dataRetention: state.dataRetention.isRunning,
          notifications: state.notifications.isEnabled,
        },
      },
    };

    emitEvent('connection_change', 'info', 'üìã ÏãúÏä§ÌÖú Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å');
    return report;
  }, [state, emitEvent]);

  /**
   * üîî Ïù¥Î≤§Ìä∏ Í¥ÄÎ¶¨
   */
  const clearEvents = useCallback(() => {
    setState(prev => ({ ...prev, recentEvents: [], eventCount: 0 }));
    emitEvent('connection_change', 'info', 'üßπ Ïù¥Î≤§Ìä∏ ÌûàÏä§ÌÜ†Î¶¨ Ï†ïÎ¶¨ ÏôÑÎ£å');
  }, [emitEvent]);

  const subscribeToEvents = useCallback(
    (callback: (event: SystemEvent) => void) => {
      eventSubscribers.current.add(callback);
      return () => {
        eventSubscribers.current.delete(callback);
      };
    },
    []
  );

  /**
   * üß† ÏòàÏ∏° Î∂ÑÏÑù ÏóîÏßÑ Ïó∞Îèô
   */
  const runPredictionAnalysis = useCallback(
    async (serverId?: string) => {
      try {
        // ÌòÑÏû¨ Î©îÌä∏Î¶≠ Îç∞Ïù¥ÌÑ∞Î•º ÏòàÏ∏° ÏóîÏßÑÏóê Ï∂îÍ∞Ä
        const currentMetrics: MetricDataPoint = {
          timestamp: new Date(),
          cpu: Math.random() * 80 + 10, // Ïã§Ï†ú ÌôòÍ≤ΩÏóêÏÑúÎäî Ïã§Ï†ú Î©îÌä∏Î¶≠ ÏÇ¨Ïö©
          memory: Math.random() * 70 + 20,
          disk: Math.random() * 60 + 30,
          network: Math.random() * 50 + 10,
          errorRate: Math.random() * 5,
          responseTime: Math.random() * 1000 + 100,
        };

        const targetServerId = serverId || 'web-server-01';
        const prediction = await predictiveAnalysisEngine.addDataPoint(
          targetServerId,
          currentMetrics
        );

        if (prediction) {
          setPredictionResults(prev => ({
            ...prev,
            [targetServerId]: prediction,
          }));

          // ÎÜíÏùÄ ÏúÑÌóòÎèÑÏùº Í≤ΩÏö∞ ÏïåÎ¶º ÏÉùÏÑ±
          if (prediction.failureProbability > 70) {
            emitEvent(
              'prediction',
              prediction.severity === 'critical' ? 'critical' : 'warning',
              `${targetServerId}ÏóêÏÑú ${Math.round(prediction.failureProbability)}% Ïû•Ïï† ÌôïÎ•† ÏòàÏ∏°Îê®`,
              {
                serverId: targetServerId,
                predictedTime: prediction.predictedTime,
                triggerMetrics: prediction.triggerMetrics,
                preventiveActions: prediction.preventiveActions,
              }
            );
          }
        }

        // ÏòàÏ∏° Ï†ïÌôïÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
        const accuracy = await predictiveAnalysisEngine.calculateAccuracy();
        setPredictionAccuracy(accuracy.overall);
      } catch (error) {
        console.error('üß† ÏòàÏ∏° Î∂ÑÏÑù Ïò§Î•ò:', error);
        emitEvent(
          'error',
          'warning',
          'ÏòàÏ∏° Î∂ÑÏÑù ÏóîÏßÑÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§',
          { error: error instanceof Error ? error.message : String(error) }
        );
      }
    },
    [emitEvent]
  );

  // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ï†ïÎ¶¨
  useEffect(() => {
    return () => {
      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
      }
    };
  }, []);

  // üß† Ï£ºÍ∏∞Ï†Å ÏòàÏ∏° Î∂ÑÏÑù Ïã§Ìñâ
  useEffect(() => {
    if (state.realTimeHub.isConnected) {
      const interval = setInterval(() => {
        runPredictionAnalysis();
      }, 30000); // 30Ï¥àÎßàÎã§ ÏòàÏ∏° Î∂ÑÏÑù

      return () => clearInterval(interval);
    }
  }, [state.realTimeHub.isConnected, runPredictionAnalysis]);

  const actions: SystemIntegrationActions = {
    initializeSystem,
    shutdownSystem,
    restartSystem,
    testRealTimeHub,
    triggerPatternAnalysis,
    forceDataCleanup,
    sendTestNotification,
    runSystemDiagnostics,
    exportSystemReport,
    clearEvents,
    subscribeToEvents,
  };

  return {
    ...state,
    ...actions,

    // Ìé∏Ïùò ÏÜçÏÑ±Îì§
    isHealthy: state.overallHealth === 'healthy',
    hasWarnings: state.overallHealth === 'warning',
    isCritical: state.overallHealth === 'critical',
    isOffline: state.overallHealth === 'offline',

    // ÌÜµÍ≥Ñ
    moduleCount: {
      total: 4,
      active: [
        state.realTimeHub.isConnected,
        state.patternMatcher.isActive,
        state.dataRetention.isRunning,
        state.notifications.isEnabled,
      ].filter(Boolean).length,
    },

    eventStats: {
      total: state.eventCount,
      critical: state.recentEvents.filter(e => e.severity === 'critical')
        .length,
      warning: state.recentEvents.filter(e => e.severity === 'warning').length,
      info: state.recentEvents.filter(e => e.severity === 'info').length,
    },

    // üß† ÏòàÏ∏° Î∂ÑÏÑù Í¥ÄÎ†®
    predictionResults,
    predictionAccuracy,
    runPredictionAnalysis,
  };
};

export type { SystemEvent, SystemIntegrationActions, SystemIntegrationState };

