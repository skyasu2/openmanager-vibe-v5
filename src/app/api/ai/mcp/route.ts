/**
 * ğŸ§  MCP (Model Context Protocol) API ì—”ë“œí¬ì¸íŠ¸
 * 
 * ì»¨í…ìŠ¤íŠ¸ ì¸ì‹ ê¸°ë°˜ í†µí•© AI ë¶„ì„
 * - ìì—°ì–´ ì¿¼ë¦¬ ì²˜ë¦¬
 * - ë‹¤ì¤‘ ë„êµ¬ ì²´ì¸ ì‹¤í–‰
 * - ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì˜ì‚¬ê²°ì •
 */

import { NextRequest, NextResponse } from 'next/server';
import { MCPOrchestrator, MCPRequest } from '../../../../core/mcp/mcp-orchestrator';

// MCP ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
let mcpOrchestrator: MCPOrchestrator | null = null;

function getMCPOrchestrator(): MCPOrchestrator {
  if (!mcpOrchestrator) {
    console.log('ğŸ§  MCP ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì´ˆê¸°í™”...');
    mcpOrchestrator = new MCPOrchestrator();
  }
  return mcpOrchestrator;
}

/**
 * ğŸ¯ MCP ë¶„ì„ ìš”ì²­ ì²˜ë¦¬
 */
export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    const body = await request.json();
    
    console.log('ğŸ§  MCP ìš”ì²­ ìˆ˜ì‹ :', {
      query: body.query?.substring(0, 50) + '...',
      hasMetrics: !!body.parameters?.metrics,
      sessionId: body.context?.session_id
    });

    // MCP ìš”ì²­ ê°ì²´ êµ¬ì„±
    const mcpRequest: MCPRequest = {
      query: body.query || 'ì‹œìŠ¤í…œ ìƒíƒœë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”',
      parameters: body.parameters || {},
      context: {
        session_id: body.context?.session_id,
        user_preferences: body.context?.user_preferences || {},
        urgency: body.context?.urgency || 'medium'
      }
    };

    // MCP ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‹¤í–‰
    const orchestrator = getMCPOrchestrator();
    const result = await orchestrator.process(mcpRequest);

    const totalTime = Date.now() - startTime;

    console.log('âœ… MCP ë¶„ì„ ì™„ë£Œ:', {
      toolsUsed: result.tools_used,
      confidence: result.confidence,
      totalTime
    });

    return NextResponse.json({
      success: true,
      data: result.result,
      metadata: {
        tools_used: result.tools_used,
        context_id: result.context_id,
        processing_time: result.processing_time,
        confidence: result.confidence,
        total_time: totalTime
      }
    });

  } catch (error: any) {
    console.error('âŒ MCP ì²˜ë¦¬ ì˜¤ë¥˜:', error);

    return NextResponse.json({
      success: false,
      error: 'MCP ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
      message: error.message,
      processing_time: Date.now() - startTime
    }, { status: 500 });
  }
}

/**
 * ğŸ¥ MCP ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸
 */
export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const action = url.searchParams.get('action');

    if (action === 'health') {
      const orchestrator = getMCPOrchestrator();
      
      return NextResponse.json({
        status: 'healthy',
        message: 'MCP ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ ì •ìƒ ë™ì‘ ì¤‘ì…ë‹ˆë‹¤',
        timestamp: new Date().toISOString(),
        tools_registered: 6, // statistical_analysis, anomaly_detection, time_series_forecast, pattern_recognition, root_cause_analysis, optimization_advisor
        context_active: true
      });
    }

    if (action === 'tools') {
      return NextResponse.json({
        tools: [
          'statistical_analysis',
          'anomaly_detection', 
          'time_series_forecast',
          'pattern_recognition',
          'root_cause_analysis',
          'optimization_advisor'
        ],
        description: 'MCP ë“±ë¡ëœ ë„êµ¬ ëª©ë¡'
      });
    }

    return NextResponse.json({
      service: 'MCP Orchestrator',
      version: '1.0.0',
      endpoints: {
        'POST /': 'MCP ë¶„ì„ ìš”ì²­',
        'GET /?action=health': 'ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸',
        'GET /?action=tools': 'ë“±ë¡ëœ ë„êµ¬ ëª©ë¡'
      }
    });

  } catch (error: any) {
    return NextResponse.json({
      error: 'MCP ìƒíƒœ í™•ì¸ ì‹¤íŒ¨',
      message: error.message
    }, { status: 500 });
  }
} 