/**
 * ğŸ” Authentication Service
 *
 * AI ì—ì´ì „íŠ¸ ì¸ì¦ ë° ë³´ì•ˆ ê´€ë¦¬ ì„œë¹„ìŠ¤
 *
 * @created 2025-06-09
 * @author AI Assistant
 */

import type { ApiResponse, AuthenticationState } from '../types/ProfileTypes';

interface ProfileStore {
  authenticateAIAgent(
    password: string
  ): Promise<{ success: boolean; data?: AuthenticationState }>;
  updateAuthState(auth: AuthenticationState): void;
  agentLocked: boolean;
  apiKey?: string;
  isLocked: boolean;
  getRemainingLockTime(): number;
  attempts: number;
  disableAIAgent(): Promise<{ success: boolean; error?: string; data?: AuthenticationState }>;
  adminMode?: {
    isAuthenticated: boolean;
  };
}

// ê°œë°œ í™˜ê²½ ì„¤ì •
const DEVELOPMENT_MODE =
  process.env.NEXT_PUBLIC_NODE_ENV === 'development' ||
  process.env.NODE_ENV === 'development' ||
  typeof window !== 'undefined';
const BYPASS_PASSWORD = true; // í•­ìƒ ë¹„ë°€ë²ˆí˜¸ ìš°íšŒ í—ˆìš©

export class AuthenticationService {
  private static instance: AuthenticationService;
  private lockTimeouts: Map<string, NodeJS.Timeout> = new Map();

  public static getInstance(): AuthenticationService {
    if (!AuthenticationService.instance) {
      AuthenticationService.instance = new AuthenticationService();
    }
    return AuthenticationService.instance;
  }

  /**
   * ë¹ ë¥¸ í™œì„±í™” (ê°œë°œ ëª¨ë“œìš©)
   */
  quickActivation(): Promise<ApiResponse> {
    if (!DEVELOPMENT_MODE || !BYPASS_PASSWORD) {
      return Promise.resolve({
        success: false,
        error: 'ë¹ ë¥¸ í™œì„±í™”ëŠ” ê°œë°œ ëª¨ë“œì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.',
      });
    }

    try {
      // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ì¦‰ì‹œ ì¸ì¦ ì„±ê³µ ì²˜ë¦¬
      return Promise.resolve({
        success: true,
        message: 'ğŸš€ AI ì—ì´ì „íŠ¸ê°€ ë¹ ë¥´ê²Œ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤!',
        data: { mode: 'quick-activation', timestamp: new Date().toISOString() },
      });
    } catch (_error) {
      return Promise.resolve({
        success: false,
        error: 'ë¹ ë¥¸ í™œì„±í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
      });
    }
  }

  /**
   * AI ì—ì´ì „íŠ¸ ì¸ì¦
   */
  async authenticateAIAgent(
    password: string,
    store: ProfileStore
  ): Promise<ApiResponse> {
    try {
      // ê°œë°œ ëª¨ë“œì—ì„œ ë¹„ë°€ë²ˆí˜¸ ìš°íšŒ
      if (DEVELOPMENT_MODE && BYPASS_PASSWORD) {
        const result = await store.authenticateAIAgent('dev-mode');

        if (result.success) {
          return {
            success: true,
            message: 'ğŸ”“ ê°œë°œ ëª¨ë“œ: AI ì—ì´ì „íŠ¸ ì¸ì¦ ì„±ê³µ',
            data: result.data,
          };
        }
      }

      // ì¼ë°˜ ì¸ì¦ ë¡œì§
      if (!password || password.trim().length === 0) {
        return {
          success: false,
          error: 'ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.',
        };
      }

      const result = await store.authenticateAIAgent(password);

      if (result.success) {
        return {
          success: true,
          message: 'âœ… AI ì—ì´ì „íŠ¸ ì¸ì¦ ì„±ê³µ',
          data: result.data,
        };
      } else {
        // ì‹¤íŒ¨ ì‹œ ì ê¸ˆ í™•ì¸
        if (store.isLocked) {
          const remainingTime = store.getRemainingLockTime();
          return {
            success: false,
            error: `ğŸ”’ ë„ˆë¬´ ë§ì€ ì‹¤íŒ¨ë¡œ ì ê¸ˆë¨ (${Math.ceil(remainingTime / 1000)}ì´ˆ ë‚¨ìŒ)`,
          };
        } else {
          const attemptsLeft = Math.max(0, 3 - store.attempts);
          return {
            success: false,
            error: `âŒ ì¸ì¦ ì‹¤íŒ¨ (${attemptsLeft}íšŒ ë‚¨ìŒ)`,
          };
        }
      }
    } catch (_error) {
      console.error('AI ì—ì´ì „íŠ¸ ì¸ì¦ ì˜¤ë¥˜:', error);
      return {
        success: false,
        error: 'ì¸ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
      };
    }
  }

  /**
   * AI ì—ì´ì „íŠ¸ ë¹„í™œì„±í™”
   */
  async disableAIAgent(store: ProfileStore): Promise<ApiResponse> {
    try {
      const result = await store.disableAIAgent();

      if (result.success) {
        return {
          success: true,
          message: 'ğŸ›‘ AI ì—ì´ì „íŠ¸ê°€ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.',
          data: result.data,
        };
      } else {
        return {
          success: false,
          error: result.error || 'AI ì—ì´ì „íŠ¸ ë¹„í™œì„±í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
        };
      }
    } catch (_error) {
      console.error('AI ì—ì´ì „íŠ¸ ë¹„í™œì„±í™” ì˜¤ë¥˜:', error);
      return {
        success: false,
        error: 'ë¹„í™œì„±í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
      };
    }
  }

  /**
   * ì¸ì¦ ìƒíƒœ í™•ì¸
   */
  getAuthenticationState(store: ProfileStore): AuthenticationState {
    return {
      attempts: store.attempts || 0,
      isLocked: store.isLocked || false,
      isAuthenticated: store.adminMode?.isAuthenticated || false,
      isAuthenticating: false, // ì»´í¬ë„ŒíŠ¸ì—ì„œ ê´€ë¦¬
      showPassword: false, // ì»´í¬ë„ŒíŠ¸ì—ì„œ ê´€ë¦¬
    };
  }

  /**
   * ë‚¨ì€ ì ê¸ˆ ì‹œê°„ ê³„ì‚°
   */
  getRemainingLockTime(store: ProfileStore): number {
    if (!store.isLocked) return 0;
    return store.getRemainingLockTime();
  }

  /**
   * ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
   */
  validatePassword(password: string): { isValid: boolean; message?: string } {
    if (!password || password.trim().length === 0) {
      return { isValid: false, message: 'ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.' };
    }

    if (password.length < 4) {
      return {
        isValid: false,
        message: 'ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 4ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.',
      };
    }

    return { isValid: true };
  }

  /**
   * ê°œë°œ ëª¨ë“œ í™•ì¸
   */
  isDevelopmentMode(): boolean {
    return DEVELOPMENT_MODE;
  }

  /**
   * ë¹„ë°€ë²ˆí˜¸ ìš°íšŒ ê°€ëŠ¥ ì—¬ë¶€
   */
  canBypassPassword(): boolean {
    return BYPASS_PASSWORD && DEVELOPMENT_MODE;
  }

  /**
   * ìë™ ì ê¸ˆ í•´ì œ íƒ€ì´ë¨¸ ì„¤ì •
   */
  setAutoUnlockTimer(
    userId: string,
    duration: number,
    callback: () => void
  ): void {
    // ê¸°ì¡´ íƒ€ì´ë¨¸ê°€ ìˆë‹¤ë©´ ì œê±°
    if (this.lockTimeouts.has(userId)) {
      clearTimeout(this.lockTimeouts.get(userId));
    }

    // ìƒˆ íƒ€ì´ë¨¸ ì„¤ì •
    const timeoutId = setTimeout(() => {
      callback();
      this.lockTimeouts.delete(userId);
    }, duration);

    this.lockTimeouts.set(userId, timeoutId);
  }

  /**
   * ì ê¸ˆ í•´ì œ íƒ€ì´ë¨¸ ì œê±°
   */
  clearAutoUnlockTimer(userId: string): void {
    if (this.lockTimeouts.has(userId)) {
      clearTimeout(this.lockTimeouts.get(userId));
      this.lockTimeouts.delete(userId);
    }
  }

  /**
   * ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬
   */
  clearAllTimers(): void {
    this.lockTimeouts.forEach((timeoutId) => {
      clearTimeout(timeoutId);
    });
    this.lockTimeouts.clear();
  }

  /**
   * ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…
   */
  logSecurityEvent(event: string, details: unknown): void {
    const logEntry = {
      timestamp: new Date().toISOString(),
      event,
      details,
      userAgent:
        typeof window !== 'undefined' ? window.navigator.userAgent : 'server',
      ip: 'local', // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” IP ì¶”ì  ê°€ëŠ¥
    };

    console.log('ğŸ”’ ë³´ì•ˆ ì´ë²¤íŠ¸:', logEntry);

    // í•„ìš”ì‹œ ì„œë²„ë¡œ ë³´ì•ˆ ë¡œê·¸ ì „ì†¡
    if (event === 'auth_failure' || event === 'account_locked') {
      void this.sendSecurityLog(logEntry);
    }
  }

  /**
   * ë³´ì•ˆ ë¡œê·¸ ì„œë²„ ì „ì†¡
   */
  private async sendSecurityLog(logEntry: unknown): Promise<void> {
    try {
      await fetch('/api/security/log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(logEntry),
      });
    } catch (_error) {
      console.warn('ë³´ì•ˆ ë¡œê·¸ ì „ì†¡ ì‹¤íŒ¨:', error);
    }
  }
}
