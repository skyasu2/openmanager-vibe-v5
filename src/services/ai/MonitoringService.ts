export interface PerformanceMetrics {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
  requestsPerMinute: number;
  lastRequestTime: number;
  lastSuccessTime: number;
  successRate: number;
}

export interface SystemHealth {
  status: 'healthy' | 'degraded' | 'unhealthy';
  pythonServiceStatus: 'up' | 'down' | 'slow';
  jsEnginesStatus: 'up' | 'down' | 'partial';
  lastHealthCheck: string;
  uptime: number;
}

export interface ErrorReport {
  timestamp: string;
  type: 'request_failure' | 'engine_failure' | 'timeout' | 'system_error';
  message: string;
  stack?: string;
  context?: any;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export class MonitoringService {
  private performanceMetrics: PerformanceMetrics = {
    totalRequests: 0,
    successfulRequests: 0,
    failedRequests: 0,
    averageResponseTime: 0,
    requestsPerMinute: 0,
    lastRequestTime: 0,
    lastSuccessTime: 0,
    successRate: 1.0
  };
  private systemHealth: SystemHealth = {
    status: 'healthy',
    pythonServiceStatus: 'up',
    jsEnginesStatus: 'up',
    lastHealthCheck: new Date().toISOString(),
    uptime: 0
  };
  private errorReports: ErrorReport[] = [];
  private responseTimesBuffer: number[] = [];
  private requestBuffer: Array<{ timestamp: number; success: boolean; responseTime: number; engine: string }> = [];
  private startTime: number;

  constructor() {
    this.startTime = Date.now();
    console.log('üìä [MonitoringService] Ï¥àÍ∏∞Ìôî ÏôÑÎ£å - Google Cloud VM 24ÏãúÍ∞Ñ ÎèôÏûë');

    // üîÑ Ï£ºÍ∏∞Ï†Å Î©îÌä∏Î¶≠ Ï†ïÎ¶¨ (5Î∂ÑÎßàÎã§)
    setInterval(() => {
      this.cleanupMetrics();
    }, 5 * 60 * 1000);
  }

  /**
   * üìä ÏöîÏ≤≠ Í∏∞Î°ù
   */
  recordRequest(success: boolean, responseTime: number, engine: string) {
    const timestamp = Date.now();

    // ÏÑ±Îä• Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
    this.performanceMetrics.totalRequests++;
    if (success) {
      this.performanceMetrics.successfulRequests++;
      this.performanceMetrics.lastSuccessTime = timestamp;
    } else {
      this.performanceMetrics.failedRequests++;
    }

    this.performanceMetrics.lastRequestTime = timestamp;
    this.performanceMetrics.successRate = this.performanceMetrics.successfulRequests / this.performanceMetrics.totalRequests;

    // ÏùëÎãµÏãúÍ∞Ñ Î≤ÑÌçº ÏóÖÎç∞Ïù¥Ìä∏
    this.responseTimesBuffer.push(responseTime);
    if (this.responseTimesBuffer.length > 100) {
      this.responseTimesBuffer = this.responseTimesBuffer.slice(-100);
    }

    // ÏöîÏ≤≠ Î≤ÑÌçº ÏóÖÎç∞Ïù¥Ìä∏
    this.requestBuffer.push({ timestamp, success, responseTime, engine });
    if (this.requestBuffer.length > 1000) {
      this.requestBuffer = this.requestBuffer.slice(-1000);
    }

    // Î©îÌä∏Î¶≠ Í≥ÑÏÇ∞
    this.updateResponseTimeMetrics();
    this.calculateRequestsPerMinute();
  }

  private updateResponseTimeMetrics() {
    if (this.responseTimesBuffer.length === 0) return;

    const sorted = [...this.responseTimesBuffer].sort((a, b) => a - b);
    const total = sorted.reduce((sum, time) => sum + time, 0);

    this.performanceMetrics.averageResponseTime = total / sorted.length;
  }

  private calculateRequestsPerMinute() {
    const oneMinuteAgo = Date.now() - 60 * 1000;
    const recentRequests = this.requestBuffer.filter(req => req.timestamp > oneMinuteAgo);
    this.performanceMetrics.requestsPerMinute = recentRequests.length;
  }

  /**
   * ‚ùå ÏóêÎü¨ Î≥¥Í≥†ÏÑú Ï∂îÍ∞Ä
   */
  addErrorReport(error: Omit<ErrorReport, 'timestamp'> & { timestamp?: string }) {
    const errorReport: ErrorReport = {
      timestamp: error.timestamp || new Date().toISOString(),
      type: error.type,
      message: error.message,
      stack: error.stack,
      context: error.context,
      severity: error.severity
    };

    this.errorReports.push(errorReport);

    // ÏµúÍ∑º 100Í∞úÎßå Ïú†ÏßÄ
    if (this.errorReports.length > 100) {
      this.errorReports = this.errorReports.slice(-100);
    }
  }

  /**
   * üè• ÏãúÏä§ÌÖú Ìó¨Ïä§ ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateSystemHealth(pythonStatus: 'up' | 'down' | 'slow', jsEnginesStatus: 'up' | 'down' | 'partial') {
    this.systemHealth.pythonServiceStatus = pythonStatus;
    this.systemHealth.jsEnginesStatus = jsEnginesStatus;
    this.systemHealth.lastHealthCheck = new Date().toISOString();
    this.systemHealth.uptime = Date.now() - this.startTime;

    // üîß Ï†ÑÏ≤¥ ÏãúÏä§ÌÖú ÏÉÅÌÉú Í≤∞Ï†ï - Python ÏÑúÎπÑÏä§Î•º ÏòµÏÖîÎÑêÎ°ú Ï≤òÎ¶¨
    const criticalErrors = this.errorReports.filter(e => e.severity === 'critical').length;
    const recentFailureRate = this.calculateRecentFailureRate();

    // ‚úÖ Python ÏÑúÎπÑÏä§Îäî Îçî Ïù¥ÏÉÅ Ï†ÑÏ≤¥ ÏãúÏä§ÌÖú ÏÉÅÌÉúÏóê ÏòÅÌñ•Ï£ºÏßÄ ÏïäÏùå (ÏòµÏÖîÎÑê AI Í∏∞Îä•)
    if (criticalErrors > 0 || recentFailureRate > 0.5) {
      this.systemHealth.status = 'unhealthy';
    } else if (recentFailureRate > 0.2 || jsEnginesStatus === 'partial') {
      this.systemHealth.status = 'degraded';
    } else {
      this.systemHealth.status = 'healthy';
    }

    // üîî Python ÏÑúÎπÑÏä§ ÏÉÅÌÉúÎäî Î≥ÑÎèÑ Í≤ΩÍ≥†Î°úÎßå Ï≤òÎ¶¨
    if (pythonStatus === 'down') {
      console.warn('‚ö†Ô∏è [MonitoringService] Python AI ÏÑúÎπÑÏä§ ÎπÑÌôúÏÑ±Ìôî - Í∏∞Î≥∏ Î™®ÎãàÌÑ∞ÎßÅÏùÄ Ï†ïÏÉÅ ÎèôÏûë');
    } else if (pythonStatus === 'slow') {
      console.warn('‚ö†Ô∏è [MonitoringService] Python AI ÏÑúÎπÑÏä§ ÏùëÎãµ ÏßÄÏó∞ - Í∏∞Î≥∏ Î™®ÎãàÌÑ∞ÎßÅÏùÄ Ï†ïÏÉÅ ÎèôÏûë');
    }
  }

  private calculateRecentFailureRate(): number {
    const recentRequests = this.requestBuffer.filter(req => req.timestamp > Date.now() - 5 * 60 * 1000);
    if (recentRequests.length === 0) return 0;

    const failures = recentRequests.filter(req => !req.success).length;
    return failures / recentRequests.length;
  }

  /**
   * üìà Ï†ÑÏ≤¥ Î©îÌä∏Î¶≠ Ï°∞Ìöå
   */
  getAllMetrics() {
    return {
      performance: this.performanceMetrics,
      health: this.systemHealth,
      errors: this.errorReports.slice(-10), // ÏµúÍ∑º 10Í∞ú ÏóêÎü¨Îßå
      summary: {
        totalUptime: Date.now() - this.startTime,
        overallSuccessRate: this.performanceMetrics.totalRequests > 0 ?
          this.performanceMetrics.successfulRequests / this.performanceMetrics.totalRequests : 1,
        systemStatus: this.systemHealth.status
      }
    };
  }

  /**
   * üîç Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìñâ (ÏÑúÎ≤ÑÎ¶¨Ïä§ ÏµúÏ†ÅÌôî)
   */
  async performHealthCheck(): Promise<any> {
    const isVercel = process.env.VERCEL === '1';
    const healthChecks: any[] = [];

    if (isVercel) {
      // üö´ ÏÑúÎ≤ÑÎ¶¨Ïä§ ÌôòÍ≤Ω: Ïô∏Î∂Ä API Ìò∏Ï∂ú ÏµúÏÜåÌôî
      console.warn('‚ö†Ô∏è ÏÑúÎ≤ÑÎ¶¨Ïä§ ÌôòÍ≤ΩÏóêÏÑú Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏµúÏ†ÅÌôîÎê®');

      healthChecks.push({
        name: 'ÏÑúÎ≤ÑÎ¶¨Ïä§ Ìï®Ïàò (ÌïµÏã¨)',
        status: 'healthy',
        responseTime: 0,
        details: 'Vercel ÏÑúÎ≤ÑÎ¶¨Ïä§ Ìï®Ïàò Ï†ïÏÉÅ ÎèôÏûë',
        optional: false
      });

      healthChecks.push({
        name: 'Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú (ÌïµÏã¨)',
        status: 'healthy',
        responseTime: 0,
        details: 'API ÏÑúÎ≤Ñ Ï†ïÏÉÅ ÎèôÏûë',
        optional: false
      });

      // üö´ Python ÏÑúÎπÑÏä§ Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏÉùÎûµ (API Ìï†ÎãπÎüâ Ï†àÏïΩ)
      healthChecks.push({
        name: 'Python AI ÏÑúÎπÑÏä§ (ÏòµÏÖîÎÑê)',
        status: 'skipped',
        responseTime: 0,
        details: 'ÏÑúÎ≤ÑÎ¶¨Ïä§ ÌôòÍ≤ΩÏóêÏÑú Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏÉùÎûµ - ÌïÑÏöîÏãú ÏöîÏ≤≠Î≥Ñ ÌôïÏù∏',
        optional: true
      });

      return {
        status: 'healthy',
        checks: healthChecks,
        totalResponseTime: 0,
        coreServicesHealthy: true,
        optionalServicesCount: 1,
        message: 'ÏÑúÎ≤ÑÎ¶¨Ïä§ ÌôòÍ≤ΩÏóêÏÑú ÌïµÏã¨ Í∏∞Îä• Ï†ïÏÉÅ ÎèôÏûë',
        timestamp: new Date().toISOString(),
        environment: 'serverless'
      };
    }

    // üîß Î°úÏª¨ ÌôòÍ≤ΩÏóêÏÑúÎßå Ïã§Ï†ú Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏàòÌñâ
    try {
      const pythonServiceUrl = process.env.FASTAPI_BASE_URL || 'https://openmanager-ai-engine.onrender.com';
      const startTime = Date.now();

      const response = await fetch(`${pythonServiceUrl}/health`, {
        signal: AbortSignal.timeout(10000)
      });

      const responseTime = Date.now() - startTime;

      healthChecks.push({
        name: 'Python AI ÏÑúÎπÑÏä§ (ÏòµÏÖîÎÑê)',
        status: response.ok ? 'healthy' : 'unhealthy',
        responseTime,
        details: response.ok ? 'AI Í∏∞Îä• ÏÇ¨Ïö© Í∞ÄÎä•' : `HTTP ${response.status} - AI Í∏∞Îä• Ï†úÌïúÏ†Å`,
        optional: true
      });

      this.updateSystemHealth(
        response.ok ? (responseTime > 5000 ? 'slow' : 'up') : 'down',
        'up' // JS ÏóîÏßÑÏùÄ Ìï≠ÏÉÅ up (Î°úÏª¨ Ïã§Ìñâ)
      );

    } catch (error: any) {
      healthChecks.push({
        name: 'Python AI ÏÑúÎπÑÏä§ (ÏòµÏÖîÎÑê)',
        status: 'unhealthy',
        responseTime: 10000,
        details: `${error.message} - Í∏∞Î≥∏ Î™®ÎãàÌÑ∞ÎßÅÏùÄ Ï†ïÏÉÅ ÎèôÏûë`,
        optional: true
      });

      // ‚úÖ Python ÏÑúÎπÑÏä§ Ïã§Ìå®Ìï¥ÎèÑ JS ÏóîÏßÑÏùÄ Ï†ïÏÉÅÏúºÎ°ú Ï≤òÎ¶¨
      this.updateSystemHealth('down', 'up');
    }

    // üîß ÌïµÏã¨ ÏÑúÎπÑÏä§ Ï≤¥ÌÅ¨ (Ìï≠ÏÉÅ Ï†ïÏÉÅ)
    healthChecks.push({
      name: 'ÏÑúÎ≤Ñ Î™®ÎãàÌÑ∞ÎßÅ (ÌïµÏã¨)',
      status: 'healthy',
      responseTime: 0,
      details: 'API ÏÑúÎ≤Ñ Ï†ïÏÉÅ ÎèôÏûë',
      optional: false
    });

    healthChecks.push({
      name: 'ÎåÄÏãúÎ≥¥Îìú UI (ÌïµÏã¨)',
      status: 'healthy',
      responseTime: 0,
      details: 'React Ïª¥Ìè¨ÎÑåÌä∏ Ï†ïÏÉÅ Î†åÎçîÎßÅ',
      optional: false
    });

    const totalResponseTime = healthChecks
      .filter(check => !check.optional)
      .reduce((sum, check) => sum + check.responseTime, 0);

    // üéØ Ìó¨Ïä§Ï≤¥ÌÅ¨ Í≤∞Í≥º: ÌïµÏã¨ Í∏∞Îä• Í∏∞Ï§ÄÏúºÎ°ú ÌåêÎã®
    const coreServicesHealthy = healthChecks
      .filter(check => !check.optional)
      .every(check => check.status === 'healthy');

    const overallStatus = coreServicesHealthy ? 'healthy' : this.systemHealth.status;

    return {
      status: overallStatus,
      checks: healthChecks,
      totalResponseTime,
      coreServicesHealthy,
      optionalServicesCount: healthChecks.filter(check => check.optional).length,
      message: coreServicesHealthy ?
        'ÌïµÏã¨ Î™®ÎãàÌÑ∞ÎßÅ Í∏∞Îä• Ï†ïÏÉÅ ÎèôÏûë' :
        'ÏùºÎ∂Ä ÏÑúÎπÑÏä§Ïóê Î¨∏Ï†úÍ∞Ä ÏûàÏßÄÎßå Î™®ÎãàÌÑ∞ÎßÅ Í∏∞Îä•ÏùÄ ÏÇ¨Ïö© Í∞ÄÎä•',
      timestamp: new Date().toISOString(),
      environment: isVercel ? 'serverless' : 'local'
    };
  }

  /**
   * üßπ Î©îÌä∏Î¶≠ Ï†ïÎ¶¨
   */
  private cleanupMetrics() {
    // 1ÏãúÍ∞Ñ Ïù¥Ï†Ñ ÏöîÏ≤≠ Ï†úÍ±∞
    const oneHourAgo = Date.now() - 60 * 60 * 1000;
    this.requestBuffer = this.requestBuffer.filter(req => req.timestamp > oneHourAgo);

    // Ïò§ÎûòÎêú ÏóêÎü¨ Î≥¥Í≥†ÏÑú Ï†úÍ±∞ (24ÏãúÍ∞Ñ Ïù¥Ï†Ñ)
    const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
    this.errorReports = this.errorReports.filter(error =>
      new Date(error.timestamp).getTime() > oneDayAgo
    );

    console.log('üìä Î©îÌä∏Î¶≠ Ï†ïÎ¶¨ ÏôÑÎ£å:', {
      requestBufferSize: this.requestBuffer.length,
      errorReportsSize: this.errorReports.length
    });
  }

  /**
   * üìä Ïã§ÏãúÍ∞Ñ ÌÜµÍ≥Ñ Ï°∞Ìöå
   */
  getRealTimeStats() {
    const now = Date.now();
    const last5Minutes = this.requestBuffer.filter(req => req.timestamp > now - 5 * 60 * 1000);
    const last1Hour = this.requestBuffer.filter(req => req.timestamp > now - 60 * 60 * 1000);

    return {
      last5Minutes: {
        requests: last5Minutes.length,
        successRate: last5Minutes.length > 0 ?
          last5Minutes.filter(r => r.success).length / last5Minutes.length : 1,
        averageResponseTime: last5Minutes.length > 0 ?
          last5Minutes.reduce((sum, r) => sum + r.responseTime, 0) / last5Minutes.length : 0
      },
      last1Hour: {
        requests: last1Hour.length,
        successRate: last1Hour.length > 0 ?
          last1Hour.filter(r => r.success).length / last1Hour.length : 1,
        averageResponseTime: last1Hour.length > 0 ?
          last1Hour.reduce((sum, r) => sum + r.responseTime, 0) / last1Hour.length : 0
      },
      current: {
        systemStatus: this.systemHealth.status,
        uptime: now - this.startTime
      }
    };
  }
}

// Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
export const monitoringService = new MonitoringService(); 