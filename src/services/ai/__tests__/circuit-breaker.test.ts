/**
 * ‚ö° ÌöåÎ°ú Ï∞®Îã®Í∏∞ Ìå®ÌÑ¥ ÌÖåÏä§Ìä∏
 *
 * ÌÖåÏä§Ìä∏ ÏòÅÏó≠:
 * 1. ÌöåÎ°ú Ï∞®Îã®Í∏∞ Í∏∞Î≥∏ ÎèôÏûë (Closed ‚Üí Open ‚Üí Half-Open)
 * 2. Ïã§Ìå® ÏûÑÍ≥ÑÍ∞í Î∞è ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
 * 3. ÏûêÎèô Î≥µÍµ¨ Î©îÏª§ÎãàÏ¶ò
 * 4. Ìè¥Î∞± ÏùëÎãµ Í≤ÄÏ¶ù
 * 5. Îã§Ï§ë ÏÑúÎπÑÏä§ ÌöåÎ°ú Ï∞®Îã®Í∏∞
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { getPerformanceOptimizedQueryEngine } from '@/services/ai/performance-optimized-query-engine';
import type {
  QueryRequest,
  QueryResponse,
} from '@/services/ai/SimplifiedQueryEngine';

// Mock dependencies
vi.mock('@/services/ai/SimplifiedQueryEngine');
vi.mock('@/services/ai/supabase-rag-engine');
vi.mock('@/lib/logger');
vi.mock('@/services/ai/query-cache-manager', () => ({
  getQueryCacheManager: vi.fn().mockReturnValue({
    getFromPatternCache: vi.fn().mockResolvedValue(null),
    saveToPatternCache: vi.fn(),
  }),
}));
vi.mock('@/services/ai/vector-search-optimizer', () => ({
  getVectorSearchOptimizer: vi.fn().mockReturnValue({
    optimizeSearch: vi.fn(),
  }),
}));

// ÌÖåÏä§Ìä∏Ïö© ÏÑ§Ï†ï
const CIRCUIT_BREAKER_CONFIG = {
  enableParallelProcessing: true,
  enablePredictiveLoading: false, // ÌÖåÏä§Ìä∏ Îã®ÏàúÌôî
  enableCircuitBreaker: true,
  warmupOnStart: false,
  cacheStrategy: 'conservative' as const,
  timeoutMs: 5000,
};

describe('‚ö° ÌöåÎ°ú Ï∞®Îã®Í∏∞ Ìå®ÌÑ¥ ÌÖåÏä§Ìä∏', () => {
  let engine: ReturnType<typeof getPerformanceOptimizedQueryEngine> & {
    _initialize: () => Promise<void>;
    clearOptimizationCache: () => void;
    ragEngine: any;
    circuitBreakers: Map<string, any>;
    generateLocalResponse: any;
  };

  beforeEach(async () => {
    // ÏÉàÎ°úÏö¥ ÏóîÏßÑ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
    engine = getPerformanceOptimizedQueryEngine(CIRCUIT_BREAKER_CONFIG);
    await engine._initialize();

    // Í∏∞Ï°¥ ÌöåÎ°ú Ï∞®Îã®Í∏∞ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    engine.clearOptimizationCache();
  });

  afterEach(() => {
    // ÌÖåÏä§Ìä∏ ÌõÑ Ï†ïÎ¶¨
    engine.clearOptimizationCache();
    vi.clearAllTimers();
  });

  describe('üîÑ ÌöåÎ°ú Ï∞®Îã®Í∏∞ Í∏∞Î≥∏ ÏÉÅÌÉú Ï†ÑÌôò', () => {
    it('Ïó∞ÏÜç Ïã§Ìå® Ïãú ÌöåÎ°úÍ∞Ä Ïó¥Î†§Ïïº Ìï® (Closed ‚Üí Open)', async () => {
      const testQuery: QueryRequest = {
        query: 'test circuit breaker failure',
        mode: 'local',
        options: { includeMCPContext: false },
      };

      // Mock the ragEngine to fail multiple times
      engine.ragEngine = {
        searchSimilar: vi
          .fn()
          .mockRejectedValueOnce(new Error('Test failure 1'))
          .mockRejectedValueOnce(new Error('Test failure 2'))
          .mockRejectedValueOnce(new Error('Test failure 3'))
          .mockRejectedValueOnce(new Error('Test failure 4'))
          .mockRejectedValueOnce(new Error('Test failure 5'))
          .mockResolvedValue({
            results: [{ content: 'Success after failures', score: 0.8 }],
            totalResults: 1,
            cached: false,
          }),
        generateEmbedding: vi.fn().mockResolvedValue([0.1, 0.2, 0.3]),
        _initialize: vi.fn().mockResolvedValue(undefined),
        healthCheck: vi
          .fn()
          .mockResolvedValue({ status: 'healthy', vectorDB: true }),
      };

      const responses: QueryResponse[] = [];
      let fallbackCount = 0;

      // Test consecutive failures (threshold is 5)
      for (let i = 0; i < 7; i++) {
        const result = await engine.query(testQuery);
        responses.push(result);

        // Check if circuit breaker opened (fallback response)
        if (result.engine === 'fallback' || result.metadata?.fallback) {
          fallbackCount++;
          console.log(`üî¥ Fallback response at attempt ${i + 1}`);
        }
      }

      // After 5 failures, circuit should be open and return fallback responses
      expect(fallbackCount).toBeGreaterThan(0);
      expect(responses.some((r) => r.engine === 'fallback')).toBe(true);

      // Check the last responses should be fallback
      const lastTwo = responses.slice(-2);
      expect(
        lastTwo.every((r) => r.engine === 'fallback' || r.metadata?.fallback)
      ).toBe(true);

      console.log(
        `üìä Ï¥ù ${responses.length}Í∞ú ÏùëÎãµ Ï§ë Ìè¥Î∞±: ${fallbackCount}Í∞ú`
      );
    }, 15000);

    it('Ï†ïÏÉÅ ÏÑúÎπÑÏä§Îäî ÌöåÎ°ú Ï∞®Îã®Í∏∞Ïùò ÏòÅÌñ•ÏùÑ Î∞õÏßÄ ÏïäÏïÑÏïº Ìï®', async () => {
      const normalQuery: QueryRequest = {
        query: 'normal query test',
        mode: 'local',
        options: { includeMCPContext: false },
      };

      // Ï†ïÏÉÅ ÎèôÏûëÌïòÎäî RAG ÏóîÏßÑ Mock
      const mockRagEngine = {
        searchSimilar: vi.fn().mockResolvedValue({
          results: [{ content: 'test result', score: 0.8 }],
          totalResults: 1,
          cached: false,
        }),
        generateEmbedding: vi.fn().mockResolvedValue([0.1, 0.2, 0.3]),
        _initialize: vi.fn().mockResolvedValue(undefined),
        healthCheck: vi
          .fn()
          .mockResolvedValue({ status: 'healthy', vectorDB: true }),
      };

      engine.ragEngine = mockRagEngine;

      // Mock the generateLocalResponse method
      engine.generateLocalResponse = vi.fn().mockReturnValue({
        success: true,
        response: 'Normal response from RAG engine',
        engine: 'local',
        confidence: 0.8,
        thinkingSteps: [],
        metadata: {},
        processingTime: 100,
      });

      // Ïó¨Îü¨ Î≤à Ï†ïÏÉÅ ÏøºÎ¶¨ Ïã§Ìñâ
      const responses = [];
      for (let i = 0; i < 3; i++) {
        const result = await engine.query(normalQuery);
        responses.push(result);

        expect(result.success).toBe(true);
        expect(result.metadata?.fallback).toBeFalsy();
        expect(result.response).toBeTruthy();
        expect(result.engine).not.toBe('fallback');
      }

      console.log(`‚úÖ Ï†ïÏÉÅ ÏÑúÎπÑÏä§ ${responses.length}Î≤à Ïó∞ÏÜç ÏÑ±Í≥µ`);
    });
  });

  describe('‚è±Ô∏è ÌöåÎ°ú Ï∞®Îã®Í∏∞ ÌÉÄÏûÑÏïÑÏõÉ Î∞è Î≥µÍµ¨', () => {
    it('ÌÉÄÏûÑÏïÑÏõÉ ÌõÑ Half-Open ÏÉÅÌÉúÎ°ú Ï†ÑÌôòÎêòÏñ¥Ïïº Ìï®', async () => {
      // ÏßßÏùÄ ÌÉÄÏûÑÏïÑÏõÉÏúºÎ°ú ÌÖåÏä§Ìä∏ (Ïã§Ï†úÎ°úÎäî 30Ï¥à)
      const mockCircuitBreaker = {
        failures: 6, // ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º
        lastFailure: Date.now() - 31000, // 31Ï¥à Ï†Ñ Ïã§Ìå®
        state: 'open',
        threshold: 5,
        timeout: 30000,
      };

      // ÌöåÎ°ú Ï∞®Îã®Í∏∞ ÏÉÅÌÉú ÏßÅÏ†ë ÏÑ§Ï†ï (ÌÖåÏä§Ìä∏Ïö©)
      engine.circuitBreakers = new Map([['local', mockCircuitBreaker]]);

      const testQuery: QueryRequest = {
        query: 'test recovery query',
        mode: 'local',
        options: { includeMCPContext: false },
      };

      // Ï†ïÏÉÅ ÎèôÏûëÌïòÎäî ÏóîÏßÑÏúºÎ°ú ÏÑ§Ï†ï
      const mockRagEngine = {
        searchSimilar: vi.fn().mockResolvedValue({
          results: [{ content: 'recovery test', score: 0.9 }],
          totalResults: 1,
          cached: false,
        }),
        generateEmbedding: vi.fn().mockResolvedValue([0.1, 0.2, 0.3]),
        _initialize: vi.fn().mockResolvedValue(undefined),
        healthCheck: vi
          .fn()
          .mockResolvedValue({ status: 'healthy', vectorDB: true }),
      };

      engine.ragEngine = mockRagEngine;

      // Mock the generateLocalResponse method for recovery
      engine.generateLocalResponse = vi.fn().mockReturnValue({
        success: true,
        response: 'Recovery successful - system is back online',
        engine: 'local',
        confidence: 0.9,
        thinkingSteps: [],
        metadata: {},
        processingTime: 50,
      });

      const result = await engine.query(testQuery);

      // Half-Open ÏÉÅÌÉúÏóêÏÑú ÏÑ±Í≥µÌïòÎ©¥ Ï†ïÏÉÅ ÏùëÎãµÏùÑ Î∞õÏïÑÏïº Ìï®
      expect(result.success).toBe(true);
      expect(result.response).toBeTruthy();
      expect(result.metadata?.fallback).toBeFalsy();
      expect(result.engine).not.toBe('fallback');

      console.log('üü° Half-Open ÏÉÅÌÉúÏóêÏÑú Î≥µÍµ¨ ÏÑ±Í≥µ');
    });

    it('Î≥µÍµ¨ ÏãúÎèÑ Ïã§Ìå® Ïãú Îã§Ïãú Open ÏÉÅÌÉúÎ°ú ÎèåÏïÑÍ∞ÄÏïº Ìï®', async () => {
      const mockCircuitBreaker = {
        failures: 6,
        lastFailure: Date.now() - 31000,
        state: 'half-open',
        threshold: 5,
        timeout: 30000,
      };

      engine.circuitBreakers = new Map([['local', mockCircuitBreaker]]);

      // Î≥µÍµ¨ ÏãúÎèÑÏóêÏÑú Ïã§Ìå®ÌïòÎäî ÏóîÏßÑ
      const mockRagEngine = {
        searchSimilar: vi
          .fn()
          .mockRejectedValue(new Error('Recovery attempt failed')),
        generateEmbedding: vi.fn().mockResolvedValue([0.1, 0.2, 0.3]),
        _initialize: vi.fn().mockResolvedValue(undefined),
        healthCheck: vi
          .fn()
          .mockResolvedValue({ status: 'healthy', vectorDB: true }),
      };

      engine.ragEngine = mockRagEngine;

      const testQuery: QueryRequest = {
        query: 'test failed recovery',
        mode: 'local',
        options: { includeMCPContext: false },
      };

      const result = await engine.query(testQuery);

      // Ïã§Ìå® Ïãú Ìè¥Î∞± ÏùëÎãµÏùÑ Î∞õÏïÑÏïº Ìï®
      expect(result.metadata?.fallback || result.engine === 'fallback').toBe(
        true
      );
      expect(result.response).toBeTruthy();

      console.log('üî¥ Î≥µÍµ¨ Ïã§Ìå®, Îã§Ïãú Open ÏÉÅÌÉúÎ°ú Ï†ÑÌôò');
    });
  });

  describe('üéØ Îã§Ï§ë ÏÑúÎπÑÏä§ ÌöåÎ°ú Ï∞®Îã®Í∏∞', () => {
    it('Í∞Å ÏÑúÎπÑÏä§Î≥ÑÎ°ú ÎèÖÎ¶ΩÏ†ÅÏù∏ ÌöåÎ°ú Ï∞®Îã®Í∏∞Í∞Ä ÏûëÎèôÌï¥Ïïº Ìï®', async () => {
      const localQuery: QueryRequest = {
        query: 'local service test',
        mode: 'local',
        options: { includeMCPContext: false },
      };

      const googleQuery: QueryRequest = {
        query: 'google ai service test',
        mode: 'google-ai',
        options: { includeMCPContext: false },
      };

      // Î°úÏª¨ ÏÑúÎπÑÏä§Îßå Ïã§Ìå®ÌïòÎèÑÎ°ù ÏÑ§Ï†ï
      const failingLocalMock = {
        searchSimilar: vi
          .fn()
          .mockRejectedValue(new Error('Local service down')),
        generateEmbedding: vi.fn().mockResolvedValue([0.1, 0.2, 0.3]),
        _initialize: vi.fn().mockResolvedValue(undefined),
        healthCheck: vi
          .fn()
          .mockResolvedValue({ status: 'healthy', vectorDB: true }),
      };

      engine.ragEngine = failingLocalMock;

      // Google AIÎäî Ï†ïÏÉÅ ÎèôÏûëÌïòÎèÑÎ°ù fetch Mock ÏÑ§Ï†ï
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () =>
          Promise.resolve({
            response: 'Google AI response',
            text: 'Google AI response',
            confidence: 0.9,
            model: 'gemini-1.5-flash',
          }),
      }) as any;

      // Î°úÏª¨ ÏÑúÎπÑÏä§ Ïã§Ìå® ÌÖåÏä§Ìä∏
      const localResults = [];
      for (let i = 0; i < 6; i++) {
        // ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º
        const result = await engine.query(localQuery);
        localResults.push(result);
      }

      // Google AI ÏÑúÎπÑÏä§ Ï†ïÏÉÅ ÎèôÏûë ÌÖåÏä§Ìä∏
      const googleResult = await engine.query(googleQuery);

      // Î°úÏª¨ ÏÑúÎπÑÏä§Îäî Ìè¥Î∞± ÏùëÎãµ
      const localFallbacks = localResults.filter(
        (r) => r.metadata?.fallback
      ).length;
      expect(localFallbacks).toBeGreaterThan(0);

      // Google AIÎäî Ï†ïÏÉÅ ÏùëÎãµ
      expect(googleResult.success).toBe(true);
      expect(googleResult.engine).toBe('google-ai');

      console.log(
        `üîÄ ÎèÖÎ¶ΩÏ†Å ÌöåÎ°ú Ï∞®Îã®Í∏∞: Local Ìè¥Î∞± ${localFallbacks}Í∞ú, Google AI Ï†ïÏÉÅ`
      );
    });

    it('Ï†ÑÏ≤¥ ÏãúÏä§ÌÖú Î≥µÍµ¨ Ïãú Î™®Îì† ÌöåÎ°ú Ï∞®Îã®Í∏∞Í∞Ä Ïû¨ÏÑ§Ï†ïÎêòÏñ¥Ïïº Ìï®', async () => {
      // Ïó¨Îü¨ ÏÑúÎπÑÏä§Ïóê Ïã§Ìå® ÏÉÅÌÉú ÏÑ§Ï†ï
      const circuitBreakers = new Map([
        [
          'local',
          {
            failures: 6,
            lastFailure: Date.now(),
            state: 'open',
            threshold: 5,
            timeout: 30000,
          },
        ],
        [
          'google-ai',
          {
            failures: 7,
            lastFailure: Date.now(),
            state: 'open',
            threshold: 5,
            timeout: 30000,
          },
        ],
      ]);

      engine.circuitBreakers = circuitBreakers;

      // Ï¥àÍ∏∞ ÌöåÎ°ú Ï∞®Îã®Í∏∞ Ïàò ÌôïÏù∏
      const _initialBreakerCount = engine.circuitBreakers.size;
      expect(_initialBreakerCount).toBe(2);

      // Ï†ÑÏ≤¥ Ï∫êÏãú Î∞è ÌöåÎ°ú Ï∞®Îã®Í∏∞ Ï¥àÍ∏∞Ìôî
      engine.clearOptimizationCache();

      // Ï¥àÍ∏∞Ìôî ÌõÑ ÌöåÎ°ú Ï∞®Îã®Í∏∞ Ïàò ÌôïÏù∏
      const finalBreakerCount = engine.circuitBreakers.size;
      expect(finalBreakerCount).toBe(0);

      console.log(
        `üîÑ ÏãúÏä§ÌÖú Î≥µÍµ¨: ${_initialBreakerCount}Í∞ú ‚Üí ${finalBreakerCount}Í∞ú ÌöåÎ°ú Ï∞®Îã®Í∏∞`
      );
    });
  });

  describe('üõ°Ô∏è Ìè¥Î∞± ÏùëÎãµ ÌíàÏßà Í≤ÄÏ¶ù', () => {
    it('Ìè¥Î∞± ÏùëÎãµÏù¥ ÏÇ¨Ïö©ÏûêÏóêÍ≤å Ïú†Ïö©Ìïú Ï†ïÎ≥¥Î•º Ï†úÍ≥µÌï¥Ïïº Ìï®', async () => {
      // Í∞ïÏ†úÎ°ú ÌöåÎ°ú Ï∞®Îã®Í∏∞ Ïó¥Í∏∞
      const openCircuitBreaker = {
        failures: 10,
        lastFailure: Date.now(),
        state: 'open',
        threshold: 5,
        timeout: 30000,
      };

      engine.circuitBreakers = new Map([['local', openCircuitBreaker]]);

      const testQuery: QueryRequest = {
        query: 'emergency system status check',
        mode: 'local',
        options: { includeMCPContext: false },
      };

      const result = await engine.query(testQuery);

      // Ìè¥Î∞± ÏùëÎãµ ÌíàÏßà Í≤ÄÏ¶ù
      expect(result.success).toBe(true);
      expect(result.response).toBeTruthy();
      expect(result.response.length).toBeGreaterThan(20); // ÏùòÎØ∏ÏûàÎäî Í∏∏Ïù¥
      expect(result.engine).toBe('fallback');
      expect(result.metadata?.fallback).toBe(true);
      expect(result.metadata?.reason).toBeTruthy();

      // ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†Å Î©îÏãúÏßÄ ÌôïÏù∏
      const userFriendlyKeywords = [
        'Ï†úÌïúÎêú Î™®Îìú',
        'ÏùºÏãúÏ†Å',
        'Í∏∞Î≥∏Ï†ÅÏù∏ Ï†ïÎ≥¥',
        'ÏãúÏä§ÌÖú',
        'ÏÑúÎπÑÏä§',
        'Ïù¥Ïö©',
      ];

      const hasUserFriendlyMessage = userFriendlyKeywords.some((keyword) =>
        result.response.includes(keyword)
      );

      expect(hasUserFriendlyMessage).toBe(true);

      console.log(
        `üõ°Ô∏è Ìè¥Î∞± ÏùëÎãµ ÌíàÏßà: "${result.response.substring(0, 50)}..."`
      );
      console.log(`üîç Ìè¥Î∞± Ïù¥Ïú†: ${result.metadata?.reason}`);
    });

    it('Ìè¥Î∞± ÏùëÎãµ ÏãúÍ∞ÑÏù¥ Îπ®ÎùºÏïº Ìï®', async () => {
      const openCircuitBreaker = {
        failures: 10,
        lastFailure: Date.now(),
        state: 'open',
        threshold: 5,
        timeout: 30000,
      };

      engine.circuitBreakers = new Map([['local', openCircuitBreaker]]);

      const testQuery: QueryRequest = {
        query: 'fast fallback test',
        mode: 'local',
        options: { includeMCPContext: false },
      };

      const startTime = Date.now();
      const result = await engine.query(testQuery);
      const responseTime = Date.now() - startTime;

      expect(result.metadata?.fallback).toBe(true);
      expect(responseTime).toBeLessThan(200); // 200ms Ïù¥ÎÇ¥
      expect(result.processingTime).toBeLessThan(100); // ÎÇ¥Î∂Ä Ï≤òÎ¶¨ ÏãúÍ∞ÑÎèÑ Îπ®ÎùºÏïº Ìï®

      console.log(
        `‚ö° Ìè¥Î∞± ÏùëÎãµ ÏÜçÎèÑ: ${responseTime}ms (Ï≤òÎ¶¨: ${result.processingTime}ms)`
      );
    });
  });

  describe('üìä ÌöåÎ°ú Ï∞®Îã®Í∏∞ ÌÜµÍ≥Ñ Î∞è Î™®ÎãàÌÑ∞ÎßÅ', () => {
    it('ÌöåÎ°ú Ï∞®Îã®Í∏∞ ÏÉÅÌÉúÍ∞Ä ÏÑ±Îä• ÌÜµÍ≥ÑÏóê Î∞òÏòÅÎêòÏñ¥Ïïº Ìï®', async () => {
      // ÌöåÎ°ú Ï∞®Îã®Í∏∞ ÏÉÅÌÉú ÏÑ§Ï†ï
      const circuitBreakers = new Map([
        [
          'local',
          {
            failures: 3,
            lastFailure: Date.now(),
            state: 'closed',
            threshold: 5,
            timeout: 30000,
          },
        ],
        [
          'google-ai',
          {
            failures: 6,
            lastFailure: Date.now(),
            state: 'open',
            threshold: 5,
            timeout: 30000,
          },
        ],
      ]);

      engine.circuitBreakers = circuitBreakers;

      const stats = engine.getPerformanceStats();

      expect(stats.optimization.circuitBreakers).toBe(2);

      console.log(`üìä ÌöåÎ°ú Ï∞®Îã®Í∏∞ ÌÜµÍ≥Ñ:`, {
        Ï¥ùÍ∞úÏàò: stats.optimization.circuitBreakers,
        ÏÉÅÌÉú: Array.from(circuitBreakers.entries()).map(
          ([service, breaker]) => ({
            service,
            state: breaker.state,
            failures: breaker.failures,
          })
        ),
      });
    });

    // ÏóêÎü¨Ïú® Í∏∞Î∞ò ÌöåÎ°ú Ï∞®Îã®Í∏∞Îäî ÌòÑÏû¨ SimplifiedQueryEngineÏóêÏÑú Íµ¨ÌòÑÎêòÏßÄ ÏïäÏùå
    // ÎØ∏Îûò Íµ¨ÌòÑ Ïãú Îã§Ïùå ÌÖåÏä§Ìä∏ ÏºÄÏù¥Ïä§ Ï∞∏Ï°∞:
    // - Ïó∞ÏÜç Ïã§Ìå®Ïú® ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º Ïãú ÌöåÎ°ú Ï∞®Îã®
    // - ÏóêÎü¨Ïú® Í∏∞Î∞ò Ìè¥Î∞± ÏóîÏßÑ ÏÑ†ÌÉù
    // - ÎèôÏ†Å ÏûÑÍ≥ÑÍ∞í Ï°∞Ï†ï Í∏∞Îä•
  });
});
