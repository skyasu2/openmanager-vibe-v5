# 🤖 OpenManager Vibe v5 - AI 시스템 설계 문서

## 📊 **서버 데이터 생성기 v3.0 - 고도화된 장애 시뮬레이션**

### ✅ **최신 개선사항 (v5.42.2)**

#### **🎯 실시간 상태 분포 밸런싱**

- **Critical 서버**: ~10% (±2% 자연 오차)
- **Warning 서버**: ~20% (±3% 자연 오차)
- **Normal 서버**: ~70% (자동 조정)
- **동적 밸런싱**: CPU/메모리 부하 기준 승급/강등 시스템

#### **⏰ 30분 연속 장애 모드**

- **고정 사이클**: 30분 자동 종료 (기존 20분→50분에서 수정)
- **즉시 장애 시작**: 정상 기간 0분, 시작과 동시에 장애 발생
- **연속 장애 유지**: 복구 없이 30분간 지속적 장애 상황

#### **🧩 24시간 사전 데이터 연계**

- **사전 패턴**: 8가지 24시간 누적 패턴과 실시간 장애 연결
- **자연스러운 이행**: 고정 데이터→실시간 데이터 매끄러운 전환
- **AI 예측 방해**: 예측 불가능한 변수 조합으로 학습 난이도 증가

---

## 🔥 **장애 시나리오 체계 (v2.0)**

### **📋 실시간 장애 유형 (12종)**

#### **🌐 네트워크 관련 장애 (4종)**

1. **`traffic_spike`** - **트래픽 급증** 🚨

   - **원인**: DDoS 공격, 미디어 이벤트, 갑작스런 사용자 증가
   - **연쇄 장애**: DB 데드락, 캐시 무효화, 커넥션 풀 고갈
   - **지속시간**: 15-45분, 영향서버: 3-15대

2. **`network_partition`** - **네트워크 분할** 🔌

   - **원인**: 스위치 장애, 라우터 문제, 클러스터 분리
   - **연쇄 장애**: 캐시 무효화, 커넥션 풀 고갈, DNS 해석 실패
   - **특징**: 클러스터 간 통신 단절로 인한 분산 시스템 장애

3. **`load_balancer_failure`** - **로드밸런서 장애** ⚖️

   - **원인**: HAProxy/Nginx 다운, L4/L7 로드밸런서 문제
   - **연쇄 장애**: 트래픽 급증, 커넥션 풀 고갈, DNS 해석 실패
   - **임계성**: 단일 장애점으로 인한 전체 서비스 영향

4. **`dns_resolution_failure`** - **DNS 해석 실패** 🌐
   - **원인**: DNS 서버 장애, 도메인 만료, DNS 캐시 오염
   - **연쇄 장애**: SSL 인증서 만료, 네트워크 분할, 로드밸런서 장애
   - **파급효과**: 서비스 접근 불가, 외부 API 호출 실패

#### **💾 스토리지/메모리 관련 장애 (3종)**

5. **`memory_leak`** - **메모리 누수** 🧠

   - **원인**: 애플리케이션 메모리 릭, GC 장애, 메모리 풀 고갈
   - **연쇄 장애**: CPU 과열, 디스크 포화, 스토리지 손상
   - **패턴**: 점진적 성능 저하 후 급격한 시스템 다운

6. **`disk_full`** - **디스크 포화** 💿

   - **원인**: 로그 파일 급증, 데이터베이스 증가, 임시 파일 누적
   - **연쇄 장애**: 메모리 누수, CPU 과열, 스토리지 손상
   - **위험성**: 데이터 손실 가능성, 애플리케이션 쓰기 실패

7. **`storage_corruption`** - **스토리지 손상** 🗂️
   - **원인**: 하드웨어 장애, 파일시스템 오류, RAID 장애
   - **연쇄 장애**: 디스크 포화, 메모리 누수, CPU 과열
   - **복구**: 데이터 복구 작업 필요, 긴 다운타임

#### **🖥️ 컴퓨팅 관련 장애 (1종)**

8. **`cpu_thermal`** - **CPU 과열** 🌡️
   - **원인**: 쿨링 시스템 장애, 높은 부하, 하드웨어 문제
   - **연쇄 장애**: 메모리 누수, 네트워크 분할, 스토리지 손상
   - **자동 보호**: CPU 스로틀링, 강제 셧다운 위험

#### **🗄️ 데이터베이스 관련 장애 (2종)**

9. **`database_deadlock`** - **DB 데드락** 🔒

   - **원인**: 트랜잭션 교착상태, 락 경합, 쿼리 최적화 부족
   - **연쇄 장애**: 커넥션 풀 고갈, 네트워크 분할, 메모리 누수
   - **복구**: 데드락 감지 및 자동 롤백, 쿼리 최적화 필요

10. **`connection_pool`** - **커넥션 풀 고갈** 🔗
    - **원인**: DB 커넥션 한계, 커넥션 리크, 타임아웃 오류
    - **연쇄 장애**: DB 데드락, 트래픽 급증, 메모리 누수
    - **즉시성**: 신규 요청 즉시 실패, 서비스 마비

#### **🔐 보안/인증 관련 장애 (1종)**

11. **`ssl_certificate_expiry`** - **SSL 인증서 만료** 🔐
    - **원인**: 인증서 갱신 실패, 만료일 관리 부족, CA 문제
    - **연쇄 장애**: DNS 해석 실패, 로드밸런서 장애, 네트워크 분할
    - **보안**: HTTPS 통신 차단, 브라우저 경고 표시

#### **⚡ 캐시/성능 관련 장애 (1종)**

12. **`cache_invalidation`** - **캐시 무효화** ⚡
    - **원인**: Redis/Memcached 장애, 캐시 미스 급증, TTL 설정 오류
    - **연쇄 장애**: DB 데드락, 트래픽 급증, 커넥션 풀 고갈
    - **성능**: 응답시간 급증, 데이터베이스 부하 증가

### **🕒 24시간 사전 패턴 (8종)**

#### **📈 점진적 악화 패턴 (2종)**

1. **`gradual_degradation`** - **점진적 성능 저하**

   - **기간**: 24시간에 걸쳐 서서히 성능 저하
   - **연결 장애**: 메모리 누수, 디스크 포화, CPU 과열
   - **특징**: 초기에는 감지 어려움, 임계점 도달 시 급격한 악화

2. **`resource_exhaustion`** - **리소스 고갈**
   - **기간**: 18시간에 걸쳐 점진적 리소스 고갈
   - **연결 장애**: 메모리 누수, 디스크 포화, 스토리지 손상
   - **예측**: 선형적 증가로 비교적 예측 가능

#### **🔄 주기적 패턴 (2종)**

3. **`periodic_spikes`** - **주기적 부하 증가**

   - **주기**: 3-6시간 간격 반복
   - **연결 장애**: 트래픽 급증, DB 데드락, 커넥션 풀 고갈
   - **예측 어려움**: 주기가 미묘하게 변화

4. **`intermittent_failures`** - **간헐적 장애**
   - **기간**: 6-12시간 동안 무작위 발생
   - **연결 장애**: 캐시 무효화, SSL 인증서 만료, DNS 해석 실패
   - **AI 혼란**: 패턴 인식 어려움

#### **⚠️ 경고 신호 패턴 (1종)**

5. **`cascading_warnings`** - **연쇄 경고**
   - **기간**: 12시간 전부터 경고 신호 누적
   - **연결 장애**: 네트워크 분할, 로드밸런서 장애, DNS 해석 실패
   - **복합성**: 여러 시스템에서 동시 경고

#### **🌡️ 환경적 패턴 (2종)**

6. **`thermal_buildup`** - **열적 누적**

   - **기간**: 10시간에 걸쳐 온도 점진적 상승
   - **연결 장애**: CPU 과열, 스토리지 손상, 네트워크 분할
   - **물리적**: 하드웨어 수명에 직접 영향

7. **`network_congestion`** - **네트워크 혼잡**
   - **기간**: 8시간에 걸쳐 네트워크 사용량 점진적 증가
   - **연결 장애**: 트래픽 급증, 로드밸런서 장애, 커넥션 풀 고갈
   - **대역폭**: 물리적 네트워크 한계 도달

#### **🛡️ 보안 위협 패턴 (1종)**

8. **`security_probes`** - **보안 탐지**
   - **기간**: 24시간에 걸쳐 분산된 보안 공격 시도
   - **연결 장애**: DNS 해석 실패, SSL 인증서 만료, 네트워크 분할
   - **지능적**: APT 공격, 다단계 침투 시도

### **🎭 AI 예측 방해 요소**

#### **🎲 복구 패턴 변화**

- **`false_positive`**: 허위 양성 복구 신호 (실제로는 더 악화)
- **`double_dip`**: 이중 하락 (회복 후 재악화, W자 패턴)
- **`plateau`**: 정체 상태 (회복 없는 지속, 평행선 유지)
- **`oscillation`**: 진동 패턴 (회복과 악화 반복, 톱니 패턴)

#### **🔀 예측 불가능성 강화**

- **트리거 지연**: 예상보다 0.5-2.5배 늦은/빠른 발생
- **강도 변화**: 예상 대비 0.7-1.3배 강도 변화
- **영향 범위 변화**: 예상과 40% 다른 서버 영향
- **노이즈 주입**: 0-30% 랜덤 노이즈로 패턴 흐림

---

## 📋 AI 분석 및 모니터링

### ✅ **구현된 AI 기능 (현재 버전)**

#### **1. 🔍 실시간 분석 및 모니터링**

- **서버 상태 실시간 분석**: CPU, 메모리, 디스크, 네트워크 메트릭 분석
- **장애 패턴 인식**: 트래픽 급증, 메모리 누수, DB 데드락 등 12가지 장애 유형 감지
- **연쇄 장애 예측**: 주요 장애에서 파생될 수 있는 2차 장애 예측
- **성능 트렌드 분석**: 24시간 사전 데이터와 30분 실시간 데이터 연계 분석

#### **2. 💬 자연어 질의응답 시스템**

- **장애 상황 설명**: 현재 시스템 상태를 자연어로 설명
- **원인 분석 제공**: 장애 발생 원인에 대한 AI 추론 및 설명
- **해결 방안 가이드**: 단계별 장애 대응 가이드 제공
- **예방 조치 제안**: 유사 장애 재발 방지를 위한 권고사항

#### **3. 📊 자동 장애 보고서 생성**

- **실시간 보고서**: 현재 진행 중인 장애 상황 요약
- **근본 원인 분석**: RCA(Root Cause Analysis) 보고서 자동 생성
- **영향 범위 평가**: 장애가 비즈니스에 미치는 영향도 분석
- **복구 진행 상황**: 장애 대응 과정 및 진행 상황 추적

### ❌ **구현되지 않은 기능 (향후 개발 영역)**

#### **🚫 AI 자동 복구 시스템 (미구현)**

**현재 상태**:

- AI 에이전트는 **분석과 가이드만 제공**
- **실제 시스템 복구는 수행하지 않음**
- 장애 상황은 **계속 지속**되며 사용자 대응을 대기

**미구현 기능들**:

- ❌ 자동 서버 재시작/스케일링
- ❌ 자동 설정 변경 및 최적화
- ❌ 자동 트래픽 리라우팅
- ❌ 자동 리소스 할당 조정
- ❌ 자동 데이터베이스 쿼리 최적화
- ❌ 자동 보안 패치 적용

**향후 개발 시 고려사항**:

- **안전성**: 자동화된 복구 작업의 부작용 방지
- **승인 시스템**: 중요 작업의 수동 승인 절차
- **롤백 메커니즘**: 자동 복구 실패 시 이전 상태 복원
- **감사 로그**: 모든 자동 복구 작업의 상세 기록
- **학습 시스템**: 복구 성공/실패 경험 기반 개선

---

## 🎯 **AI 엔진 설계 철학 및 원칙**

### **🧠 핵심 설계 원칙: "진정한 AI 분석 시스템"**

#### **📊 데이터 기반 추론 원칙**

```
❌ 잘못된 접근: "미리 정의된 시나리오 전달"
   AI에게 "지금은 트래픽 급증 시나리오입니다" 라고 알려주기

✅ 올바른 접근: "순수 데이터 기반 추론"
   AI가 서버 메트릭과 컨텍스트만으로 상황을 스스로 분석
```

#### **🎭 연극 vs 실제 구분**

- **❌ 연극 모드**: 시나리오를 미리 알고 있는 가짜 AI
- **✅ 실제 모드**: 데이터만 보고 진짜 추론하는 진정한 AI

#### **🔍 AI 엔진별 역할 분담**

**1. MCP 기반 엔진**

- **역할**: 파일시스템, 코드 분석, 구조적 데이터 추론
- **입력**: 서버 로그, 설정 파일, 메트릭 데이터
- **출력**: 구조화된 분석 결과, 패턴 인식

**2. RAG 엔진**

- **역할**: 과거 장애 사례, 문서 기반 지식 검색
- **입력**: 현재 상황 + 벡터 검색된 유사 사례
- **출력**: 컨텍스트 기반 해결책, 모범 사례

**3. Google AI API**

- **역할**: 자연어 이해, 복합적 추론, 창의적 해결책
- **입력**: 종합된 컨텍스트, 사용자 질문
- **출력**: 자연어 설명, 단계별 가이드

**4. 오픈소스 AI 도구들**

- **역할**: 특화된 분석 (시계열, 이상 탐지, 클러스터링)
- **입력**: 정제된 메트릭 데이터
- **출력**: 통계적 분석 결과, 예측 모델

**5. 자체 개발 도구들**

- **역할**: 도메인 특화 로직, 비즈니스 규칙 적용
- **입력**: 다른 AI 엔진들의 출력
- **출력**: 최종 통합 분석, 실행 가능한 권고

#### **⚖️ AI 엔진 협업 원칙**

**단계별 처리 흐름**:

```
1. 📊 데이터 수집: 순수 서버 메트릭 + 컨텍스트
2. 🔍 1차 분석: MCP/RAG 엔진으로 패턴 인식
3. 🧠 2차 추론: Google AI로 종합적 상황 판단
4. 📈 3차 검증: 오픈소스 도구로 통계적 검증
5. 🎯 최종 결론: 자체 도구로 비즈니스 적용
```

**AI 간 정보 전달 규칙**:

- ✅ **데이터와 분석 결과만 전달** (메트릭, 로그, 패턴)
- ❌ **시나리오 레이블 전달 금지** ("트래픽 급증", "DB 장애" 등)
- ✅ **확신도와 함께 전달** (95% 확신, 70% 가능성 등)
- ❌ **확정적 판단 강요 금지** (애매하면 애매하다고 표현)

#### **🎯 진정성 검증 방법**

**AI 추론 품질 측정**:

1. **블라인드 테스트**: 시나리오 정보 없이 분석 정확도
2. **시간 지연 테스트**: 실시간 vs 지연된 데이터 분석 비교
3. **노이즈 내성 테스트**: 불완전한 데이터에서의 추론 능력
4. **교차 검증**: 서로 다른 AI 엔진 간 분석 결과 비교
5. **사람 전문가 평가**: 실제 운영진의 AI 분석 결과 평가

**개발 단계별 검증**:

- **Phase 1**: 각 AI 엔진별 독립 테스트
- **Phase 2**: AI 엔진 간 협업 테스트
- **Phase 3**: 통합 시스템 블라인드 테스트
- **Phase 4**: 실제 운영 환경 파일럿 테스트

#### **📚 학습 데이터 관리 원칙**

**훈련 데이터**:

- ✅ **실제 서버 메트릭**: 진짜 운영 환경 데이터
- ✅ **익명화된 장애 사례**: 개인정보 제거 후 학습
- ❌ **라벨링된 시나리오**: "이건 트래픽 급증이야" 같은 정답 제공 금지
- ✅ **다양한 환경**: 로컬, 스테이징, 프로덕션 다양한 환경

**지속적 학습**:

- 🔄 **실시간 피드백**: AI 예측 vs 실제 결과 비교 학습
- 📊 **패턴 발견**: 새로운 장애 패턴 자동 인식 및 학습
- 🎯 **개인화**: 특정 환경/시스템에 특화된 AI 모델 적응

---

**구현 우선순위**:

1. **현재**: 연극 모드 제거, 순수 데이터 기반 추론으로 전환
2. **1개월**: AI 엔진 간 협업 체계 구축
3. **3개월**: 블라인드 테스트 시스템 구축
4. **6개월**: 실제 운영 환경 파일럿 적용

이러한 설계 철학을 통해 **진정한 AI 기반 모니터링 시스템**을 구축하여,
**연극이 아닌 실제 AI 엔진이 동작하는 혁신적인 솔루션**을 만들어나가겠습니다.

---

_🗓️ 문서 작성일: 2025년 6월 11일_  
_📝 작성자: OpenManager Vibe v5 개발팀_  
_🔄 버전: v5.42.2_

## 🤖 **AI 엔진 통합 아키텍처 v2.0** _(v5.42.4 완료)_

### **🎯 설계 철학: "진정한 AI 분석 시스템"**

- **연극이 아닌 실제**: AI 엔진이 시나리오를 미리 알지 못하고 서버 상태와 컨텍스트만으로 분석
- **하이브리드 접근**: 4종 AI 엔진(MCP, RAG, TensorFlow, Google AI)의 협업 시스템
- **Graceful Degradation**: 개별 엔진 실패 시에도 전체 시스템 안정성 보장

### **🔧 AI 엔진별 구현 상태**

#### **1️⃣ MCP (Model Context Protocol) 엔진**

```typescript
// 환경별 자동 스위치
const MCP_URL =
  process.env.VERCEL || process.env.NODE_ENV === 'production'
    ? process.env.MCP_REMOTE_URL // Render: https://openmanager-vibe-v5.onrender.com
    : process.env.MCP_LOCAL_URL; // Local: http://localhost:3100
```

- **Remote**: Render에서 구동 중인 MCP 서버 연결
- **Local**: 개발 환경 자동 폴백
- **상태**: ✅ 실제 파일시스템/GitHub 도구 연동

#### **2️⃣ RAG (Retrieval-Augmented Generation) 엔진**

```typescript
// 의도적 메모리 모드 설정
if (process.env.RAG_FORCE_MEMORY === 'true') {
  console.log(
    '⏭️ RAG_FORCE_MEMORY 활성화 – PostgresVectorDB를 메모리 모드로 실행'
  );
  this.isInitialized = true; // pgvector 초기화 스킵
  return;
}
```

- **메모리 모드**: 빠른 응답, DB 권한 불필요
- **Supabase 연결**: 프로덕션에서 pgvector 지원 가능
- **상태**: ✅ 3개 문서 기반 지식베이스 운영

#### **3️⃣ TensorFlow 동적 로더**

```typescript
// Graceful Fallback 시스템
export async function loadTf() {
  try {
    if (process.env.VERCEL) {
      tf = await import('@tensorflow/tfjs-node'); // WASM backend
    } else {
      tf = await import('@tensorflow/tfjs-node'); // Native addon
    }
    return tf;
  } catch (moduleError) {
    console.warn('⚠️ TensorFlow 모듈 로드 실패 - 기능 비활성');
    return null; // 호출부에서 null 체크 후 graceful skip
  }
}
```

- **CPU 모드**: Vercel 서버리스 환경 호환
- **모듈 선택적 로드**: 패키지 없어도 빌드 에러 없음
- **상태**: ✅ 개발/프로덕션 환경별 최적화

#### **4️⃣ Google AI API**

- **Gemini 모델**: 기존 설정 유지
- **환경변수**: `GOOGLE_AI_API_KEY` 기반
- **상태**: ✅ API 키 검증 완료, 실제 분석 가능

### **📊 AI Health 통합 모니터링**

```typescript
// GET /api/ai/health - 4종 AI 엔진 통합 상태
{
  "mcp": { "status": "online", "latency": 155 },
  "rag": { "status": "memory_mode", "documents": 3 },
  "tensorflow": { "status": "loaded", "backend": "cpu" },
  "google_ai": { "status": "ready", "model": "gemini-pro" }
}
```

### **🛡️ 안정성 보장 메커니즘**

#### **환경변수 기반 제어**

```bash
# Vercel 프로덕션 설정
RAG_FORCE_MEMORY=true
MCP_REMOTE_URL=https://openmanager-vibe-v5.onrender.com
MCP_LOCAL_URL=http://localhost:3100
```

#### **실패 처리 전략**

- **MCP 실패**: Mock 클라이언트로 폴백, 기본 도구 제공
- **RAG 실패**: 메모리 모드로 자동 전환
- **TensorFlow 실패**: null 반환, 호출부에서 graceful skip
- **Google AI 실패**: 다른 엔진으로 보완 분석

#### **성능 최적화**

- **지연 로딩**: 필요 시점에만 AI 엔진 초기화
- **캐싱 시스템**: 분석 결과 임시 저장으로 응답 속도 향상
- **병렬 처리**: 4종 엔진 독립적 동작, 하나 실패해도 나머지 정상

---
